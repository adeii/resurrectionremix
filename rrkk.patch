
project build/
diff --git a/target/product/generic_no_telephony.mk b/target/product/generic_no_telephony.mk
index 6a5a242d..1e2e6722 100644
--- a/target/product/generic_no_telephony.mk
+++ b/target/product/generic_no_telephony.mk
@@ -27,7 +27,7 @@ PRODUCT_PACKAGES := \
     Camera2 \
     CertInstaller \
     Email \
-    Exchange2 \
+ #  Exchange2 \
     FusedLocation \
     Gallery2 \
     InputDevices \
diff --git a/target/product/large_emu_hw.mk b/target/product/large_emu_hw.mk
index a918c1d9..7ab47c4d 100644
--- a/target/product/large_emu_hw.mk
+++ b/target/product/large_emu_hw.mk
@@ -27,7 +27,7 @@ PRODUCT_PACKAGES := \
     Calendar \
     CertInstaller \
     Email \
-    Exchange2 \
+#   Exchange2 \
     Gallery2 \
     LatinIME \
     Launcher2 \
diff --git a/target/product/sdk.mk b/target/product/sdk.mk
index 1c0e18ec..f1461aba 100644
--- a/target/product/sdk.mk
+++ b/target/product/sdk.mk
@@ -21,7 +21,7 @@ PRODUCT_PACKAGES := \
 	Calculator \
 	DeskClock \
 	Email \
-	Exchange2 \
+#	Exchange2 \
 	FusedLocation \
 	Gallery2 \
 	Keyguard \

project device/huawei/msm7x27a-common/
diff --git a/BoardConfigCommon.mk b/BoardConfigCommon.mk
index c4a7032..3e9615c 100644
--- a/BoardConfigCommon.mk
+++ b/BoardConfigCommon.mk
@@ -42,7 +42,9 @@ TARGET_BOARD_PLATFORM_GPU := qcom-adreno200
 
 ARCH_ARM_HAVE_TLS_REGISTER := true
 
+# Low RAM settings
 TARGET_ARCH_LOWMEM := true
+TARGET_BOOTANIMATION_TEXTURE_CACHE := false
 
 # Qualcomm hardware
 BOARD_USES_QCOM_HARDWARE := true
@@ -99,7 +101,7 @@ BOARD_KERNEL_BASE := 0x00200000
 BOARD_KERNEL_CMDLINE := androidboot.hardware=huawei androidboot.selinux=permissive
 BOARD_PAGE_SIZE := 2048
 TARGET_KERNEL_SOURCE := kernel/huawei/huawei-kernel-3.4
-TARGET_KERNEL_CUSTOM_TOOLCHAIN := linaro-4.7-13.04/bin/arm-linux-gnueabihf-
+#TARGET_KERNEL_CUSTOM_TOOLCHAIN := linaro-4.7-13.04/bin/arm-linux-gnueabihf-
 BOARD_MKBOOTIMG_ARGS := --ramdisk_offset 0x01800000
 
 # Lights
diff --git a/msm7x27a.mk b/msm7x27a.mk
index 15e296d..ed1f8f3 100644
--- a/msm7x27a.mk
+++ b/msm7x27a.mk
@@ -55,6 +55,13 @@ PRODUCT_PACKAGES += \
     gps.msm7x27a
 #    lights.msm7x27a
 
+PRODUCT_PACKAGES += \
+    libqcomfm_jni \
+    qcom.fmradio.xml \
+    FM2 \
+    FMRecord \
+    Chromium
+
 PRODUCT_PACKAGES += \
     com.android.future.usb.accessory \
     hwmac \
@@ -122,12 +129,12 @@ PRODUCT_PROPERTY_OVERRIDES += \
     debug.composition.type=dyn \
     debug.hwc.dynThreshold=1.9 \
     ro.bq.gpu_to_cpu_unsupported=1 \
-    ro.max.fling_velocity=4000 \
+    ro.max.fling_velocity=8000 \
     ro.opengles.version=131072 \
     ro.sf.lcd_density=240
 
 PRODUCT_PROPERTY_OVERRIDES += \
-    dalvik.vm.heapgrowthlimit=48m \
+    dalvik.vm.heapgrowthlimit=52m \
     dalvik.vm.heapsize=128m \
     ro.config.low_ram=true
 
diff --git a/overlay/frameworks/base/core/res/res/values/arrays.xml b/overlay/frameworks/base/core/res/res/values/arrays.xml
index 5b65ae4..5602a1c 100644
--- a/overlay/frameworks/base/core/res/res/values/arrays.xml
+++ b/overlay/frameworks/base/core/res/res/values/arrays.xml
@@ -19,17 +19,4 @@
 -->
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
 
-    <!-- Defines the shutdown options shown in the reboot dialog. -->
-    <array name="shutdown_reboot_options" translatable="false">
-        <item>@string/reboot_reboot</item>
-        <item>@string/reboot_recovery</item>
-    </array>
-
-    <!-- Do not translate. Defines the shutdown actions passed to the kernel.
-         The first item should be empty for regular reboot. -->
-    <string-array name="shutdown_reboot_actions" translatable="false">
-        <item></item>
-        <item>recovery</item>
-    </string-array>
-
 </resources>
diff --git a/overlay/frameworks/base/core/res/res/xml/storage_list.xml b/overlay/frameworks/base/core/res/res/xml/storage_list.xml
index 479c392..3e59fac 100644
--- a/overlay/frameworks/base/core/res/res/xml/storage_list.xml
+++ b/overlay/frameworks/base/core/res/res/xml/storage_list.xml
@@ -38,8 +38,7 @@
                 android:storageDescription="@string/storage_sd_card"
                 android:primary="false"
                 android:removable="true"
-                android:allowMassStorage="true"
-                android:externalApps="true" />
+                android:allowMassStorage="true" />
 
     <storage android:mountPoint="/storage/sdcard0"
                 android:storageDescription="@string/storage_internal"
diff --git a/overlay/packages/apps/Settings/res/values/config.xml b/overlay/packages/apps/Settings/res/values/config.xml
index ab42db6..bb72cd6 100644
--- a/overlay/packages/apps/Settings/res/values/config.xml
+++ b/overlay/packages/apps/Settings/res/values/config.xml
@@ -16,12 +16,6 @@
 
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
 
-    <!-- LED Flashlight -->
-    <bool name="has_led_flash">true</bool>
-
-    <!-- Show Expanded Desktop preference -->
-    <bool name="config_show_expandedDesktop">true</bool>
-
     <!-- Volume Rocker Wake Support. Some devices do not support (PMU) this.
          Setting to false will disable Volume Rocker Wake support -->
     <bool name="config_show_volumeRockerWake">true</bool>
diff --git a/patches/build/0002-Disable-Emulator-to-speed-up-build-times.patch b/patches/build/0002-Disable-Emulator-to-speed-up-build-times.patch
deleted file mode 100644
index a52b264..0000000
--- a/patches/build/0002-Disable-Emulator-to-speed-up-build-times.patch
+++ /dev/null
@@ -1,39 +0,0 @@
-From 6fda02552e9879e9f3e4061b14930bd692ff4d32 Mon Sep 17 00:00:00 2001
-From: Kyle Harrison <khwebmail@gmail.com>
-Date: Thu, 13 Feb 2014 20:50:52 +0000
-Subject: [PATCH] Disable Emulator to speed up build times
-
----
- core/main.mk | 15 ---------------
- 1 file changed, 15 deletions(-)
-
-diff --git a/core/main.mk b/core/main.mk
-index 7c67afc..8a924db 100644
---- a/core/main.mk
-+++ b/core/main.mk
-@@ -182,22 +182,7 @@ $(error stop)
- endif
- 
- ifndef BUILD_EMULATOR
--ifeq (darwin,$(HOST_OS))
--GCC_REALPATH = $(realpath $(shell which $(HOST_CC)))
--ifneq ($(findstring llvm-gcc,$(GCC_REALPATH)),)
--  # Using LLVM GCC results in a non functional emulator due to it
--  # not honouring global register variables
--  $(warning ****************************************)
--  $(warning * gcc is linked to llvm-gcc which will *)
--  $(warning * not create a useable emulator.       *)
--  $(warning ****************************************)
-   BUILD_EMULATOR := false
--else
--  BUILD_EMULATOR := true
--endif
--else   # HOST_OS is not darwin
--  BUILD_EMULATOR := true
--endif  # HOST_OS is darwin
- endif
- 
- $(shell echo 'VERSIONS_CHECKED := $(VERSION_CHECK_SEQUENCE_NUMBER)' \
--- 
-1.8.5.4
-
diff --git a/patches/external_skia/0001-make-setdevice-public.patch b/patches/external_skia/0001-make-setdevice-public.patch
deleted file mode 100644
index ba4b48f..0000000
--- a/patches/external_skia/0001-make-setdevice-public.patch
+++ /dev/null
@@ -1,53 +0,0 @@
-From 390cf91d1aa20f9b0d65e7c07d16378eb8d803e1 Mon Sep 17 00:00:00 2001
-From: WinSuk <winsuk@winsuk.net>
-Date: Sat, 7 Jun 2014 00:04:35 -0700
-Subject: [PATCH] SkCanvas: Make setDevice public again
-
-Needed to build external/webkit
-
-Change-Id: Ia7c8b4d53f19a0a7bb536f241472ce824a1eeb77
----
- include/core/SkCanvas.h | 20 +++++++++-----------
- 1 file changed, 9 insertions(+), 11 deletions(-)
-
-diff --git a/include/core/SkCanvas.h b/include/core/SkCanvas.h
-index 5a5cc65..069b95a 100644
---- a/include/core/SkCanvas.h
-+++ b/include/core/SkCanvas.h
-@@ -1007,6 +1007,15 @@ class SK_API SkCanvas : public SkRefCnt {
-         bool              fDone;
-     };
- 
-+    /**
-+     DEPRECATED -- need to remove when subclass stop relying on it.
-+
-+     Specify a device for this canvas to draw into. If it is not null, its
-+     reference count is incremented. If the canvas was already holding a
-+     device, its reference count is decremented. The new device is returned.
-+     */
-+    virtual SkBaseDevice* setDevice(SkBaseDevice* device);
-+
- protected:
-     // Returns the canvas to be used by DrawIter. Default implementation
-     // returns this. Subclasses that encapsulate an indirect canvas may
-@@ -1028,17 +1037,6 @@ class SK_API SkCanvas : public SkRefCnt {
-     // can perform copy-on-write or invalidate any cached images
-     void predrawNotify();
- 
--    /**
--     DEPRECATED -- need to remove when subclass stop relying on it.
--     Marked as 'protected' to avoid new clients using this before we can
--     completely remove it.
--
--     Specify a device for this canvas to draw into. If it is not null, its
--     reference count is incremented. If the canvas was already holding a
--     device, its reference count is decremented. The new device is returned.
--     */
--    virtual SkBaseDevice* setDevice(SkBaseDevice* device);
--
- private:
-     class MCRec;
- 
--- 
-1.9.3
-
diff --git a/patches/frameworks_base/0002-add-freememoryfortests.patch b/patches/frameworks_base/0002-add-freememoryfortests.patch
deleted file mode 100644
index 4d40478..0000000
--- a/patches/frameworks_base/0002-add-freememoryfortests.patch
+++ /dev/null
@@ -1,31 +0,0 @@
-From 6ffea3cb792890ad0cca970f70e4723e82009780 Mon Sep 17 00:00:00 2001
-From: WinSuk <winsuk@winsuk.net>
-Date: Sat, 7 Jun 2014 00:07:06 -0700
-Subject: [PATCH] WebViewClassic: Add freeMemoryForTests
-
-Since the 4.4.3 merge, an override of freeMemoryForTests is required to build
-
-Change-Id: I81c13f4d4f39332ccce3616881ec6e84605ef0ee
----
- core/java/android/webkit/WebViewClassic.java | 5 +++++
- 1 file changed, 5 insertions(+)
-
-diff --git a/core/java/android/webkit/WebViewClassic.java b/core/java/android/webkit/WebViewClassic.java
-index 3c377d3..09f40e3 100644
---- a/core/java/android/webkit/WebViewClassic.java
-+++ b/core/java/android/webkit/WebViewClassic.java
-@@ -1363,6 +1363,11 @@ public String getDefaultUserAgent(Context context) {
-         }
- 
-         @Override
-+        public void freeMemoryForTests() {
-+            WebViewFactory.getProvider().getStatics().freeMemoryForTests();
-+        }
-+
-+        @Override
-         public void setWebContentsDebuggingEnabled(boolean enable) {
-             // no-op for WebViewClassic.
-         }
--- 
-1.9.3
-
diff --git a/patches/frameworks_base/0003-clearall-recent-apps.patch b/patches/frameworks_base/0003-clearall-recent-apps.patch
deleted file mode 100644
index b1d3e49..0000000
--- a/patches/frameworks_base/0003-clearall-recent-apps.patch
+++ /dev/null
@@ -1,199 +0,0 @@
-From 6471aee7bec8e8d2eb179db9605d3b6a12ac48f6 Mon Sep 17 00:00:00 2001
-From: D4rKn3sSyS <jedga_95@outlook.com>
-Date: Sat, 15 Sep 2012 15:00:48 -0500
-Subject: [PATCH] "Clear all" button on recent apps
-
-Port forward from cm-10.2
-
-Change-Id: I9ebcf22f85957f61caefb14e0efd4cf2978d92cd
----
- .../res/layout-land/status_bar_recent_panel.xml       | 12 +++++++++++-
- .../SystemUI/res/layout/status_bar_recent_panel.xml   | 12 +++++++++++-
- .../systemui/recent/RecentsHorizontalScrollView.java  | 19 +++++++++++++++++++
- .../com/android/systemui/recent/RecentsPanelView.java | 14 +++++++++++++-
- .../systemui/recent/RecentsVerticalScrollView.java    | 19 +++++++++++++++++++
- 5 files changed, 73 insertions(+), 3 deletions(-)
-
-diff --git a/packages/SystemUI/res/layout-land/status_bar_recent_panel.xml b/packages/SystemUI/res/layout-land/status_bar_recent_panel.xml
-index b2ba25a..ccd507e 100644
---- a/packages/SystemUI/res/layout-land/status_bar_recent_panel.xml
-+++ b/packages/SystemUI/res/layout-land/status_bar_recent_panel.xml
-@@ -33,7 +33,8 @@
-         android:layout_height="match_parent"
-         android:layout_alignParentBottom="true"
-         android:clipToPadding="false"
--        android:clipChildren="false">
-+        android:clipChildren="false"
-+        android:fitsSystemWindows="true">
- 
-         <com.android.systemui.recent.RecentsHorizontalScrollView android:id="@+id/recents_container"
-             android:layout_width="wrap_content"
-@@ -54,6 +55,15 @@
- 
-         </com.android.systemui.recent.RecentsHorizontalScrollView>
- 
-+        <ImageView
-+            android:id="@+id/recents_clear"
-+            android:clickable="true"
-+            android:layout_width="50dp"
-+            android:layout_height="50dp"
-+            android:scaleType="center"
-+            android:layout_gravity="top|right"
-+            android:src="@drawable/ic_notify_clear" />
-+
-     </FrameLayout>
- 
-     <include layout="@layout/status_bar_no_recent_apps"
-diff --git a/packages/SystemUI/res/layout/status_bar_recent_panel.xml b/packages/SystemUI/res/layout/status_bar_recent_panel.xml
-index e41475b..4d89ece 100644
---- a/packages/SystemUI/res/layout/status_bar_recent_panel.xml
-+++ b/packages/SystemUI/res/layout/status_bar_recent_panel.xml
-@@ -31,7 +31,8 @@
-         android:background="@drawable/status_bar_recents_background"
-         android:layout_width="match_parent"
-         android:layout_height="match_parent"
--        android:layout_alignParentBottom="true">
-+        android:layout_alignParentBottom="true"
-+        android:fitsSystemWindows="true">
- 
-         <com.android.systemui.recent.RecentsVerticalScrollView
-             android:id="@+id/recents_container"
-@@ -58,6 +59,15 @@
- 
-         </com.android.systemui.recent.RecentsVerticalScrollView>
- 
-+        <ImageView
-+            android:id="@+id/recents_clear"
-+            android:clickable="true"
-+            android:layout_width="50dp"
-+            android:layout_height="50dp"
-+            android:scaleType="center"
-+            android:layout_gravity="top|right"
-+            android:src="@drawable/ic_notify_clear" />
-+
-     </FrameLayout>
- 
-     <include layout="@layout/status_bar_no_recent_apps"
-diff --git a/packages/SystemUI/src/com/android/systemui/recent/RecentsHorizontalScrollView.java b/packages/SystemUI/src/com/android/systemui/recent/RecentsHorizontalScrollView.java
-index 9c4c582..ed14063 100644
---- a/packages/SystemUI/src/com/android/systemui/recent/RecentsHorizontalScrollView.java
-+++ b/packages/SystemUI/src/com/android/systemui/recent/RecentsHorizontalScrollView.java
-@@ -22,6 +22,7 @@
- import android.database.DataSetObserver;
- import android.graphics.Canvas;
- import android.graphics.Rect;
-+import android.os.Handler;
- import android.util.AttributeSet;
- import android.util.DisplayMetrics;
- import android.util.FloatMath;
-@@ -178,6 +179,24 @@ public void removeViewInLayout(final View view) {
-         dismissChild(view);
-     }
- 
-+    @Override
-+    public void removeAllViewsInLayout() {
-+        int count = mLinearLayout.getChildCount();
-+        int scrollX = getScrollX();
-+        for (int i = 0, delayCounter = 0; i < count; i++) {
-+            final View child = mLinearLayout.getChildAt(i);
-+            if (child.getRight() > scrollX) {
-+                delayCounter++;
-+            }
-+            postDelayed(new Runnable() {
-+                @Override
-+                public void run() {
-+                    dismissChild(child);
-+                }
-+            }, delayCounter * 150);
-+        }
-+    }
-+
-     public boolean onInterceptTouchEvent(MotionEvent ev) {
-         if (DEBUG) Log.v(TAG, "onInterceptTouchEvent()");
-         return mSwipeHelper.onInterceptTouchEvent(ev) ||
-diff --git a/packages/SystemUI/src/com/android/systemui/recent/RecentsPanelView.java b/packages/SystemUI/src/com/android/systemui/recent/RecentsPanelView.java
-index 788e843..6d8997a 100644
---- a/packages/SystemUI/src/com/android/systemui/recent/RecentsPanelView.java
-+++ b/packages/SystemUI/src/com/android/systemui/recent/RecentsPanelView.java
-@@ -92,6 +92,7 @@
-     private boolean mFitThumbnailToXY;
-     private int mRecentItemLayoutId;
-     private boolean mHighEndGfx;
-+    private ImageView mClearRecents;
- 
-     public static interface RecentsScrollView {
-         public int numItemsInOneScreenful();
-@@ -101,6 +102,7 @@
-         public View findViewForTask(int persistentTaskId);
-         public void drawFadedEdges(Canvas c, int left, int right, int top, int bottom);
-         public void setOnScrollListener(Runnable listener);
-+        public void removeAllViewsInLayout();
-     }
- 
-     private final class OnLongClickDelegate implements View.OnLongClickListener {
-@@ -340,7 +342,7 @@ private void showImpl(boolean show) {
-                     && (mRecentTaskDescriptions.size() == 0);
-             mRecentsNoApps.setAlpha(1f);
-             mRecentsNoApps.setVisibility(noApps ? View.VISIBLE : View.INVISIBLE);
--
-+            mClearRecents.setVisibility(noApps ? View.GONE : View.VISIBLE);
-             onAnimationEnd(null);
-             setFocusable(true);
-             setFocusableInTouchMode(true);
-@@ -447,6 +449,16 @@ public void run() {
-         mRecentsScrim = findViewById(R.id.recents_bg_protect);
-         mRecentsNoApps = findViewById(R.id.recents_no_apps);
- 
-+        mClearRecents = (ImageView) findViewById(R.id.recents_clear);
-+        if (mClearRecents != null){
-+            mClearRecents.setOnClickListener(new OnClickListener() {
-+                @Override
-+                public void onClick(View v) {
-+                    mRecentsContainer.removeAllViewsInLayout();
-+                }
-+            });
-+        }
-+
-         if (mRecentsScrim != null) {
-             mHighEndGfx = ActivityManager.isHighEndGfx();
-             if (!mHighEndGfx) {
-diff --git a/packages/SystemUI/src/com/android/systemui/recent/RecentsVerticalScrollView.java b/packages/SystemUI/src/com/android/systemui/recent/RecentsVerticalScrollView.java
-index 6dddc39..5595863 100644
---- a/packages/SystemUI/src/com/android/systemui/recent/RecentsVerticalScrollView.java
-+++ b/packages/SystemUI/src/com/android/systemui/recent/RecentsVerticalScrollView.java
-@@ -21,6 +21,7 @@
- import android.content.res.Configuration;
- import android.database.DataSetObserver;
- import android.graphics.Canvas;
-+import android.os.Handler;
- import android.util.AttributeSet;
- import android.util.DisplayMetrics;
- import android.util.FloatMath;
-@@ -185,6 +186,24 @@ public void removeViewInLayout(final View view) {
-         dismissChild(view);
-     }
- 
-+    @Override
-+    public void removeAllViewsInLayout() {
-+        int count = mLinearLayout.getChildCount();
-+        int scrollY = getScrollY();
-+        for (int i = 0, delayCounter = 0; i < count; i++) {
-+            final View child = mLinearLayout.getChildAt(i);
-+            if (child.getBottom() > scrollY) {
-+                delayCounter++;
-+            }
-+            postDelayed(new Runnable() {
-+                @Override
-+                public void run() {
-+                    dismissChild(child);
-+                }
-+            }, delayCounter * 150);
-+        }
-+    }
-+
-     public boolean onInterceptTouchEvent(MotionEvent ev) {
-         if (DEBUG) Log.v(TAG, "onInterceptTouchEvent()");
-         return mSwipeHelper.onInterceptTouchEvent(ev) ||
--- 
-1.8.5.1
-
diff --git a/patches/frameworks_base/0004-force-translucent-statusbar.patch b/patches/frameworks_base/0004-force-translucent-statusbar.patch
deleted file mode 100644
index 0466f24..0000000
--- a/patches/frameworks_base/0004-force-translucent-statusbar.patch
+++ /dev/null
@@ -1,16 +0,0 @@
-From: ChepKun <ProgrammerKun@gmail.com>
-Subject: Force translucent status bar without high end gfx
-
-diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/phone/BarTransitions.java b/packages/SystemUI/src/com/android/systemui/statusbar/phone/BarTransitions.java
-index 20177da..428af24 100644
---- a/packages/SystemUI/src/com/android/systemui/statusbar/phone/BarTransitions.java
-+++ b/packages/SystemUI/src/com/android/systemui/statusbar/phone/BarTransitions.java
-@@ -37,7 +37,7 @@ public class BarTransitions {
-     private static final boolean DEBUG = false;
-     private static final boolean DEBUG_COLORS = false;
- 
--    public static final boolean HIGH_END = ActivityManager.isHighEndGfx();
-+    public static final boolean HIGH_END = true;
- 
-     public static final int MODE_OPAQUE = 0;
-     public static final int MODE_SEMI_TRANSPARENT = 1;
diff --git a/patches/frameworks_base/0005-dont-disable-lockscreen-widgets-on-low-memory-devices.patch b/patches/frameworks_base/0005-dont-disable-lockscreen-widgets-on-low-memory-devices.patch
deleted file mode 100644
index a2415fa..0000000
--- a/patches/frameworks_base/0005-dont-disable-lockscreen-widgets-on-low-memory-devices.patch
+++ /dev/null
@@ -1,44 +0,0 @@
-From a534bbc2e56f92461f6c75b00ddfb04fea9f63cd Mon Sep 17 00:00:00 2001
-From: Kyle Harrison <khwebmail@gmail.com>
-Date: Thu, 17 Jul 2014 19:15:04 +0100
-Subject: [PATCH] don't disable lockscreen widgets on low memory devices (1/2)
-
----
- packages/Keyguard/src/com/android/keyguard/KeyguardHostView.java    | 3 +--
- packages/Keyguard/src/com/android/keyguard/KeyguardWidgetFrame.java | 3 +--
- 2 files changed, 2 insertions(+), 4 deletions(-)
-
-diff --git a/packages/Keyguard/src/com/android/keyguard/KeyguardHostView.java b/packages/Keyguard/src/com/android/keyguard/KeyguardHostView.java
-index 93e12c3..29b2699 100644
---- a/packages/Keyguard/src/com/android/keyguard/KeyguardHostView.java
-+++ b/packages/Keyguard/src/com/android/keyguard/KeyguardHostView.java
-@@ -731,11 +731,10 @@ public class KeyguardHostView extends KeyguardViewBase {
-     }
- 
-     private boolean widgetsDisabled() {
--        boolean disabledByLowRamDevice = ActivityManager.isLowRamDeviceStatic();
-         boolean disabledByDpm =
-                 (mDisabledFeatures & DevicePolicyManager.KEYGUARD_DISABLE_WIDGETS_ALL) != 0;
-         boolean disabledByUser = !mLockPatternUtils.getWidgetsEnabled();
--        return disabledByLowRamDevice || disabledByDpm || disabledByUser;
-+        return disabledByDpm || disabledByUser;
-     }
- 
-     private boolean cameraDisabledByDpm() {
-diff --git a/packages/Keyguard/src/com/android/keyguard/KeyguardWidgetFrame.java b/packages/Keyguard/src/com/android/keyguard/KeyguardWidgetFrame.java
-index 5fcf0fc..ea1620d 100644
---- a/packages/Keyguard/src/com/android/keyguard/KeyguardWidgetFrame.java
-+++ b/packages/Keyguard/src/com/android/keyguard/KeyguardWidgetFrame.java
-@@ -149,8 +149,7 @@ public class KeyguardWidgetFrame extends FrameLayout {
-         boolean disabledByDpm =
-                 (disabledFeatures & DevicePolicyManager.KEYGUARD_DISABLE_WIDGETS_ALL) != 0;
-         boolean disabledByUser = !lockPatternUtils.getWidgetsEnabled();
--        boolean disabledByLowRamDevice = ActivityManager.isLowRamDeviceStatic();
--        return disabledByLowRamDevice || disabledByDpm || disabledByUser;
-+        return disabledByDpm || disabledByUser;
-     }
- 
-     private int getDisabledFeatures(DevicePolicyManager dpm, LockPatternUtils lockPatternUtils) {
--- 
-2.0.1
-
diff --git a/patches/frameworks_base/0006-Hack-for-no-network-bug.patch b/patches/frameworks_base/0006-Hack-for-no-network-bug.patch
deleted file mode 100644
index 2f817c8..0000000
--- a/patches/frameworks_base/0006-Hack-for-no-network-bug.patch
+++ /dev/null
@@ -1,25 +0,0 @@
-From 00d6eeaadb920f70c58003cf9438ef019ef196f1 Mon Sep 17 00:00:00 2001
-From: Kyle Harrison <khwebmail@gmail.com>
-Date: Thu, 7 Aug 2014 14:20:52 +0100
-Subject: [PATCH] Hack for "no network" bug
-
----
- .../src/com/android/systemui/statusbar/policy/NetworkController.java    | 2 ++
- 1 file changed, 2 insertions(+)
-
-diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/policy/NetworkController.java b/packages/SystemUI/src/com/android/systemui/statusbar/policy/NetworkController.java
-index 41de93b..7ac2978 100644
---- a/packages/SystemUI/src/com/android/systemui/statusbar/policy/NetworkController.java
-+++ b/packages/SystemUI/src/com/android/systemui/statusbar/policy/NetworkController.java
-@@ -1058,6 +1058,8 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
-                     // Tablets, basically
-                     mobileLabel = "";
-                 }
-+            } else if (hasService() || emergencyOnly) {
-+                    mobileLabel = mNetworkName;
-             } else {
-                 mobileLabel
-                     = context.getString(R.string.status_bar_settings_signal_meter_disconnected);
--- 
-2.0.4
-
diff --git a/patches/frameworks_webview/0001-add-classic-webview.patch b/patches/frameworks_webview/0001-add-classic-webview.patch
deleted file mode 100644
index 55d40e2..0000000
--- a/patches/frameworks_webview/0001-add-classic-webview.patch
+++ /dev/null
@@ -1,26 +0,0 @@
-From e67ef8bff1265001b915fa9020177414be4b3641 Mon Sep 17 00:00:00 2001
-From: Daz Jones <yuki@thebronasium.com>
-Date: Sat, 21 Dec 2013 13:50:36 +0000
-Subject: [PATCH] Build libwebcore instead of webviewchromium
-
-Change-Id: I140b90336f921edacdfb98da81c2d1945404fc7f
----
- Android.mk | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
-diff --git a/Android.mk b/Android.mk
-index 2effc4e..2258968 100644
---- a/Android.mk
-+++ b/Android.mk
-@@ -22,7 +22,7 @@ include $(CLEAR_VARS)
- 
- LOCAL_MODULE := webview
- LOCAL_MODULE_TAGS := optional
--LOCAL_REQUIRED_MODULES := webviewchromium
-+LOCAL_REQUIRED_MODULES := libwebcore
- 
- include $(BUILD_PHONY_PACKAGE)
- 
--- 
-1.8.1.2
-
diff --git a/patches/hardware_libhardware/0001-add-sourcetransform.patch b/patches/hardware_libhardware/0001-add-sourcetransform.patch
deleted file mode 100644
index 4271c99..0000000
--- a/patches/hardware_libhardware/0001-add-sourcetransform.patch
+++ /dev/null
@@ -1,34 +0,0 @@
-From 41735f87a8db22f2037a62658f01a6fdb069cc62 Mon Sep 17 00:00:00 2001
-From: "Arun Kumar K.R" <akumarkr@codeaurora.org>
-Date: Fri, 17 Aug 2012 11:23:21 -0700
-Subject: [PATCH] hwcomposer: Add sourceTransform to hwc_layer_t
-
-sourceTransform has the source buffer transform which can used to
-apply rotation on displays whose orientation is fixed(HDMI).
-
-CRs-fixed: 387357
-Change-Id: I26eb2de76b3548634a80ca8b98547c6fdfe145ea
-(cherry picked from commit f16aed381eb2a7232bf576c1d77cdad61be54419)
----
- include/hardware/hwcomposer_v0.h | 5 +++++
- 1 file changed, 5 insertions(+)
-
-diff --git a/include/hardware/hwcomposer_v0.h b/include/hardware/hwcomposer_v0.h
-index 473819b..6e9308d 100644
---- a/include/hardware/hwcomposer_v0.h
-+++ b/include/hardware/hwcomposer_v0.h
-@@ -97,6 +97,11 @@ typedef struct hwc_layer {
-              * not changed. */
-             buffer_handle_t handle;
- 
-+#ifdef QCOM_HARDWARE
-+            /* source transform of the buffer */
-+            uint32_t sourceTransform;
-+#endif
-+
-             /* transformation to apply to the buffer during composition */
-             uint32_t transform;
- 
--- 
-1.8.4
-
diff --git a/patches/hardware_libhardware_legacy/0001-custom-wifi.patch b/patches/hardware_libhardware_legacy/0001-custom-wifi.patch
deleted file mode 100644
index 489955e..0000000
--- a/patches/hardware_libhardware_legacy/0001-custom-wifi.patch
+++ /dev/null
@@ -1,32 +0,0 @@
-From 4644181d6371b9dad8c991b2104f5a18e9870e7d Mon Sep 17 00:00:00 2001
-From: Daz Jones <yuki@thebronasium.com>
-Date: Sat, 27 Jul 2013 02:40:36 +0100
-Subject: [PATCH] wifi: add support for custom Wi-Fi implementations
-
-Change-Id: Id464138cdb679fc4550914a32d9c71131bdfffb3
----
- wifi/Android.mk | 8 +++++++-
- 1 file changed, 7 insertions(+), 1 deletion(-)
-
-diff --git a/wifi/Android.mk b/wifi/Android.mk
-index 51afe3a..788520f 100644
---- a/wifi/Android.mk
-+++ b/wifi/Android.mk
-@@ -43,7 +43,13 @@ ifdef WIFI_EXT_MODULE_NAME
- LOCAL_CFLAGS += -DWIFI_EXT_MODULE_NAME=\"$(WIFI_EXT_MODULE_NAME)\"
- endif
- 
--LOCAL_SRC_FILES += wifi/wifi.c
-+ifeq ($(TARGET_CUSTOM_WIFI),)
-+       LOCAL_SRC_FILES += \
-+               wifi/wifi.c
-+else
-+       LOCAL_SRC_FILES += \
-+               $(TARGET_CUSTOM_WIFI)
-+endif
- 
- ifeq ($(BOARD_HAVE_SAMSUNG_WIFI),true)
- LOCAL_CFLAGS += -DSAMSUNG_WIFI
--- 
-1.8.1.2
-
diff --git a/patches/hardware_libhardware_legacy/0002-audio-formats.patch b/patches/hardware_libhardware_legacy/0002-audio-formats.patch
deleted file mode 100644
index 18c6158..0000000
--- a/patches/hardware_libhardware_legacy/0002-audio-formats.patch
+++ /dev/null
@@ -1,33 +0,0 @@
-From ea13176e3431c114f1da53b1f301758db9eb73df Mon Sep 17 00:00:00 2001
-From: sakindia123 <sa6915@gmail.com>
-Date: Sat, 6 Jul 2013 06:04:27 +0100
-Subject: [PATCH] audio_policy: Add EVRCB & EVRCWB formats
-
-  * needed for msm7x27a and msm8660
-  * needed to compile audio hal from caf
-
-Change-Id: Ibac3cf0b58de0bb6ee621e0498322318464492a0
----
- include/hardware_legacy/AudioSystemLegacy.h | 6 ++++++
- 1 file changed, 6 insertions(+)
-
-diff --git a/include/hardware_legacy/AudioSystemLegacy.h b/include/hardware_legacy/AudioSystemLegacy.h
-index 6296b8b..a3241be 100644
---- a/include/hardware_legacy/AudioSystemLegacy.h
-+++ b/include/hardware_legacy/AudioSystemLegacy.h
-@@ -133,6 +133,12 @@ public:
-         HE_AAC_V1           = 0x05000000,
-         HE_AAC_V2           = 0x06000000,
-         VORBIS              = 0x07000000,
-+#ifdef QCOM_HARDWARE
-+        EVRC                = 0x08000000,
-+        QCELP               = 0x09000000,
-+        EVRCB               = 0x10000000,
-+        EVRCWB              = 0x11000000,
-+#endif
-         MAIN_FORMAT_MASK    = 0xFF000000,
-         SUB_FORMAT_MASK     = 0x00FFFFFF,
-         // Aliases
--- 
-1.8.1.2
-
diff --git a/patches/packages_apps_Browser/0001-no-text-autosizing-pls.patch b/patches/packages_apps_Browser/0001-no-text-autosizing-pls.patch
deleted file mode 100644
index 8f30425..0000000
--- a/patches/packages_apps_Browser/0001-no-text-autosizing-pls.patch
+++ /dev/null
@@ -1,36 +0,0 @@
-From 567a8f3835c52dcfcdfb4be4e0502bea58a255ae Mon Sep 17 00:00:00 2001
-From: Daz Jones <yuki@thebronasium.com>
-Date: Wed, 12 Feb 2014 15:54:15 +0100
-Subject: [PATCH] Revert "Replace removed NARROW_COLUMNS layout mode with
- TEXT_AUTOSIZING"
-
-This reverts commit a31cfea37c3892f68807d2df52c9d482e9e1f8f6.
----
- src/com/android/browser/BrowserSettings.java | 4 ++--
- 1 file changed, 2 insertions(+), 2 deletions(-)
-
-diff --git a/src/com/android/browser/BrowserSettings.java b/src/com/android/browser/BrowserSettings.java
-index 8865f32..69d51a4 100644
---- a/src/com/android/browser/BrowserSettings.java
-+++ b/src/com/android/browser/BrowserSettings.java
-@@ -358,7 +358,7 @@ public class BrowserSettings implements OnSharedPreferenceChangeListener,
-     public LayoutAlgorithm getLayoutAlgorithm() {
-         LayoutAlgorithm layoutAlgorithm = LayoutAlgorithm.NORMAL;
-         if (autofitPages()) {
--            layoutAlgorithm = LayoutAlgorithm.TEXT_AUTOSIZING;
-+            layoutAlgorithm = LayoutAlgorithm.NARROW_COLUMNS;
-         }
-         if (isDebugEnabled()) {
-             if (isSmallScreen()) {
-@@ -367,7 +367,7 @@ public class BrowserSettings implements OnSharedPreferenceChangeListener,
-                 if (isNormalLayout()) {
-                     layoutAlgorithm = LayoutAlgorithm.NORMAL;
-                 } else {
--                    layoutAlgorithm = LayoutAlgorithm.TEXT_AUTOSIZING;
-+                    layoutAlgorithm = LayoutAlgorithm.NARROW_COLUMNS;
-                 }
-             }
-         }
--- 
-1.8.1.2
-
diff --git a/patches/packages_apps_Settings/0001-vold-switchable-pair.patch b/patches/packages_apps_Settings/0001-vold-switchable-pair.patch
deleted file mode 100644
index 916a31e..0000000
--- a/patches/packages_apps_Settings/0001-vold-switchable-pair.patch
+++ /dev/null
@@ -1,152 +0,0 @@
-From fdd6e1144941717840a42c1f6af2036ca567e30c Mon Sep 17 00:00:00 2001
-From: Kyle Harrison <khwebmail@gmail.com>
-Date: Thu, 16 Jan 2014 12:21:59 +0000
-Subject: [PATCH 1/2] Add setting for Vold Switchable Pair (2/2)
-
----
- res/values/slim_strings.xml                     |  7 ++++
- res/xml/device_info_memory.xml                  |  5 +++
- src/com/android/settings/deviceinfo/Memory.java | 54 ++++++++++++++++++++++++-
- 3 files changed, 65 insertions(+), 1 deletion(-)
-
-diff --git a/res/values/slim_strings.xml b/res/values/slim_strings.xml
-index 1a6dd52..9c7d770 100644
---- a/res/values/slim_strings.xml
-+++ b/res/values/slim_strings.xml
-@@ -1090,6 +1090,13 @@ two in order to insert additional control points. \'Remove\' deletes the selecte
-     <!-- Minimum Vibration Duration -->
-     <string name="minimum_vibration_duration">Minimum vibration duration</string>
- 
-+    <!-- Vold Switchable Pair -->
-+    <string name="storage_switch_title">Use external SD as primary</string>
-+    <string name="storage_switch_summary_off">Using expanded internal storage for apps and media</string>
-+    <string name="storage_switch_summary_on">Using SD Card for apps and media</string>
-+    <string name="reboot_prompt_title">Reboot required</string>
-+    <string name="reboot_prompt_message">In order to apply the changed configuration, a reboot is required.\n\nDo you want to reboot now?</string>
-+
-     <!-- ListView animation -->
-     <string name="interface_settings_animation_title">Animation options</string>
-     <string name="listview_animation_title">ListView animation</string>
-diff --git a/res/xml/device_info_memory.xml b/res/xml/device_info_memory.xml
-index 47be229..688efae 100644
---- a/res/xml/device_info_memory.xml
-+++ b/res/xml/device_info_memory.xml
-@@ -16,6 +16,11 @@
- 
- <PreferenceScreen xmlns:android="http://schemas.android.com/apk/res/android"
-         android:title="@string/storage_settings_title">
-+    <CheckBoxPreference
-+        android:key="key_switch_storage"
-+        android:title="@string/storage_switch_title"
-+        android:summaryOn="@string/storage_switch_summary_on"
-+        android:summaryOff="@string/storage_switch_summary_off" />
- 
- <!-- Preference categories are dynamically created based on the list of available storage volumes -->
- 
-diff --git a/src/com/android/settings/deviceinfo/Memory.java b/src/com/android/settings/deviceinfo/Memory.java
-index a604eea..4bb00f1 100644
---- a/src/com/android/settings/deviceinfo/Memory.java
-+++ b/src/com/android/settings/deviceinfo/Memory.java
-@@ -32,19 +32,23 @@ import android.hardware.usb.UsbManager;
- import android.os.Bundle;
- import android.os.Environment;
- import android.os.IBinder;
-+import android.os.PowerManager;
- import android.os.RemoteException;
- import android.os.ServiceManager;
-+import android.os.SystemProperties;
- import android.os.UserManager;
- import android.os.storage.IMountService;
- import android.os.storage.StorageEventListener;
- import android.os.storage.StorageManager;
- import android.os.storage.StorageVolume;
-+import android.preference.CheckBoxPreference;
- import android.preference.ListPreference;
- import android.preference.Preference;
- import android.preference.PreferenceActivity;
- import android.preference.PreferenceScreen;
- import android.preference.Preference.OnPreferenceChangeListener;
- import android.provider.Settings;
-+import android.text.TextUtils;
- import android.util.Log;
- import android.view.Menu;
- import android.view.MenuInflater;
-@@ -87,6 +91,10 @@ public class Memory extends SettingsPreferenceFragment
-     private UsbManager mUsbManager;
- 
-     private ArrayList<StorageVolumePreferenceCategory> mCategories = Lists.newArrayList();
-+    private static final String KEY_SWITCH_STORAGE = "key_switch_storage";
-+    private static final String VOLD_SWITCH_PERSIST_PROP = "persist.sys.vold.switchexternal";
-+    private static final String VOLD_SWITCHABLEPAIR_PROP = "persist.sys.vold.switchablepair";
-+    private CheckBoxPreference mSwitchStoragePref;
- 
-     @Override
-     public void onCreate(Bundle icicle) {
-@@ -101,6 +109,27 @@ public class Memory extends SettingsPreferenceFragment
- 
-         addPreferencesFromResource(R.xml.device_info_memory);
- 
-+        String voldswitch = SystemProperties.get(VOLD_SWITCH_PERSIST_PROP, "0");
-+        mSwitchStoragePref = (CheckBoxPreference) findPreference(KEY_SWITCH_STORAGE);
-+        mSwitchStoragePref.setChecked("1".equals(voldswitch));
-+        if (!Environment.isExternalStorageEmulated()) {
-+            Log.i(TAG, "Checking to see if vold switch is possible on this device.");
-+            String PRIMARY_STORAGE = System.getenv("EXTERNAL_STORAGE");
-+            String SECONDARY_STORAGE = System.getenv("SECONDARY_STORAGE");
-+            if (!TextUtils.isEmpty(PRIMARY_STORAGE) && !TextUtils.isEmpty(SECONDARY_STORAGE)) {
-+                SystemProperties.set(VOLD_SWITCHABLEPAIR_PROP, PRIMARY_STORAGE + ',' +
-+                        SECONDARY_STORAGE);
-+                Log.i(TAG, "Setting persist.sys.vold.switchablepair=" + PRIMARY_STORAGE + ',' +
-+                        SECONDARY_STORAGE);
-+            } else {
-+                Log.i(TAG, "Vold switch not possible on this device.");
-+            }
-+        }
-+
-+        if (SystemProperties.get(VOLD_SWITCHABLEPAIR_PROP).equals("")) {
-+            removePreference(KEY_SWITCH_STORAGE);
-+        }
-+
-         addCategory(StorageVolumePreferenceCategory.buildForInternal(context));
- 
-         final StorageVolume[] storageVolumes = mStorageManager.getVolumeList();
-@@ -228,7 +257,13 @@ public class Memory extends SettingsPreferenceFragment
- 
-     @Override
-     public boolean onPreferenceTreeClick(PreferenceScreen preferenceScreen, Preference preference) {
--        if (StorageVolumePreferenceCategory.KEY_CACHE.equals(preference.getKey())) {
-+        if(preference == mSwitchStoragePref) {
-+            Log.d(TAG,"Setting persist.sys.vold.switchexternal to "+(
-+                    mSwitchStoragePref.isChecked() ? "1" : "0"));
-+            SystemProperties.set(VOLD_SWITCH_PERSIST_PROP,
-+                    mSwitchStoragePref.isChecked() ? "1" : "0");
-+            showRebootPrompt();
-+        } else if (StorageVolumePreferenceCategory.KEY_CACHE.equals(preference.getKey())) {
-             ConfirmClearCacheFragment.show(this);
-             return true;
-         }
-@@ -453,4 +488,21 @@ public class Memory extends SettingsPreferenceFragment
-             return builder.create();
-         }
-     }
-+
-+    private void showRebootPrompt() {
-+        AlertDialog dialog = new AlertDialog.Builder(getActivity())
-+                .setTitle(R.string.reboot_prompt_title)
-+                .setMessage(R.string.reboot_prompt_message)
-+                .setPositiveButton(R.string.yes, new DialogInterface.OnClickListener() {
-+                    @Override
-+                    public void onClick(DialogInterface dialog, int which) {
-+                        PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE);
-+                        pm.reboot(null);
-+                    }
-+                })
-+                .setNegativeButton(R.string.no, null)
-+                .create();
-+
-+        dialog.show();
-+    }
- }
--- 
-2.1.3
-
diff --git a/patches/packages_apps_Settings/0002-dont-disable-lockscreen-widgets-on-low-memory-devices.patch b/patches/packages_apps_Settings/0002-dont-disable-lockscreen-widgets-on-low-memory-devices.patch
deleted file mode 100644
index 228c4cd..0000000
--- a/patches/packages_apps_Settings/0002-dont-disable-lockscreen-widgets-on-low-memory-devices.patch
+++ /dev/null
@@ -1,27 +0,0 @@
-From 46a9efa51d7e2df68fd352952ff952e4ec063631 Mon Sep 17 00:00:00 2001
-From: Kyle Harrison <khwebmail@gmail.com>
-Date: Tue, 21 Oct 2014 01:01:53 +0100
-Subject: [PATCH] Don't disable lockscreen widgets on low memory devices
-
-Change-Id: If47f551edbf4515db97c5be27df53d23607cffe3
----
- src/com/android/settings/Lockscreen.java | 3 +--
- 1 file changed, 1 insertion(+), 2 deletions(-)
-
-diff --git a/src/com/android/settings/Lockscreen.java b/src/com/android/settings/Lockscreen.java
-index 8331b52..109d342 100644
---- a/src/com/android/settings/Lockscreen.java
-+++ b/src/com/android/settings/Lockscreen.java
-@@ -298,8 +298,7 @@ public class Lockscreen extends RestrictedSettingsFragment
-         // and remove them on low memory devices
-         mEnableKeyguardWidgets = root.findPreference(KEY_ENABLE_WIDGETS);
-         if (mEnableKeyguardWidgets != null) {
--            if (ActivityManager.isLowRamDeviceStatic()
--                    || mLockPatternUtils.isLockScreenDisabled()) {
-+            if (mLockPatternUtils.isLockScreenDisabled()) {
-                 // Widgets take a lot of RAM, so disable them on low-memory devices
-                 root.removePreference(root.findPreference(KEY_ENABLE_WIDGETS));
-                 mEnableKeyguardWidgets = null;
--- 
-2.1.2
-
diff --git a/patches/system_vold/0001-vold-switchable-pair.patch b/patches/system_vold/0001-vold-switchable-pair.patch
deleted file mode 100644
index b00ec6e..0000000
--- a/patches/system_vold/0001-vold-switchable-pair.patch
+++ /dev/null
@@ -1,115 +0,0 @@
-From 8a4f1fb196fa5160485eb246035f1dd5691bd620 Mon Sep 17 00:00:00 2001
-From: Ricardo Cerqueira <cyanogenmod@cerqueira.org>
-Date: Fri, 19 Aug 2011 18:42:27 +0100
-Subject: [PATCH] vold: Allow pre-configured device pairs to switch mountpoints
-
-The use-case for this are devices with internal extended storage
-(pseudo-SDCard emmc) and an actual microSD card reader.
-In CM, we choose to use the microSD as primary storage, and leave
-the internal partition mostly unused; some users usually come up with
-imaginative and data-destroying ways of working around that.
-
-This allows us to specify a pair of mountpoints which can be
-switched from a user preference. For this vold.fstab:
-
------
-dev_mount sdcard /mnt/sdcard ...<path-to-microSD-sysfs>
-dev_mount emmc /mnt/emmc ...<path-to-emmc-partition>
------
-
-We can add to build.prop:
-"ro.vold.switchablepair=/mnt/sdcard,/mnt/emmc"
-
-A persistent toggle (persist.sys.vold.switchexternal), controllable
-through CMParts, can be presented to the user to allow choosing
-something other than our default as primary storage.
-
-Updated to 4.4 by @Dazzozo.
-
-Change-Id: I9559fa442c833e3168287d820b7b8347736abb15
----
- DirectVolume.cpp | 38 ++++++++++++++++++++++++++++++++++++++
- DirectVolume.h   |  4 ++--
- 2 files changed, 40 insertions(+), 2 deletions(-)
-
-diff --git a/DirectVolume.cpp b/DirectVolume.cpp
-index 57dc555..b176d15 100644
---- a/DirectVolume.cpp
-+++ b/DirectVolume.cpp
-@@ -24,6 +24,7 @@
- #define LOG_TAG "DirectVolume"
- 
- #include <cutils/log.h>
-+#include <cutils/properties.h>
- #include <sysutils/NetlinkEvent.h>
- 
- #include "DirectVolume.h"
-@@ -35,6 +36,7 @@
- 
- DirectVolume::DirectVolume(VolumeManager *vm, const fstab_rec* rec, int flags) :
-         Volume(vm, rec, flags) {
-+    char switchable[PROPERTY_VALUE_MAX];
-     mPaths = new PathCollection();
-     for (int i = 0; i < MAX_PARTITIONS; i++)
-         mPartMinors[i] = -1;
-@@ -62,6 +64,42 @@ DirectVolume::DirectVolume(VolumeManager *vm, const fstab_rec* rec, int flags) :
-     mMountpoint = strdup(mount);
-     snprintf(mount, PATH_MAX, "%s/%s", Volume::FUSE_DIR, rec->label);
-     mFuseMountpoint = strdup(mount);
-+
-+    property_get("persist.sys.vold.switchexternal", switchable, "0");
-+    if (!strcmp(switchable,"1")) {
-+        char *first, *second = NULL;
-+        char label[PATH_MAX];
-+        const char *delim = ",";
-+        int lblidx = strlen(Volume::FUSE_DIR) + 1;
-+        bool swap = true;
-+
-+        property_get("ro.vold.switchablepair", switchable, "");
-+
-+        if (!(first = strtok(switchable, delim))) {
-+            SLOGE("Mount switch requested, but no switchable mountpoints found");
-+            swap = false;
-+        } else if (!(second = strtok(NULL, delim))) {
-+            SLOGE("Mount switch requested, but bad switchable mountpoints found");
-+            swap = false;
-+        }
-+
-+        if (swap) {
-+            free(mMountpoint);
-+            free(mFuseMountpoint);
-+
-+            if (!strcmp(mount,first)) {
-+                mFuseMountpoint = strdup(second);
-+                strcpy(label, second+lblidx);
-+                snprintf(second, PATH_MAX, "%s/%s", Volume::MEDIA_DIR, label);
-+                mMountpoint = strdup(second);
-+            } else if (!strcmp(mount,second)) {
-+                mFuseMountpoint = strdup(first);
-+                strcpy(label, first+lblidx);
-+                snprintf(first, PATH_MAX, "%s/%s", Volume::MEDIA_DIR, label);
-+                mMountpoint = strdup(first);
-+            }
-+        }
-+    }
- #endif
- 
-     setState(Volume::State_NoMedia);
-diff --git a/DirectVolume.h b/DirectVolume.h
-index 396ac91..8b6e9a8 100644
---- a/DirectVolume.h
-+++ b/DirectVolume.h
-@@ -31,8 +31,8 @@ class DirectVolume : public Volume {
- public:
-     static const int MAX_PARTITIONS = VOLD_MAX_PARTITIONS;
- protected:
--    const char* mMountpoint;
--    const char* mFuseMountpoint;
-+    char* mMountpoint;
-+    char* mFuseMountpoint;
- 
-     PathCollection *mPaths;
-     int            mDiskMajor;
--- 
-1.8.1.2
-
diff --git a/patches/system_vold/0002-switchable-pair-setting.patch b/patches/system_vold/0002-switchable-pair-setting.patch
deleted file mode 100644
index 3bc7943..0000000
--- a/patches/system_vold/0002-switchable-pair-setting.patch
+++ /dev/null
@@ -1,31 +0,0 @@
-From 5acb44e343c5b2fb67345b7edf0b6d834c52f771 Mon Sep 17 00:00:00 2001
-From: dhacker29 <davidhackerdvm@gmail.com>
-Date: Thu, 22 Aug 2013 22:28:06 -0500
-Subject: [PATCH] Vold: Allow Settings to determine if a switchable pair exists
- (1/2)
-
-This will eliminate the need for pre-configured device pairs listed
-in the build.prop, and display the setting if a pair exists.
-This exapnds on commit dc8d157d73fb88ee33b38e724a8aabe7d5e53eee
-
-Change-Id: I5f15a711b5ceabddaf842c252d890545f40b4786
----
- DirectVolume.cpp | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
-diff --git a/DirectVolume.cpp b/DirectVolume.cpp
-index b176d15..de7363e 100644
---- a/DirectVolume.cpp
-+++ b/DirectVolume.cpp
-@@ -73,7 +73,7 @@ DirectVolume::DirectVolume(VolumeManager *vm, const fstab_rec* rec, int flags) :
-         int lblidx = strlen(Volume::FUSE_DIR) + 1;
-         bool swap = true;
- 
--        property_get("ro.vold.switchablepair", switchable, "");
-+        property_get("persist.sys.vold.switchablepair", switchable, "");
- 
-         if (!(first = strtok(switchable, delim))) {
-             SLOGE("Mount switch requested, but no switchable mountpoints found");
--- 
-1.8.1.2
-

project device/huawei/u8833/
diff --git a/BoardConfig.mk b/BoardConfig.mk
index 05b194f..5be8f01 100644
--- a/BoardConfig.mk
+++ b/BoardConfig.mk
@@ -13,7 +13,12 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 #
-
+PRODUCT_PREBUILT_WEBVIEWCHROMIUM=yes
+ANDROID_COMPILE_WITH_JACK := false
+DISABLE_DEXPREOPT=true
+WITH_DEXPREOPT=false
+WITH_SU=true
+TARGET_BOOTANIMATION_HALF_RES=false
 # Inherit from the proprietary version
 -include vendor/huawei/u8833/BoardConfigVendor.mk
 
diff --git a/patches/external_wpa_supplicant_8/0001-reduce-scan-timeout.patch b/patches/external_wpa_supplicant_8/0001-reduce-scan-timeout.patch
deleted file mode 100644
index c7d7f8f..0000000
--- a/patches/external_wpa_supplicant_8/0001-reduce-scan-timeout.patch
+++ /dev/null
@@ -1,31 +0,0 @@
-From d4e29720bc7ad6dc48bf7c202efc63bb798ffc3c Mon Sep 17 00:00:00 2001
-From: Robin Humble <plaguedbypenguins@gmail.com>
-Date: Sat, 20 Apr 2013 23:55:23 +1000
-Subject: [PATCH] wpa_supplicant: reduce scan timeout to workaround ar6000
- problem
-
-Ar6k hangs on the first scan after resume causing slow wifi reconnects
-as wpa_supplicant must timeout (30s) and then retry. Work around the
-binary module bug by setting the wpa_supplicant scan timeout to be much
-shorter. Hopefully 5s is still long enough. Scans typically take 2-3s
-on my network.
----
- src/drivers/driver_wext.c | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
-diff --git a/src/drivers/driver_wext.c b/src/drivers/driver_wext.c
-index 701b7a3..ffcfe8a 100644
---- a/src/drivers/driver_wext.c
-+++ b/src/drivers/driver_wext.c
-@@ -1065,7 +1065,7 @@ int wpa_driver_wext_scan(void *priv, struct wpa_driver_scan_params *params)
- 		 * when scan is complete, so use longer timeout to avoid race
- 		 * conditions with scanning and following association request.
- 		 */
--		timeout = 30;
-+		timeout = 5;
- 	}
- 	wpa_printf(MSG_DEBUG, "Scan requested (ret=%d) - scan timeout %d "
- 		   "seconds", ret, timeout);
--- 
-1.8.1.2
-
diff --git a/patches/system_core/0001-add-huawei-firmware-path.patch b/patches/system_core/0001-add-huawei-firmware-path.patch
deleted file mode 100644
index 5cf5126..0000000
--- a/patches/system_core/0001-add-huawei-firmware-path.patch
+++ /dev/null
@@ -1,78 +0,0 @@
-From 2b8e36dd0c01a793e69a41cdeeaf5f87e41fb0f4 Mon Sep 17 00:00:00 2001
-From: Kra1o5 <kra1o5x@gmail.com>
-Date: Wed, 9 Oct 2013 12:35:40 +0100
-Subject: [PATCH] Add path for wifi firmware
-
-Change-Id: Ia898beee3ab843e400b595813ad2977b026997ca
----
- init/devices.c | 32 ++++++++++++++++++++------------
- 1 file changed, 20 insertions(+), 12 deletions(-)
-
-diff --git a/init/devices.c b/init/devices.c
-index 5681c9c..d9f34e6 100644
---- a/init/devices.c
-+++ b/init/devices.c
-@@ -49,7 +49,8 @@
- #define SYSFS_PREFIX    "/sys"
- #define FIRMWARE_DIR1   "/etc/firmware"
- #define FIRMWARE_DIR2   "/vendor/firmware"
--#define FIRMWARE_DIR3   "/firmware/image"
-+#define FIRMWARE_DIR3   "/system/wifi"
-+#define FIRMWARE_DIR4   "/data/misc/wifi"
- 
- extern struct selabel_handle *sehandle;
- 
-@@ -740,7 +741,7 @@ static int is_booting(void)
- 
- static void process_firmware_event(struct uevent *uevent)
- {
--    char *root, *loading, *data, *file1 = NULL, *file2 = NULL, *file3 = NULL;
-+    char *root, *loading, *data, *file1 = NULL, *file2 = NULL, *file3 = NULL, *file4 = NULL;
-     int l, loading_fd, data_fd, fw_fd;
-     int booting = is_booting();
- 
-@@ -771,6 +772,10 @@ static void process_firmware_event(struct uevent *uevent)
-     if (l == -1)
-         goto data_free_out;
- 
-+    l = asprintf(&file4, FIRMWARE_DIR4"/%s", uevent->firmware);
-+    if (l == -1)
-+        goto data_free_out;
-+
-     loading_fd = open(loading, O_WRONLY);
-     if(loading_fd < 0)
-         goto file_free_out;
-@@ -786,17 +791,20 @@ try_loading_again:
-         if (fw_fd < 0) {
-             fw_fd = open(file3, O_RDONLY);
-             if (fw_fd < 0) {
--                if (booting) {
--                        /* If we're not fully booted, we may be missing
--                         * filesystems needed for firmware, wait and retry.
--                         */
--                    usleep(100000);
--                    booting = is_booting();
--                    goto try_loading_again;
-+                fw_fd = open(file4, O_RDONLY);
-+                if (fw_fd < 0) {
-+                    if (booting) {
-+                            /* If we're not fully booted, we may be missing
-+                             * filesystems needed for firmware, wait and retry.
-+                             */
-+                        usleep(100000);
-+                        booting = is_booting();
-+                        goto try_loading_again;
-+                    }
-+                    INFO("firmware: could not open '%s' %d\n", uevent->firmware, errno);
-+                    write(loading_fd, "-1", 2);
-+                    goto data_close_out;
-                 }
--                INFO("firmware: could not open '%s' %d\n", uevent->firmware, errno);
--                write(loading_fd, "-1", 2);
--                goto data_close_out;
-             }
-         }
-     }
--- 
-1.8.1.2
-
diff --git a/patches/system_netd/0001-fix-softap-for-huawei-ath.patch b/patches/system_netd/0001-fix-softap-for-huawei-ath.patch
deleted file mode 100644
index 93e5950..0000000
--- a/patches/system_netd/0001-fix-softap-for-huawei-ath.patch
+++ /dev/null
@@ -1,916 +0,0 @@
-From 673a79581f483ce77ede31f7f6ac6bd1fbd3e21d Mon Sep 17 00:00:00 2001
-From: Kyle Harrison <khwebmail@gmail.com>
-Date: Sun, 12 Jan 2014 22:48:24 +0000
-Subject: [PATCH] Update Huawei SoftapControllerATH for 4.4 (and 4.3)
-
----
- Android.mk              |  11 +-
- CommandListener.cpp     |  11 +-
- SoftapController.h      |   8 +
- SoftapControllerATH.cpp | 816 ++++++++++++++++++++++++++++++++++++++++++++++++
- 4 files changed, 844 insertions(+), 2 deletions(-)
- create mode 100644 SoftapControllerATH.cpp
-
-diff --git a/Android.mk b/Android.mk
-index da4a7ad..db511e9 100644
---- a/Android.mk
-+++ b/Android.mk
-@@ -19,7 +19,6 @@ LOCAL_SRC_FILES:=                                      \
-                   PppController.cpp                    \
-                   ResolverController.cpp               \
-                   SecondaryTableController.cpp         \
--                  SoftapController.cpp                 \
-                   TetherController.cpp                 \
-                   oem_iptables_hook.cpp                \
-                   UidMarkMap.cpp                       \
-@@ -42,6 +41,16 @@ LOCAL_SHARED_LIBRARIES := libstlport libsysutils liblog libcutils libnetutils \
-                           libcrypto libhardware_legacy libmdnssd libdl \
-                           liblogwrap
- 
-+ifeq ($(BOARD_HAS_ATH_WLAN),true)
-+  LOCAL_CFLAGS += -DATH_WLAN
-+  LOCAL_CFLAGS += -DWIFI_MODULE_PATH=\"$(WIFI_DRIVER_MODULE_PATH)\"
-+  LOCAL_C_INCLUDES += external/wpa_supplicant_8/wpa_supplicant/src/common
-+  LOCAL_SRC_FILES += SoftapControllerATH.cpp
-+  LOCAL_SHARED_LIBRARIES := $(LOCAL_SHARED_LIBRARIES) libwpa_client
-+else
-+   LOCAL_SRC_FILES += SoftapController.cpp
-+endif
-+
- include $(BUILD_EXECUTABLE)
- 
- include $(CLEAR_VARS)
-diff --git a/CommandListener.cpp b/CommandListener.cpp
-index 16c9e13..0b9fdbb 100644
---- a/CommandListener.cpp
-+++ b/CommandListener.cpp
-@@ -992,9 +992,18 @@ int CommandListener::SoftapCmd::runCommand(SocketClient *cli,
-                      "Missing argument in a SoftAP command", false);
-         return 0;
-     }
--
-+    
-+#ifdef ATH_WLAN
-+    if (!strcmp(argv[1], "start")) {
-+        rc = sSoftapCtrl->startDriver(argv[2]);
-+    } else if (!strcmp(argv[1], "stop")) {
-+        rc = sSoftapCtrl->stopDriver(argv[2]);
-+    } else if (!strcmp(argv[1], "startap")) {
-+        rc = sSoftapCtrl->startSoftap();
-+#else
-     if (!strcmp(argv[1], "startap")) {
-         rc = sSoftapCtrl->startSoftap();
-+#endif
-     } else if (!strcmp(argv[1], "stopap")) {
-         rc = sSoftapCtrl->stopSoftap();
-     } else if (!strcmp(argv[1], "fwreload")) {
-diff --git a/SoftapController.h b/SoftapController.h
-index 7063067..b520fca 100644
---- a/SoftapController.h
-+++ b/SoftapController.h
-@@ -32,12 +32,20 @@ public:
-     SoftapController();
-     virtual ~SoftapController();
- 
-+#ifdef ATH_WLAN
-+    int startDriver(const char *iface);
-+    int stopDriver(const char *iface);
-+#endif
-     int startSoftap();
-     int stopSoftap();
-     bool isSoftapStarted();
-     int setSoftap(int argc, char *argv[]);
-     int fwReloadSoftap(int argc, char *argv[]);
- private:
-+#ifdef ATH_WLAN
-+    char mBuf[SOFTAP_MAX_BUFFER_SIZE];
-+    char mIface[IFNAMSIZ];
-+#endif
-     pid_t mPid;
-     void generatePsk(char *ssid, char *passphrase, char *psk);
- };
-diff --git a/SoftapControllerATH.cpp b/SoftapControllerATH.cpp
-new file mode 100644
-index 0000000..041f9ec
---- /dev/null
-+++ b/SoftapControllerATH.cpp
-@@ -0,0 +1,816 @@
-+/*
-+ * Copyright (C) 2008 The Android Open Source Project
-+ *
-+ * Licensed under the Apache License, Version 2.0 (the "License");
-+ * you may not use this file except in compliance with the License.
-+ * You may obtain a copy of the License at
-+ *
-+ *      http://www.apache.org/licenses/LICENSE-2.0
-+ *
-+ * Unless required by applicable law or agreed to in writing, software
-+ * distributed under the License is distributed on an "AS IS" BASIS,
-+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-+ * See the License for the specific language governing permissions and
-+ * limitations under the License.
-+ */
-+
-+#include <stdlib.h>
-+#include <errno.h>
-+#include <fcntl.h>
-+
-+#include <sys/socket.h>
-+#include <sys/stat.h>
-+#include <sys/types.h>
-+#include <sys/wait.h>
-+
-+#include <netinet/in.h>
-+#include <arpa/inet.h>
-+
-+#include <linux/wireless.h>
-+
-+#include <openssl/evp.h>
-+#include <openssl/sha.h>
-+
-+#define LOG_TAG "SoftapController"
-+#include <cutils/log.h>
-+
-+#include "SoftapController.h"
-+#include "ResponseCode.h"
-+
-+extern "C" int delete_module(const char *, unsigned int);
-+extern "C" int init_module(void * , unsigned int, const char *);
-+extern "C" void *load_file(const char *fn, unsigned *_sz);
-+
-+extern "C" int ifc_init();
-+extern "C" int ifc_up(const char *name);
-+
-+#include "private/android_filesystem_config.h"
-+#include "cutils/properties.h"
-+#ifdef HAVE_LIBC_SYSTEM_PROPERTIES
-+#define _REALLY_INCLUDE_SYS__SYSTEM_PROPERTIES_H_
-+#endif
-+
-+#include <sys/_system_properties.h>
-+#include "wpa_ctrl.h"
-+
-+static const char IFACE_DIR[]           = "/data/misc/wifi/hostapd";
-+static const char HOSTAPD_NAME[]     = "hostapd";
-+static const char HOSTAPD_CONFIG_TEMPLATE[]= "/system/etc/wifi/hostapd.conf";
-+static const char HOSTAPD_CONFIG_FILE[]    = "/data/misc/wifi/hostapd.conf";
-+static const char HOSTAPD_PROP_NAME[]      = "init.svc.hostapd";
-+
-+#ifdef WIFI_DRIVER_MODULE_AP_ARG
-+static const char DRIVER_MODULE_AP_ARG[] = WIFI_DRIVER_MODULE_AP_ARG;
-+#endif
-+
-+#define WIFI_DEFAULT_BI         100         /* in TU */
-+#define WIFI_DEFAULT_DTIM       1           /* in beacon */
-+#define WIFI_DEFAULT_CHANNEL    6
-+#define WIFI_DEFAULT_MAX_STA    8
-+#define WIFI_DEFAULT_PREAMBLE   0
-+
-+static struct wpa_ctrl *ctrl_conn;
-+static char iface[PROPERTY_VALUE_MAX];
-+int mProfileValid;
-+
-+/* rfkill support borrowed from bluetooth */
-+static int rfkill_id = -1;
-+static char *rfkill_state_path = NULL;
-+
-+static int init_rfkill() {
-+    char path[64];
-+    char buf[16];
-+    int fd;
-+    int sz;
-+    int id;
-+    for (id = 0; ; id++) {
-+        snprintf(path, sizeof(path), "/sys/class/rfkill/rfkill%d/type", id);
-+        fd = open(path, O_RDONLY);
-+        if (fd < 0) {
-+            ALOGW("open(%s) failed: %s (%d)\n", path, strerror(errno), errno);
-+            return -1;
-+        }
-+        sz = read(fd, &buf, sizeof(buf));
-+        close(fd);
-+        if (sz >= 4 && memcmp(buf, "wlan", 4) == 0) {
-+            rfkill_id = id;
-+            break;
-+        }
-+    }
-+
-+    asprintf(&rfkill_state_path, "/sys/class/rfkill/rfkill%d/state", rfkill_id);
-+    return 0;
-+}
-+
-+static int check_wifi_power() {
-+    int sz;
-+    int fd = -1;
-+    int ret = -1;
-+    char buffer;
-+
-+    if (rfkill_id == -1) {
-+        if (init_rfkill()) goto out;
-+    }
-+
-+    fd = open(rfkill_state_path, O_RDONLY);
-+    if (fd < 0) {
-+        ALOGE("open(%s) failed: %s (%d)", rfkill_state_path, strerror(errno),
-+                errno);
-+        goto out;
-+    }
-+    sz = read(fd, &buffer, 1);
-+    if (sz != 1) {
-+        ALOGE("read(%s) failed: %s (%d)", rfkill_state_path, strerror(errno),
-+                errno);
-+        goto out;
-+    }
-+
-+    switch (buffer) {
-+        case '1':
-+            ret = 1;
-+            break;
-+        case '0':
-+            ret = 0;
-+            break;
-+    }
-+
-+out:
-+    if (fd >= 0) close(fd);
-+    return ret;
-+}
-+
-+static int set_wifi_power(int on) {
-+    int sz;
-+    int fd = -1;
-+    int ret = -1;
-+    const char buffer = (on ? '1' : '0');
-+
-+    if (rfkill_id == -1) {
-+        if (init_rfkill()) goto out;
-+    }
-+
-+    if (check_wifi_power() == on) {
-+        return 0;
-+    }
-+
-+    fd = open(rfkill_state_path, O_WRONLY);
-+    if (fd < 0) {
-+        ALOGE("open(%s) for write failed: %s (%d)", rfkill_state_path,
-+                strerror(errno), errno);
-+        goto out;
-+    }
-+    /* Give it a few seconds before changing state */
-+    sleep(3);
-+    sz = write(fd, &buffer, 1);
-+    if (sz < 0) {
-+        ALOGE("write(%s) failed: %s (%d)", rfkill_state_path, strerror(errno),
-+                errno);
-+        goto out;
-+    }
-+    ret = 0;
-+
-+out:
-+    if (fd >= 0) close(fd);
-+    return ret;
-+}
-+
-+/* end rfkill support */
-+
-+int ensure_config_file_exists()
-+{
-+    char buf[2048];
-+    int srcfd, destfd;
-+    int nread;
-+
-+    if (access(HOSTAPD_CONFIG_FILE, R_OK|W_OK) == 0) {
-+        return 0;
-+    } else if (errno != ENOENT) {
-+        ALOGE("Cannot access \"%s\": %s", HOSTAPD_CONFIG_FILE, strerror(errno));
-+        return -1;
-+    }
-+
-+    srcfd = open(HOSTAPD_CONFIG_TEMPLATE, O_RDONLY);
-+    if (srcfd < 0) {
-+        ALOGE("Cannot open \"%s\": %s", HOSTAPD_CONFIG_TEMPLATE, strerror(errno));
-+        return -1;
-+    }
-+
-+    destfd = open(HOSTAPD_CONFIG_FILE, O_CREAT|O_WRONLY, 0660);
-+    if (destfd < 0) {
-+        close(srcfd);
-+        ALOGE("Cannot create \"%s\": %s", HOSTAPD_CONFIG_FILE, strerror(errno));
-+        return -1;
-+    }
-+
-+    while ((nread = read(srcfd, buf, sizeof(buf))) != 0) {
-+        if (nread < 0) {
-+            ALOGE("Error reading \"%s\": %s", HOSTAPD_CONFIG_TEMPLATE, strerror(errno));
-+            close(srcfd);
-+            close(destfd);
-+            unlink(HOSTAPD_CONFIG_FILE);
-+            return -1;
-+        }
-+        write(destfd, buf, nread);
-+    }
-+
-+    close(destfd);
-+    close(srcfd);
-+
-+    if (chown(HOSTAPD_CONFIG_FILE, AID_SYSTEM, AID_WIFI) < 0) {
-+        ALOGE("Error changing group ownership of %s to %d: %s",
-+             HOSTAPD_CONFIG_FILE, AID_WIFI, strerror(errno));
-+        unlink(HOSTAPD_CONFIG_FILE);
-+        return -1;
-+    }
-+
-+    return 0;
-+}
-+
-+int wifi_start_hostapd()
-+{
-+    char supp_status[PROPERTY_VALUE_MAX] = {'\0'};
-+    int count = 300; /* wait at most 30 seconds for completion */
-+    char mac_buff[15] = {'\0'};
-+#ifdef HAVE_LIBC_SYSTEM_PROPERTIES
-+    const prop_info *pi;
-+    unsigned serial = 0;
-+#endif
-+
-+    /* Check whether already running */
-+    if (property_get(HOSTAPD_PROP_NAME, supp_status, NULL)
-+            && strcmp(supp_status, "running") == 0) {
-+        return 0;
-+    }
-+
-+    /* Clear out any stale socket files that might be left over. */
-+    wpa_ctrl_cleanup();
-+
-+#ifdef HAVE_LIBC_SYSTEM_PROPERTIES
-+    /*
-+     * Get a reference to the status property, so we can distinguish
-+     * the case where it goes stopped => running => stopped (i.e.,
-+     * it start up, but fails right away) from the case in which
-+     * it starts in the stopped state and never manages to start
-+     * running at all.
-+     */
-+    pi = __system_property_find(HOSTAPD_PROP_NAME);
-+    if (pi != NULL) {
-+        serial = __system_property_serial(pi);
-+    }
-+#endif
-+    property_set("ctl.start", HOSTAPD_NAME);
-+    sched_yield();
-+
-+    while (count-- > 0) {
-+#ifdef HAVE_LIBC_SYSTEM_PROPERTIES
-+        if (pi == NULL) {
-+            pi = __system_property_find(HOSTAPD_PROP_NAME);
-+        }
-+        if (pi != NULL) {
-+            __system_property_read(pi, NULL, supp_status);
-+            if (strcmp(supp_status, "running") == 0) {
-+                return 0;
-+            } else if (__system_property_serial(pi) != serial &&
-+                    strcmp(supp_status, "stopped") == 0) {
-+                return -1;
-+            }
-+        }
-+#endif
-+        usleep(100000);
-+    }
-+    return -1;
-+}
-+
-+int wifi_stop_hostapd()
-+{
-+    char supp_status[PROPERTY_VALUE_MAX] = {'\0'};
-+    int count = 50; /* wait at most 5 seconds for completion */
-+
-+    /* Check whether hostapd already stopped */
-+    if (property_get(HOSTAPD_PROP_NAME, supp_status, NULL)
-+        && strcmp(supp_status, "stopped") == 0) {
-+        return 0;
-+    }
-+
-+    property_set("ctl.stop", HOSTAPD_NAME);
-+    sched_yield();
-+
-+    while (count-- > 0) {
-+        if (property_get(HOSTAPD_PROP_NAME, supp_status, NULL)) {
-+            if (strcmp(supp_status, "stopped") == 0)
-+                return 0;
-+        }
-+        usleep(100000);
-+    }
-+    return -1;
-+}
-+
-+int wifi_connect_to_hostapd()
-+{
-+    char ifname[256];
-+    char supp_status[PROPERTY_VALUE_MAX] = {'\0'};
-+    int connretry = 15; /* 1500 ms */
-+
-+    /* Make sure hostapd is running */
-+    if (!property_get(HOSTAPD_PROP_NAME, supp_status, NULL)
-+            || strcmp(supp_status, "running") != 0) {
-+        ALOGE("Supplicant not running, cannot connect");
-+        return -1;
-+    }
-+
-+    strcpy(iface, "eth0");
-+    snprintf(ifname, sizeof(ifname), "%s/%s", IFACE_DIR, iface);
-+    ALOGD("ifname = %s\n", ifname);
-+
-+    { /* check iface file is ready */
-+        int cnt = 160; /* 8 seconds (160*50)*/
-+        sched_yield();
-+        while ( access(ifname, F_OK|W_OK)!=0 && cnt-- > 0) {
-+            usleep(50000);
-+        }
-+        if (access(ifname, F_OK|W_OK)==0) {
-+            snprintf(ifname, sizeof(ifname), "%s/%s", IFACE_DIR, iface);
-+            ALOGD("ifname %s is ready to read/write cnt=%d\n", ifname, cnt);
-+        } else {
-+            strlcpy(ifname, iface, sizeof(ifname));
-+            ALOGD("ifname %s is not ready, cnt=%d\n", ifname, cnt);
-+        }
-+    }
-+
-+    while (--connretry && (ctrl_conn = wpa_ctrl_open(ifname)) == NULL) {
-+        usleep(100000);
-+    }
-+
-+    if (ctrl_conn == NULL) {
-+        ALOGE("Unable to open connection to hostapd on \"%s\": %s",
-+             ifname, strerror(errno));
-+        return -1;
-+    }
-+
-+    if (wpa_ctrl_attach(ctrl_conn) != 0) {
-+        wpa_ctrl_close(ctrl_conn);
-+        ctrl_conn = NULL;
-+        return -1;
-+    }
-+    return 0;
-+}
-+
-+void wifi_close_hostapd_connection()
-+{
-+    if (ctrl_conn != NULL) {
-+        wpa_ctrl_close(ctrl_conn);
-+        ctrl_conn = NULL;
-+    }
-+}
-+
-+int wifi_load_profile(bool started)
-+{
-+    if ((started) && (mProfileValid)) {
-+        if (ctrl_conn == NULL) {
-+            return -1;
-+        }
-+    }
-+    return 0;
-+}
-+
-+static int insmod(const char *filename, const char *args)
-+{
-+    void *module;
-+    unsigned int size;
-+    int ret;
-+
-+    module = load_file(filename, &size);
-+    if (!module)
-+        return -1;
-+
-+    ret = init_module(module, size, args);
-+
-+    free(module);
-+
-+    return ret;
-+}
-+
-+static int rmmod(const char *modname)
-+{
-+    int ret = -1;
-+    int maxtry = 10;
-+
-+    while (maxtry-- > 0) {
-+        ret = delete_module(modname, O_NONBLOCK | O_EXCL);
-+        if (ret < 0 && errno == EAGAIN)
-+            usleep(500000);
-+        else
-+            break;
-+    }
-+
-+    if (ret != 0)
-+        ALOGD("Unable to unload driver module \"%s\": %s\n",
-+                modname, strerror(errno));
-+    return ret;
-+}
-+
-+SoftapController::SoftapController()
-+    : mPid(0) {
-+    memset(mIface, 0, sizeof(mIface));
-+    mProfileValid = 0;
-+    ctrl_conn = NULL;
-+}
-+
-+SoftapController::~SoftapController() {
-+}
-+
-+#if 0
-+int SoftapController::getPrivFuncNum(char *iface, const char *fname) {
-+    struct iwreq wrq;
-+    struct iw_priv_args *priv_ptr;
-+    int i, ret;
-+
-+    strncpy(wrq.ifr_name, iface, sizeof(wrq.ifr_name));
-+    wrq.u.data.pointer = mBuf;
-+    wrq.u.data.length = sizeof(mBuf) / sizeof(struct iw_priv_args);
-+    wrq.u.data.flags = 0;
-+    if ((ret = ioctl(mSock, SIOCGIWPRIV, &wrq)) < 0) {
-+        ALOGE("SIOCGIPRIV failed: %d", ret);
-+        return ret;
-+    }
-+    priv_ptr = (struct iw_priv_args *)wrq.u.data.pointer;
-+    for(i=0;(i < wrq.u.data.length);i++) {
-+        if (strcmp(priv_ptr[i].name, fname) == 0)
-+            return priv_ptr[i].cmd;
-+    }
-+    return -1;
-+}
-+#endif
-+
-+int SoftapController::startDriver(const char *iface) {
-+    struct iwreq wrq;
-+    int fnum, ret;
-+
-+    ALOGD("startDriver()");
-+
-+    if (!iface || (iface[0] == '\0')) {
-+        ALOGD("Softap driver start - wrong interface");
-+        iface = mIface;
-+    }
-+
-+#ifdef WIFI_MODULE_PATH
-+    rmmod("ar6000");
-+#ifdef WIFI_DRIVER_MODULE_AP_ARG
-+    ret = insmod(WIFI_MODULE_PATH, DRIVER_MODULE_AP_ARG);
-+#else
-+    ret = insmod(WIFI_MODULE_PATH, "");
-+#endif
-+    sleep(1);
-+#else
-+    set_wifi_power(0);
-+    {
-+        int fd = -1;
-+        char buffer;
-+
-+        fd = open("/sys/module/ar6000/parameters/ifname", O_RDWR);
-+        if (fd < 0) {
-+            ALOGE("failed to open interface name");
-+            ret = -1;
-+        }
-+        if (read(fd, &buffer, 1) != 1) {
-+            ALOGE("failed to get interface name");
-+            ret = -1;
-+        }
-+        if (buffer != 'a' && write(fd, "eth0", 6) > 0) {
-+            ALOGD("interface renamed for AP mode");
-+            usleep(500000); /* Give it a while after a name change... */
-+            ret = set_wifi_power(1);
-+        } else if (buffer == 'a') {
-+            ALOGD("interface already named for AP mode");
-+            ret = 0;
-+        } else {
-+            ALOGE("failed to change interface name - %c",buffer);
-+            ret = -2;
-+        }
-+        close(fd);
-+    }
-+#endif
-+
-+    if (ret) {
-+        ALOGE("Softap driver start failed");
-+        return -1;
-+    }
-+
-+    /* Before starting the daemon, make sure its config file exists */
-+    ret =ensure_config_file_exists();
-+    if (ret < 0) {
-+        ALOGE("Softap driver start - configuration file missing");
-+        return -1;
-+    }
-+    /* Indicate interface down */
-+
-+    ALOGD("Softap driver start: %d", ret);
-+    return ret;
-+}
-+
-+int SoftapController::stopDriver(const char *iface) {
-+    struct iwreq wrq;
-+    int fnum, ret;
-+
-+    ALOGD("stopDriver()");
-+
-+    ALOGE("softapcontroller->stopDriver");
-+    if (!iface || (iface[0] == '\0')) {
-+        ALOGD("Softap driver stop - wrong interface");
-+        iface = mIface;
-+    }
-+    ret = 0;
-+#ifdef WIFI_MODULE_PATH
-+    rmmod("ar6000");
-+    ret = insmod(WIFI_MODULE_PATH, "");
-+    sleep(1);
-+#else
-+    ret = set_wifi_power(0);
-+    if (!ret) {
-+        int fd = -1;
-+        char buffer;
-+
-+        fd = open("/sys/module/ar6000/parameters/ifname", O_RDWR);
-+        if (fd < 0) {
-+            ALOGE("failed to open interface name");
-+            ret = -1;
-+        }
-+        if (read(fd, &buffer, 1) != 1) {
-+            ALOGE("failed to get interface name");
-+            ret = -1;
-+        }
-+        if (buffer != 'w' && write(fd, "wlan0", 5) > 0) {
-+            ALOGD("interface renamed for STA mode");
-+            usleep(500000); /* Give it a while after a name change... */
-+            ret = 0;
-+        } else if (buffer == 'w') {
-+            ALOGD("interface already named for STA mode");
-+            ret = 0;
-+        } else {
-+            ALOGE("failed to change interface name - %c",buffer);
-+            ret = -2;
-+        }
-+        close(fd);
-+    }
-+#endif
-+
-+    ALOGD("Softap driver stop: %d", ret);
-+    return ret;
-+}
-+
-+int SoftapController::startSoftap() {
-+    struct iwreq wrq;
-+    pid_t pid = 1;
-+    int fnum, ret;
-+
-+    ALOGD("startSoftap()");
-+
-+    if (mPid) {
-+        ALOGE("SoftAP is already running");
-+        return ResponseCode::SoftapStatusResult;
-+    }
-+
-+    if (!mPid) {
-+        ALOGW("Softap driver not started - loading now");
-+        startDriver("eth0");
-+    }
-+#if 0
-+   if ((pid = fork()) < 0) {
-+        ALOGE("fork failed (%s)", strerror(errno));
-+        return -1;
-+    }
-+#endif
-+    /* system("iwpriv wl0.1 AP_BSS_START"); */
-+    if (!pid) {
-+        /* start hostapd */
-+        return ResponseCode::ServiceStartFailed;
-+    } else {
-+        ifc_init();
-+        ifc_up("eth0");
-+        sleep(1); /* Give the driver time to settle... */
-+
-+        ret = wifi_start_hostapd();
-+        if (ret < 0) {
-+            ALOGE("Softap startap - starting hostapd fails");
-+            stopDriver("eth0");
-+            return ResponseCode::ServiceStartFailed;
-+        }
-+
-+        sched_yield();
-+        usleep(100000);
-+
-+        ret = wifi_connect_to_hostapd();
-+        if (ret < 0) {
-+            ALOGE("Softap startap - connect to hostapd fails");
-+            return ResponseCode::ServiceStartFailed;
-+        }
-+
-+        /* Indicate interface up */
-+
-+        ret = wifi_load_profile(true);
-+        if (ret < 0) {
-+            ALOGE("Softap startap - load new configuration fails");
-+            return ResponseCode::ServiceStartFailed;
-+        }
-+        if (ret) {
-+            ALOGE("Softap startap - failed: %d", ret);
-+        }
-+        else {
-+           mPid = pid;
-+           ALOGD("Softap startap - Ok");
-+           usleep(AP_BSS_START_DELAY);
-+        }
-+    }
-+
-+    return ResponseCode::SoftapStatusResult;
-+}
-+
-+int SoftapController::stopSoftap() {
-+    struct iwreq wrq;
-+    int fnum, ret;
-+
-+    ALOGD("stopSoftap()");
-+
-+    if (mPid == 0) {
-+        ALOGE("SoftAP is not running");
-+        return ResponseCode::SoftapStatusResult;
-+    }
-+    wifi_close_hostapd_connection();
-+    ret = wifi_stop_hostapd();
-+    mPid = 0;
-+    ALOGD("Softap service stopped: %d", ret);
-+
-+#ifndef WIFI_MODULE_PATH
-+    set_wifi_power(0);
-+    {
-+        int fd = -1;
-+        char buffer;
-+
-+        fd = open("/sys/module/ar6000/parameters/ifname", O_RDWR);
-+        if (fd < 0) {
-+            ALOGE("failed to open interface name");
-+            ret = -1;
-+        }
-+        if (read(fd, &buffer, 1) != 1) {
-+            ALOGE("failed to get interface name");
-+            ret = -1;
-+        }
-+        if (buffer != 'w' && write(fd, "wlan0", 5) > 0) {
-+            ALOGD("interface renamed for STA mode");
-+            usleep(500000); /* Give it a while after a name change... */
-+            ret = 0;
-+        } else if (buffer == 'w') {
-+            ALOGD("interface already named for STA mode");
-+            ret = 0;
-+        } else {
-+            ALOGE("failed to change interface name - %c",buffer);
-+            ret = -2;
-+        }
-+        close(fd);
-+    }
-+#endif
-+    usleep(AP_BSS_STOP_DELAY);
-+    return ResponseCode::SoftapStatusResult;
-+}
-+
-+bool SoftapController::isSoftapStarted() {
-+    return (mPid != 0);
-+}
-+
-+/*
-+ * Arguments:
-+ *	argv[2] - wlan interface
-+ *	argv[3] - SSID
-+ *	argv[4] - Broadcast/Hidden
-+ *	argv[5] - Channel
-+ *	argv[6] - Security
-+ *	argv[7] - Key
-+ */
-+int SoftapController::setSoftap(int argc, char *argv[]) {
-+    unsigned char psk[SHA256_DIGEST_LENGTH];
-+    char psk_str[2*SHA256_DIGEST_LENGTH+1];
-+    struct iwreq wrq;
-+    int fnum, ret, i = 0;
-+    char *ssid;
-+    int fd;
-+    char buf[80];
-+    int len;
-+
-+    ALOGD("setSoftap()");
-+
-+    if (argc < 4) {
-+        ALOGE("Softap set - missing arguments");
-+        return ResponseCode::CommandSyntaxError;
-+    }
-+
-+    fd = open(HOSTAPD_CONFIG_FILE, O_CREAT|O_WRONLY|O_TRUNC, 0660);
-+    if (fd < 0) {
-+        ALOGE("Cannot create \"%s\": %s", HOSTAPD_CONFIG_FILE, strerror(errno));
-+        return ResponseCode::OperationFailed;
-+    }
-+    if (chown(HOSTAPD_CONFIG_FILE, AID_SYSTEM, AID_WIFI) < 0) {
-+        ALOGE("Error changing group ownership of %s to %d: %s",
-+            HOSTAPD_CONFIG_FILE, AID_WIFI, strerror(errno));
-+        return ResponseCode::OperationFailed;
-+    }
-+    if (chmod(HOSTAPD_CONFIG_FILE, 0660) < 0) {
-+        ALOGE("Error changing permission of %s to %d: %s",
-+            HOSTAPD_CONFIG_FILE, AID_WIFI, strerror(errno));
-+        return ResponseCode::OperationFailed;
-+    }
-+
-+    len = snprintf(buf, sizeof(buf), "interface=eth0\n");
-+    write(fd, buf, len);
-+    len = snprintf(buf, sizeof(buf), "ctrl_interface=%s\n",IFACE_DIR);
-+    write(fd, buf, len);
-+    if (argc > 3) {
-+        len = snprintf(buf, sizeof(buf), "ssid=%s\n",argv[3]);
-+    } else {
-+        len = snprintf(buf, sizeof(buf), "ssid=AndroidAP\n");
-+    }
-+    /* set open auth */
-+    write(fd, buf, len);
-+    len = snprintf(buf, sizeof(buf), "auth_algs=1\n");
-+    write(fd, buf, len);
-+    len = snprintf(buf, sizeof(buf), "max_num_sta=%d\n",WIFI_DEFAULT_MAX_STA);
-+    write(fd, buf, len);
-+    len = snprintf(buf, sizeof(buf), "beacon_int=%d\n",WIFI_DEFAULT_BI);
-+    write(fd, buf, len);
-+    len = snprintf(buf, sizeof(buf), "dtim_period=%d\n",WIFI_DEFAULT_DTIM);
-+    write(fd, buf, len);
-+    if (argc > 4) {
-+        if (strncmp(argv[6], "wpa2-psk", 8) == 0) {
-+            len = snprintf(buf, sizeof(buf), "wpa=2\n");
-+            write(fd, buf, len);
-+            len = snprintf(buf, sizeof(buf), "wpa_key_mgmt=WPA-PSK\n");
-+            write(fd, buf, len);
-+            len = snprintf(buf, sizeof(buf), "wpa_pairwise=CCMP\n");
-+            write(fd, buf, len);
-+            if (argc > 5) {
-+                len = snprintf(buf, sizeof(buf), "wpa_passphrase=%s\n",argv[7]);
-+                write(fd, buf, len);
-+            } else {
-+                len = snprintf(buf, sizeof(buf), "wpa_passphrase=12345678\n");
-+                write(fd, buf, len);
-+            }
-+        }
-+    }
-+    if (argc > 6) {
-+        len = snprintf(buf, sizeof(buf), "channel=%s\n",argv[5]);
-+        write(fd, buf, len);
-+    } else {
-+        len = snprintf(buf, sizeof(buf), "channel=%d\n",WIFI_DEFAULT_CHANNEL);
-+        write(fd, buf, len);
-+    }
-+        len = snprintf(buf, sizeof(buf), "driver=nl80211\n");
-+        write(fd, buf, len);
-+
-+        len = snprintf(buf, sizeof(buf), "hw_mode=g\n");
-+        write(fd, buf, len);
-+
-+    /*if (argc > 7) {
-+        len = snprintf(buf, sizeof(buf), "preamble=%s\n",argv[7]);
-+        write(fd, buf, len);
-+    } else {
-+        len = snprintf(buf, sizeof(buf), "preamble=%d\n",WIFI_DEFAULT_PREAMBLE);
-+        write(fd, buf, len);
-+    }*/
-+    mProfileValid = 1;
-+
-+    close(fd);
-+
-+    ret = wifi_load_profile(isSoftapStarted());
-+    if (ret < 0) {
-+        ALOGE("Softap set - load new configuration fails");
-+        return ResponseCode::OperationFailed;
-+    }
-+    if (ret) {
-+        ALOGE("Softap set - failed: %d", ret);
-+        return ResponseCode::OperationFailed;
-+    }
-+
-+    ALOGD("Softap set - Ok");
-+    usleep(AP_SET_CFG_DELAY);
-+    return ResponseCode::SoftapStatusResult;
-+}
-+
-+/*
-+ * Arguments:
-+ *	argv[2] - interface name
-+ *	argv[3] - AP or STA
-+ */
-+int SoftapController::fwReloadSoftap(int argc, char *argv[])
-+{
-+    struct iwreq wrq;
-+    int fnum, i = 0;
-+    char *iface;
-+
-+    ALOGD("fwReloadSoftap()");
-+
-+    if (argc < 4) {
-+        ALOGE("Softap fwreload - missing arguments");
-+        return ResponseCode::CommandSyntaxError;
-+    }
-+    ALOGD("Softap fwReload - Ok");
-+    return ResponseCode::SoftapStatusResult;
-+} 
--- 
-1.8.5.2
-
diff --git a/slim.mk b/slim.mk
deleted file mode 100644
index 8be3b67..0000000
--- a/slim.mk
+++ /dev/null
@@ -1,35 +0,0 @@
-#
-# Copyright 2014 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-#
-
-# Specify phone tech before including full_phone
-$(call inherit-product, vendor/slim/config/gsm.mk)
-
-# Inherit some common CM stuff
-$(call inherit-product, vendor/slim/config/common_full_phone.mk)
-
-# Inherit device configuration
-$(call inherit-product, device/huawei/u8833/full_u8833.mk)
-
-# Correct boot animation size for the screen
-TARGET_SCREEN_HEIGHT := 800
-TARGET_SCREEN_WIDTH := 480
-
-# Device name
-PRODUCT_NAME := slim_u8833
-PRODUCT_DEVICE := u8833
-
-PRODUCT_PACKAGES += \
-    Torch
\ No newline at end of file
diff --git a/vendorsetup.sh b/vendorsetup.sh
index 45af644..bb0efe8 100644
--- a/vendorsetup.sh
+++ b/vendorsetup.sh
@@ -1,2 +1,2 @@
-sh device/huawei/msm7x27a-common/patches/apply.sh
-sh device/huawei/u8833/patches/apply.sh
+#sh device/huawei/msm7x27a-common/patches/apply.sh
+#sh device/huawei/u8833/patches/apply.sh

project device/huawei/u8951/
diff --git a/BoardConfig.mk b/BoardConfig.mk
index a3fb346..a6e3bab 100644
--- a/BoardConfig.mk
+++ b/BoardConfig.mk
@@ -13,7 +13,12 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 #
-
+PRODUCT_PREBUILT_WEBVIEWCHROMIUM=yes
+ANDROID_COMPILE_WITH_JACK := false
+DISABLE_DEXPREOPT=true
+WITH_DEXPREOPT=false
+WITH_SU=true
+TARGET_BOOTANIMATION_HALF_RES=false
 # Inherit from the proprietary version
 -include vendor/huawei/u8951/BoardConfigVendor.mk
 
@@ -27,4 +32,4 @@ BOARD_BLUETOOTH_BDROID_BUILDCFG_INCLUDE_DIR := device/huawei/u8951/bluetooth
 
 # NFC
 BOARD_HAVE_NFC := true
-BOARD_NFC_HAL_SUFFIX := huawei
\ No newline at end of file
+BOARD_NFC_HAL_SUFFIX := huawei

project external/stagefright-plugins/
diff --git a/libstagefright/FFmpegExtractor/FFmpegExtractor.cpp b/libstagefright/FFmpegExtractor/FFmpegExtractor.cpp
index 5305039..e1d2f3a 100644
--- a/libstagefright/FFmpegExtractor/FFmpegExtractor.cpp
+++ b/libstagefright/FFmpegExtractor/FFmpegExtractor.cpp
@@ -503,7 +503,7 @@ sp<MetaData> FFmpegExtractor::setAudioFormat(AVStream *stream)
 
         meta->setInt32(kKeyChannelCount, avctx->channels);
         meta->setInt32(kKeyBitRate, avctx->bit_rate);
-        meta->setInt32(kKeySampleBits, bitsPerSample);
+    //    meta->setInt32(kKeySampleBits, bitsPerSample);
         meta->setInt32(kKeySampleRate, avctx->sample_rate);
         meta->setInt32(kKeyBlockAlign, avctx->block_align);
         meta->setInt32(kKeySampleFormat, avctx->sample_fmt);
diff --git a/libstagefright/codecs/ffmpegdec/adec/SoftFFmpegAudio.cpp b/libstagefright/codecs/ffmpegdec/adec/SoftFFmpegAudio.cpp
index 6a5b8ad..fc939ee 100644
--- a/libstagefright/codecs/ffmpegdec/adec/SoftFFmpegAudio.cpp
+++ b/libstagefright/codecs/ffmpegdec/adec/SoftFFmpegAudio.cpp
@@ -518,7 +518,7 @@ OMX_ERRORTYPE SoftFFmpegAudio::internalGetParameter(
 
             profile->nChannels = 0;
             profile->nSampleRate = 0;
-            profile->nBitsPerSample = 0;
+         //   profile->nBitsPerSample = 0;
             return OMX_ErrorNone;
         }
 
@@ -604,7 +604,7 @@ OMX_ERRORTYPE SoftFFmpegAudio::internalGetParameter(
             profile->eCodecId = 0;
             profile->nChannels = 0;
             profile->nBitRate = 0;
-            profile->nBitsPerSample = 0;
+           // profile->nBitsPerSample = 0;
             profile->nSampleRate = 0;
             profile->nBlockAlign = 0;
             profile->eSampleFormat = 0;
@@ -939,14 +939,14 @@ OMX_ERRORTYPE SoftFFmpegAudio::internalSetParameter(
 
             mCtx->channels = profile->nChannels;
             mCtx->sample_rate = profile->nSampleRate;
-            mCtx->bits_per_coded_sample = profile->nBitsPerSample > 16 ? 32 : profile->nBitsPerSample;
-            mCtx->bits_per_raw_sample = profile->nBitsPerSample;
+        //    mCtx->bits_per_coded_sample = profile->nBitsPerSample > 16 ? 32 : profile->nBitsPerSample;
+        //    mCtx->bits_per_raw_sample = profile->nBitsPerSample;
 
             adjustAudioParams();
 
             ALOGV("set OMX_IndexParamAudioFlac, nChannels:%lu, nSampleRate:%lu, "
                     "nBitsPerSample:%lu",
-                profile->nChannels, profile->nSampleRate, profile->nBitsPerSample);
+                profile->nChannels, profile->nSampleRate ); // profile->nBitsPerSample);
 
             return OMX_ErrorNone;
         }
@@ -1010,14 +1010,14 @@ OMX_ERRORTYPE SoftFFmpegAudio::internalSetParameter(
             mCtx->sample_rate = profile->nSamplingRate;
 
             //ape decoder need bits_per_coded_sample
-            mCtx->bits_per_coded_sample = profile->nBitsPerSample;
+           // mCtx->bits_per_coded_sample = profile->nBitsPerSample;
 
             adjustAudioParams();
 
             ALOGV("set OMX_IndexParamAudioApe, nChannels:%lu, "
                     "nSampleRate:%lu, nBitsPerSample:%lu",
-                profile->nChannels, profile->nSamplingRate,
-                profile->nBitsPerSample);
+                profile->nChannels, profile->nSamplingRate );
+             //   profile->nBitsPerSample);
 
             return OMX_ErrorNone;
         }
@@ -1061,7 +1061,7 @@ OMX_ERRORTYPE SoftFFmpegAudio::internalSetParameter(
             mCtx->bit_rate = profile->nBitRate;
             mCtx->bits_per_coded_sample =
                 av_get_bytes_per_sample((AVSampleFormat)profile->eSampleFormat) * 8;
-            mCtx->bits_per_raw_sample = profile->nBitsPerSample;
+         //   mCtx->bits_per_raw_sample = profile->nBitsPerSample;
             mCtx->sample_rate = profile->nSampleRate;
             mCtx->block_align = profile->nBlockAlign;
             mCtx->sample_fmt = (AVSampleFormat)profile->eSampleFormat;
@@ -1074,7 +1074,8 @@ OMX_ERRORTYPE SoftFFmpegAudio::internalSetParameter(
                 "nBlockAlign:%lu, eSampleFormat:%lu(%s)",
                 profile->eCodecId, avcodec_get_name(mCtx->codec_id),
                 profile->nChannels, profile->nBitRate,
-                profile->nBitsPerSample, profile->nSampleRate,
+               // profile->nBitsPerSample, 
+                profile->nSampleRate,
                 profile->nBlockAlign, profile->eSampleFormat,
                 av_get_sample_fmt_name(mCtx->sample_fmt));
             return OMX_ErrorNone;

project frameworks/av/
diff --git a/media/libstagefright/Android.mk b/media/libstagefright/Android.mk
index 3c56a42fa..68994754b 100644
--- a/media/libstagefright/Android.mk
+++ b/media/libstagefright/Android.mk
@@ -110,6 +110,10 @@ ifneq ($(filter caf bfam,$(TARGET_QCOM_AUDIO_VARIANT)),)
             LOCAL_SRC_FILES += LPAPlayer.cpp
             LOCAL_CFLAGS += -DLEGACY_LPA -DUSE_LPA_MODE
         endif
+        ifeq ($(call is-chipset-in-board-platform,msm7x27a),true)
+            LOCAL_SRC_FILES += LPAPlayer.cpp
+            LOCAL_CFLAGS += -DLEGACY_LPA -DUSE_LPA_MODE
+        endif
         ifeq ($(call is-chipset-in-board-platform,msm7x30),true)
             LOCAL_SRC_FILES += LPAPlayer.cpp
             LOCAL_CFLAGS += -DLEGACY_LPA -DUSE_LPA_MODE

project frameworks/base/
diff --git a/core/java/android/app/ActivityThread.java b/core/java/android/app/ActivityThread.java
index 231510da..cd085006 100644
--- a/core/java/android/app/ActivityThread.java
+++ b/core/java/android/app/ActivityThread.java
@@ -39,7 +39,7 @@ import android.content.pm.ServiceInfo;
 import android.content.res.AssetManager;
 import android.content.res.CompatibilityInfo;
 import android.content.res.Configuration;
-import android.content.res.CustomTheme;
+//import android.content.res.CustomTheme;
 import android.content.res.Resources;
 import android.database.sqlite.SQLiteDatabase;
 import android.database.sqlite.SQLiteDebug;
diff --git a/core/java/android/app/ContextImpl.java b/core/java/android/app/ContextImpl.java
index b8bfaa6a..a2c23a19 100644
--- a/core/java/android/app/ContextImpl.java
+++ b/core/java/android/app/ContextImpl.java
@@ -46,7 +46,7 @@ import android.content.pm.PackageManager.NameNotFoundException;
 import android.content.res.AssetManager;
 import android.content.res.CompatibilityInfo;
 import android.content.res.Configuration;
-import android.content.res.CustomTheme;
+//import android.content.res.CustomTheme;
 import android.content.res.Resources;
 import android.database.DatabaseErrorHandler;
 import android.database.sqlite.SQLiteDatabase;
diff --git a/core/java/android/app/ResourcesManager.java b/core/java/android/app/ResourcesManager.java
index 22e7039c..11a23cd9 100644
--- a/core/java/android/app/ResourcesManager.java
+++ b/core/java/android/app/ResourcesManager.java
@@ -29,7 +29,7 @@ import android.content.pm.ThemeUtils;
 import android.content.res.AssetManager;
 import android.content.res.CompatibilityInfo;
 import android.content.res.Configuration;
-import android.content.res.CustomTheme;
+import android.content.res.ThemeConfig;
 import android.content.res.Resources;
 import android.content.res.ResourcesKey;
 import android.hardware.display.DisplayManagerGlobal;
@@ -216,26 +216,27 @@ public class ResourcesManager {
             config = getConfiguration();
         }
 
+        boolean iconsAttached = false;
         /* Attach theme information to the resulting AssetManager when appropriate. */
         if (compatInfo.isThemeable && config != null && !context.getPackageManager().isSafeMode()) {
-            if (config.customTheme == null) {
+            if (config.themeConfig == null) {
                 try {
-                    config.customTheme = CustomTheme.getBootTheme(context.getContentResolver());
+                    config.themeConfig = ThemeConfig.getBootTheme(context.getContentResolver());
                 } catch (Exception e) {
-                    Slog.d(TAG, "CustomTheme.getBootTheme failed, falling back to system theme", e);
-                    config.customTheme = CustomTheme.getSystemTheme();
+                    Slog.d(TAG, "ThemeConfig.getBootTheme failed, falling back to system theme", e);
+                    config.themeConfig = ThemeConfig.getSystemTheme();
                 }
             }
 
-            if (config.customTheme != null) {
-                attachThemeAssets(assets, config.customTheme);
-                attachCommonAssets(assets, config.customTheme);
-                attachIconAssets(assets, config.customTheme);
+            if (config.themeConfig != null) {
+                attachThemeAssets(assets, config.themeConfig);
+                attachCommonAssets(assets, config.themeConfig);
+                iconsAttached = attachIconAssets(assets, config.themeConfig);
             }
         }
 
         r = new Resources(assets, dm, config, compatInfo, token);
-        setActivityIcons(r);
+        if (iconsAttached) setActivityIcons(r);
 
         if (false) {
             Slog.i(TAG, "Created app resources " + resDir + " " + r + ": "
@@ -281,6 +282,12 @@ public class ResourcesManager {
             return;
         }
 
+        final ThemeConfig themeConfig = r.getConfiguration().themeConfig;
+        if (pkgName != null && themeConfig != null &&
+                pkgName.equals(themeConfig.getIconPackPkgName())) {
+            return;
+        }
+
         //Map application icon
         if (pkgInfo != null && pkgInfo.applicationInfo != null) {
             appInfo = pkgInfo.applicationInfo;
@@ -362,11 +369,12 @@ public class ResourcesManager {
                         r.setIconResources(null);
                         r.setComposedIconInfo(null);
                         detachThemeAssets(am);
-                        if (config.customTheme != null) {
-                            attachThemeAssets(am, config.customTheme);
-                            attachCommonAssets(am, config.customTheme);
-                            attachIconAssets(am, config.customTheme);
-                            setActivityIcons(r);
+                        if (config.themeConfig != null) {
+                            attachThemeAssets(am, config.themeConfig);
+                            attachCommonAssets(am, config.themeConfig);
+                            if (attachIconAssets(am, config.themeConfig)) {
+                                setActivityIcons(r);
+                            }
                         }
                     }
                 }
@@ -421,7 +429,7 @@ public class ResourcesManager {
      *         removed and the theme manager has yet to revert formally back to
      *         the framework default.
      */
-    private boolean attachThemeAssets(AssetManager assets, CustomTheme theme) {
+    private boolean attachThemeAssets(AssetManager assets, ThemeConfig theme) {
         PackageInfo piTheme = null;
         PackageInfo piTarget = null;
         PackageInfo piAndroid = null;
@@ -444,7 +452,7 @@ public class ResourcesManager {
 
         try {
             piTheme = getPackageManager().getPackageInfo(
-                    theme.getThemePackageNameForApp(basePackageName), 0, UserHandle.myUserId());
+                    theme.getOverlayPkgNameForApp(basePackageName), 0, UserHandle.myUserId());
             piTarget = getPackageManager().getPackageInfo(
                     basePackageName, 0, UserHandle.myUserId());
 
@@ -511,7 +519,7 @@ public class ResourcesManager {
      * @param theme
      * @return true if succes, false otherwise
      */
-    private boolean attachIconAssets(AssetManager assets, CustomTheme theme) {
+    private boolean attachIconAssets(AssetManager assets, ThemeConfig theme) {
         PackageInfo piIcon = null;
         try {
             piIcon = getPackageManager().getPackageInfo(theme.getIconPackPkgName(), 0, UserHandle.myUserId());
@@ -556,10 +564,10 @@ public class ResourcesManager {
      * @param theme
      * @return true if succes, false otherwise
      */
-    private boolean attachCommonAssets(AssetManager assets, CustomTheme theme) {
+    private boolean attachCommonAssets(AssetManager assets, ThemeConfig theme) {
         PackageInfo piTheme = null;
         try {
-            piTheme = getPackageManager().getPackageInfo(theme.getThemePackageName(), 0,
+            piTheme = getPackageManager().getPackageInfo(theme.getOverlayPkgName(), 0,
                     UserHandle.myUserId());
         } catch (RemoteException e) {
         }
diff --git a/core/java/android/content/pm/ThemeUtils.java b/core/java/android/content/pm/ThemeUtils.java
index b3c5a0dc..5e2d91da 100644
--- a/core/java/android/content/pm/ThemeUtils.java
+++ b/core/java/android/content/pm/ThemeUtils.java
@@ -49,7 +49,7 @@ import java.util.zip.ZipEntry;
 import java.util.zip.ZipInputStream;
 import java.util.zip.ZipOutputStream;
 
-import static android.content.res.CustomTheme.HOLO_DEFAULT;
+import static android.content.res.ThemeConfig.HOLO_DEFAULT;
 
 /**
  * @hide
diff --git a/core/java/android/content/res/Configuration.java b/core/java/android/content/res/Configuration.java
index 42f01974..163c452a 100644
--- a/core/java/android/content/res/Configuration.java
+++ b/core/java/android/content/res/Configuration.java
@@ -22,9 +22,9 @@ import android.os.Parcel;
 import android.os.Parcelable;
 import android.text.TextUtils;
 import android.view.View;
-import android.util.Log;
-import android.os.SystemProperties;
-import android.text.TextUtils;
+//import android.util.Log;
+//import android.os.SystemProperties;
+//import android.text.TextUtils;
 
 import java.util.Locale;
 
@@ -79,7 +79,7 @@ public final class Configuration implements Parcelable, Comparable<Configuration
     /**
      * @hide
      */
-    public CustomTheme customTheme;
+    public ThemeConfig themeConfig;
 
     /**
      * Locale should persist on setting.  This is hidden because it is really
@@ -416,28 +416,41 @@ public final class Configuration implements Parcelable, Comparable<Configuration
 
     /**
      * @hide
-     */
-    public static final int THEME_UNDEFINED = 0;
-
-    /**
+     * @deprecated
      * @hide
      */
     public static final String THEME_PACKAGE_NAME_PERSISTENCE_PROPERTY = "persist.sys.themePackageName";
 
     /**
      * @hide
+     * @deprecated
      */
-    public static final String THEME_SYSTEMUI_PACKAGE_NAME_PERSISTENCE_PROPERTY = "persist.sys.themeSysUiPkgName";
+    public static final String THEME_ICONPACK_PACKAGE_NAME_PERSISTENCE_PROPERTY = "themeIconPackPkgName";
 
     /**
      * @hide
+     * @deprecated 
      */
-    public static final String THEME_ICONPACK_PACKAGE_NAME_PERSISTENCE_PROPERTY = "themeIconPackPkgName";
+    public static final String THEME_FONT_PACKAGE_NAME_PERSISTENCE_PROPERTY = "themeFontPackPkgName";
 
     /**
      * @hide
+     * Serialized json structure mapping app pkgnames to their set theme.
+     *
+     * {
+     *  "default":{
+     *"     stylePkgName":"com.jasonevil.theme.miuiv5dark",
+     *      "iconPkgName":"com.cyngn.hexo",
+     *      "fontPkgName":"com.cyngn.hexo"
+     *   }
+     * }
+
+     * If an app does not have a specific theme set then it will use the 'default' theme+
+     * example: 'default' -> overlayPkgName: 'org.blue.theme'
+     *          'com.android.phone' -> 'com.red.theme'
+     *          'com.google.vending' -> 'com.white.theme'
      */
-    public static final String THEME_FONT_PACKAGE_NAME_PERSISTENCE_PROPERTY = "themeFontPackPkgName";
+    public static final String THEME_PKG_CONFIGURATION_PERSISTENCE_PROPERTY = "themeConfig";
 
     /**
      * Overall orientation of the screen.  May be one of
@@ -692,8 +705,8 @@ public final class Configuration implements Parcelable, Comparable<Configuration
         compatScreenHeightDp = o.compatScreenHeightDp;
         compatSmallestScreenWidthDp = o.compatSmallestScreenWidthDp;
         seq = o.seq;
-        if (o.customTheme != null) {
-            customTheme = (CustomTheme) o.customTheme.clone();
+        if (o.themeConfig != null) {
+            themeConfig = (ThemeConfig) o.themeConfig.clone();  
         }
     }
 
@@ -838,7 +851,7 @@ public final class Configuration implements Parcelable, Comparable<Configuration
             sb.append(seq);
         }
         sb.append(" themeResource=");
-        sb.append(customTheme);
+        sb.append(themeConfig);
         sb.append('}');
         return sb.toString();
     }
@@ -866,7 +879,7 @@ public final class Configuration implements Parcelable, Comparable<Configuration
         smallestScreenWidthDp = compatSmallestScreenWidthDp = SMALLEST_SCREEN_WIDTH_DP_UNDEFINED;
         densityDpi = DENSITY_DPI_UNDEFINED;
         seq = 0;
-        customTheme = null;
+        themeConfig = null;
     }
 
     /** {@hide} */
@@ -1015,10 +1028,10 @@ public final class Configuration implements Parcelable, Comparable<Configuration
             seq = delta.seq;
         }
 
-        if (delta.customTheme != null
-                && (customTheme == null || !customTheme.equals(delta.customTheme))) {
+        if (delta.themeConfig != null
+                && (themeConfig == null || !themeConfig.equals(delta.themeConfig))) {
             changed |= ActivityInfo.CONFIG_THEME_RESOURCE;
-            customTheme = (CustomTheme)delta.customTheme.clone();
+            themeConfig = (ThemeConfig)delta.themeConfig.clone();
         }
 
         return changed;
@@ -1134,8 +1147,8 @@ public final class Configuration implements Parcelable, Comparable<Configuration
                 && densityDpi != delta.densityDpi) {
             changed |= ActivityInfo.CONFIG_DENSITY;
         }
-        if (delta.customTheme != null &&
-                (customTheme == null || !customTheme.equals(delta.customTheme))) {
+        if (delta.themeConfig != null &&
+                (themeConfig == null || !themeConfig.equals(delta.themeConfig))) { 
             changed |= ActivityInfo.CONFIG_THEME_RESOURCE;
         }
         return changed;
@@ -1229,7 +1242,7 @@ public final class Configuration implements Parcelable, Comparable<Configuration
         dest.writeInt(compatScreenHeightDp);
         dest.writeInt(compatSmallestScreenWidthDp);
         dest.writeInt(seq);
-        dest.writeParcelable(customTheme, flags);
+        dest.writeParcelable(themeConfig, flags); 
     }
 
     public void readFromParcel(Parcel source) {
@@ -1259,7 +1272,7 @@ public final class Configuration implements Parcelable, Comparable<Configuration
         compatScreenHeightDp = source.readInt();
         compatSmallestScreenWidthDp = source.readInt();
         seq = source.readInt();
-        customTheme = source.readParcelable(CustomTheme.class.getClassLoader());
+        themeConfig = source.readParcelable(ThemeConfig.class.getClassLoader());
     }
     
     public static final Parcelable.Creator<Configuration> CREATOR
@@ -1330,10 +1343,10 @@ public final class Configuration implements Parcelable, Comparable<Configuration
         if (n != 0) return n;
         n = this.densityDpi - that.densityDpi;
         if (n != 0) return n;
-        if (this.customTheme == null) {
-            if (that.customTheme != null) return 1;
+        if (this.themeConfig == null) {
+            if (that.themeConfig != null) return 1;
         } else {
-            n = this.customTheme.compareTo(that.customTheme);
+            n = this.themeConfig.compareTo(that.themeConfig);
         }
         return n;
     }
@@ -1372,8 +1385,8 @@ public final class Configuration implements Parcelable, Comparable<Configuration
         result = 31 * result + screenHeightDp;
         result = 31 * result + smallestScreenWidthDp;
         result = 31 * result + densityDpi;
-        result = 31 * result + (this.customTheme != null ?
-                                  this.customTheme.hashCode() : 0);
+        result = 31 * result + (this.themeConfig != null ?
+                                  this.themeConfig.hashCode() : 0);
         return result;
     }
 
diff --git a/core/java/android/content/res/CustomTheme.java b/core/java/android/content/res/CustomTheme.java
deleted file mode 100644
index f8cddd50..00000000
--- a/core/java/android/content/res/CustomTheme.java
+++ /dev/null
@@ -1,262 +0,0 @@
-/*
- * Copyright (C) 2010, T-Mobile USA, Inc.
- * This code has been modified.
- * Portions copyright (C) 2014, The CyanogenMod Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.content.res;
-
-import android.content.ContentResolver;
-import android.os.Parcel;
-import android.os.Parcelable;
-import android.provider.Settings;
-import android.text.TextUtils;
-
-/**
- * @hide
- */
-public final class CustomTheme implements Cloneable, Parcelable, Comparable<CustomTheme> {
-    private final String SYSTEMUI_PKG_NAME = "com.android.systemui";
-
-    public static final String HOLO_DEFAULT = "holo";
-
-    protected final String mThemePackageName;
-    protected final String mIconPackPkgName;
-    protected final String mSystemUiThemePkgName;
-    protected final String mFontPkgName;
-
-    private static final CustomTheme sSystemTheme = new CustomTheme("","","","");
-
-    private CustomTheme(Parcel src) {
-        mThemePackageName = src.readString();
-        mSystemUiThemePkgName = src.readString();
-        mIconPackPkgName = src.readString();
-        mFontPkgName = src.readString();
-    }
-
-    /**
-     * Constructor used in legacy theme manager
-     */
-    public CustomTheme(String pkgName, String systemUiThemePkgName, String iconPackPkgName) {
-        this(pkgName, systemUiThemePkgName, iconPackPkgName, "");
-    }
-
-    public CustomTheme(String pkgName, String systemUiThemePkgName, String iconPackPkgName, String fontPkgName) {
-        mThemePackageName = pkgName;
-        mSystemUiThemePkgName = systemUiThemePkgName;
-        mIconPackPkgName = iconPackPkgName;
-        mFontPkgName = fontPkgName;
-    }
-
-    @Override
-    public Object clone() {
-        try {
-            return super.clone();
-        } catch (CloneNotSupportedException e) {
-            return null;
-        }
-    }
-
-    @Override
-    public boolean equals(Object object) {
-        if (object == this) {
-            return true;
-        }
-        if (object instanceof CustomTheme) {
-            CustomTheme o = (CustomTheme) object;
-
-            String currentSystemUi = (mSystemUiThemePkgName == null)? "" : mSystemUiThemePkgName;
-            String newSystemUi = (o.mSystemUiThemePkgName == null)? "" : o.mSystemUiThemePkgName;
-
-            String currentPackageName = (mThemePackageName == null)? "" : mThemePackageName;
-            String newPackageName = (o.mThemePackageName == null)? "" : o.mThemePackageName;
-
-            String currentIconPkgName = (mIconPackPkgName == null)? "" : mIconPackPkgName;
-            String newIconPkgName = (o.mIconPackPkgName == null)? "" : o.mIconPackPkgName;
-
-            String currentFontPkgName = (mFontPkgName == null)? "" : mFontPkgName;
-            String newFontPkgName = (o.mFontPkgName == null)? "" : o.mFontPkgName;
-
-            return (currentPackageName.equals(newPackageName) &&
-                    currentSystemUi.equals(newSystemUi) &&
-                    currentIconPkgName.equals(newIconPkgName) &&
-                    currentFontPkgName.equals(newFontPkgName));
-        }
-        return false;
-    }
-
-    @Override
-    public final String toString() {
-        StringBuilder result = new StringBuilder();
-        if (!TextUtils.isEmpty(mThemePackageName) && !TextUtils.isEmpty(mSystemUiThemePkgName)) {
-            result.append(mThemePackageName);
-            result.append('(');
-            result.append(mSystemUiThemePkgName);
-            result.append(')');
-
-            if (!TextUtils.isEmpty(mIconPackPkgName)) {
-                result.append(", iconPack:");
-                result.append(mIconPackPkgName);
-            }
-
-            if (!TextUtils.isEmpty(mFontPkgName)) {
-                result.append(", fontPkg:");
-                result.append(mFontPkgName);
-            }
-        } else {
-            result.append("system");
-        }
-        return result.toString();
-    }
-
-    @Override
-    public synchronized int hashCode() {
-        return (mSystemUiThemePkgName + mThemePackageName + mIconPackPkgName + mFontPkgName).hashCode();
-    }
-
-    public String getThemePackageName() {
-        return mThemePackageName;
-    }
-
-    public String getIconPackPkgName() {
-        return mIconPackPkgName;
-    }
-
-    public String getFontPackPkgName() {
-        return mFontPkgName;
-    }
-
-    public String getThemePackageNameForApp(String appPkgName) {
-        if (SYSTEMUI_PKG_NAME.equals(appPkgName) && mSystemUiThemePkgName != null && !mSystemUiThemePkgName.equals("")) {
-            return mSystemUiThemePkgName;
-        }
-        return mThemePackageName;
-    }
-
-    public String getSystemUiPackageName() {
-        return mSystemUiThemePkgName;
-    }
-
-    /**
-     * Represents the theme that the device booted into. This is used to
-     * simulate a "default" configuration based on the user's last known
-     * preference until the theme is switched at runtime.
-     */
-    public static CustomTheme getBootTheme(ContentResolver resolver) {
-        try {
-            String themePkgName = Settings.Secure.getString(resolver, Configuration.THEME_PACKAGE_NAME_PERSISTENCE_PROPERTY);
-            if (themePkgName == null) themePkgName = "";
-
-            String systemUiPkgName = Settings.Secure.getString(resolver, Configuration.THEME_SYSTEMUI_PACKAGE_NAME_PERSISTENCE_PROPERTY);
-            if (systemUiPkgName == null) systemUiPkgName = "";
-
-            String iconPackPkgName = Settings.Secure.getString(resolver, Configuration.THEME_ICONPACK_PACKAGE_NAME_PERSISTENCE_PROPERTY);
-            if (iconPackPkgName == null) iconPackPkgName = "";
-
-            String fontPkgName = Settings.Secure.getString(resolver, Configuration.THEME_FONT_PACKAGE_NAME_PERSISTENCE_PROPERTY);
-            if (fontPkgName == null) fontPkgName = "";
-            return new CustomTheme(themePkgName, systemUiPkgName, iconPackPkgName, fontPkgName);
-        } catch (SecurityException e) {
-            return sSystemTheme;
-        }
-    }
-
-    /**
-     * Represents the system framework theme, perceived by the system as there
-     * being no theme applied.
-     */
-    public static CustomTheme getSystemTheme() {
-        return sSystemTheme;
-    }
-
-    @Override
-    public int describeContents() {
-        return 0;
-    }
-
-    @Override
-    public void writeToParcel(Parcel dest, int flags) {
-        dest.writeString(mThemePackageName);
-        dest.writeString(mSystemUiThemePkgName);
-        dest.writeString(mIconPackPkgName);
-        dest.writeString(mFontPkgName);
-    }
-
-    public static final Parcelable.Creator<CustomTheme> CREATOR = new Parcelable.Creator<CustomTheme>() {
-        public CustomTheme createFromParcel(Parcel source) {
-            return new CustomTheme(source);
-        }
-
-        public CustomTheme[] newArray(int size) {
-            return new CustomTheme[size];
-        }
-    };
-
-    @Override
-    public int compareTo(CustomTheme o) {
-        if (o == null) return -1;
-        int n = 0;
-        n = mSystemUiThemePkgName.compareTo(o.mSystemUiThemePkgName);
-        if (n != 0) return n;
-        n = mThemePackageName.compareTo(o.mThemePackageName);
-        if (n != 0) return n;
-        n = mIconPackPkgName.compareTo(o.mIconPackPkgName);
-        if (n != 0) return n;
-        n = mFontPkgName.compareTo(o.mFontPkgName);
-        return n;
-    }
-
-    public static class Builder {
-        private String mThemePkgName;
-        private String mSystemUiPkgName;
-        private String mIconPkgName;
-        private String mFontPkgName;
-
-        public Builder() {
-        }
-
-        public Builder(CustomTheme theme) {
-            if (theme == null) return;
-            mIconPkgName = theme.mIconPackPkgName;
-            mThemePkgName = theme.mThemePackageName;
-            mSystemUiPkgName = theme.mThemePackageName;
-            mFontPkgName = theme.mFontPkgName;
-        }
-
-        public Builder overlay(String pkgName) {
-            this.mThemePkgName = pkgName.equals(HOLO_DEFAULT) ? "" : pkgName;
-            return this;
-        }
-
-        public Builder systemUi(String pkgName) {
-            this.mSystemUiPkgName = pkgName.equals(HOLO_DEFAULT) ? "" : pkgName;
-            return this;
-        }
-
-        public Builder icons(String pkgName) {
-            this.mIconPkgName = pkgName.equals(HOLO_DEFAULT) ? "" : pkgName;
-            return this;
-        }
-
-        public Builder fonts(String pkgName) {
-            this.mFontPkgName = pkgName.equals(HOLO_DEFAULT) ? "" : pkgName;
-            return this;
-        }
-
-        public CustomTheme build() {
-            return new CustomTheme(mThemePkgName, mSystemUiPkgName, mIconPkgName, mFontPkgName);
-        }
-    }
-}
diff --git a/core/java/android/provider/ThemesContract.java b/core/java/android/provider/ThemesContract.java
index 32e23c20..7c01cba6 100644
--- a/core/java/android/provider/ThemesContract.java
+++ b/core/java/android/provider/ThemesContract.java
@@ -168,6 +168,22 @@ public class ThemesContract {
          */
         public static final String MODIFIES_OVERLAYS = "mods_overlays";
 
+        public static final String MODIFIES_STATUS_BAR = "mods_status_bar";
+
+        /**
+         * 1 if theme has an overlay for SystemUI/NavBar
+         * <P>Type: INTEGER</P>
+         * <P>Default: 0</P>
+         */
+        public static final String MODIFIES_NAVIGATION_BAR = "mods_navigation_bar";
+
+        /**
+         * 1 if theme has a live lock screen
+         * <P>Type: INTEGER</P>
+         * <P>Default: 0</P>
+         */
+        public static final String MODIFIES_LIVE_LOCK_SCREEN = "mods_live_lock_screen";
+
         /**
          * URI to the theme's wallpaper. We should support multiple wallpaper
          * but for now we will just have 1.
@@ -247,6 +263,9 @@ public class ThemesContract {
         public static final String KEY_NOTIFICATIONS = "mixnmatch_notifications";
         public static final String KEY_RINGTONE = "mixnmatch_ringtone";
         public static final String KEY_OVERLAYS = "mixnmatch_overlays";
+        public static final String KEY_NAVIGATION_BAR = "mixnmatch_navigation_bar";
+        public static final String KEY_LIVE_LOCK_SCREEN = "mixnmatch_live_lock_screen";
+
 
         public static final String[] ROWS = { KEY_HOMESCREEN,
             KEY_LOCKSCREEN,
@@ -257,7 +276,9 @@ public class ThemesContract {
             KEY_NOTIFICATIONS,
             KEY_RINGTONE,
             KEY_ALARM,
-            KEY_OVERLAYS
+            KEY_OVERLAYS,
+            KEY_NAVIGATION_BAR,
+            KEY_LIVE_LOCK_SCREEN
         };
 
         /**
@@ -285,6 +306,15 @@ public class ThemesContract {
                 throw new IllegalArgumentException("Ringtone mixnmatch component does not have a related column");
             } else if (component.equals(MixnMatchColumns.KEY_OVERLAYS)) {
                 return ThemesColumns.OVERLAYS_URI;
+            } else if (component.equals(MixnMatchColumns.KEY_STATUS_BAR)) {
+                throw new IllegalArgumentException(
+                        "Status bar mixnmatch component does not have a related column");
+            } else if (component.equals(MixnMatchColumns.KEY_NAVIGATION_BAR)) {
+                throw new IllegalArgumentException(
+                        "Navigation bar mixnmatch component does not have a related column");
+            } else if (component.equals(MixnMatchColumns.KEY_LIVE_LOCK_SCREEN)) {
+                throw new IllegalArgumentException(
+                        "Live lock screen mixnmatch component does not have a related column");
             }
             return null;
         }
@@ -312,6 +342,12 @@ public class ThemesContract {
                 return MixnMatchColumns.KEY_RINGTONE;
             } else if (component.equals(ThemesColumns.MODIFIES_OVERLAYS)) {
                 return MixnMatchColumns.KEY_OVERLAYS;
+            } else if (component.equals(ThemesColumns.MODIFIES_STATUS_BAR)) {
+                return MixnMatchColumns.KEY_STATUS_BAR;
+            } else if (component.equals(ThemesColumns.MODIFIES_NAVIGATION_BAR)) {
+                return MixnMatchColumns.KEY_NAVIGATION_BAR;
+            } else if (component.equals(ThemesColumns.MODIFIES_LIVE_LOCK_SCREEN)) {
+                return MixnMatchColumns.KEY_LIVE_LOCK_SCREEN;
             }
             return null;
         }
@@ -339,6 +375,12 @@ public class ThemesContract {
                 return ThemesColumns.MODIFIES_RINGTONES;
             } else if (mixnmatchKey.equals(MixnMatchColumns.KEY_OVERLAYS)) {
                 return ThemesColumns.MODIFIES_OVERLAYS;
+            } else if (mixnmatchKey.equals(MixnMatchColumns.KEY_STATUS_BAR)) {
+                return ThemesColumns.MODIFIES_STATUS_BAR;
+            } else if (mixnmatchKey.equals(MixnMatchColumns.KEY_NAVIGATION_BAR)) {
+                return ThemesColumns.MODIFIES_NAVIGATION_BAR;
+            } else if (mixnmatchKey.equals(MixnMatchColumns.KEY_LIVE_LOCK_SCREEN)) {
+                return ThemesColumns.MODIFIES_LIVE_LOCK_SCREEN;
             }
             return null;
         }
diff --git a/core/java/android/webkit/CookieSyncManager.java b/core/java/android/webkit/CookieSyncManager.java
index 13aa43f0..df82e62e 100644
--- a/core/java/android/webkit/CookieSyncManager.java
+++ b/core/java/android/webkit/CookieSyncManager.java
@@ -89,7 +89,10 @@ public final class CookieSyncManager extends WebSyncManager {
         if (context == null) {
             throw new IllegalArgumentException("Invalid context argument");
         }
-
+        // TODO: Remove this workaround after webview classic is no longer supported.
+        if (WebViewFactory.getProvider().getClass().getName().contains("WebViewClassic")) {
+            WebViewDatabase.getInstance(context);
+        }
         setGetInstanceIsAllowed();
         return getInstance();
     }
diff --git a/core/java/android/webkit/DebugFlags.java b/core/java/android/webkit/DebugFlags.java
index b5ca8c17..cb7956be 100644
--- a/core/java/android/webkit/DebugFlags.java
+++ b/core/java/android/webkit/DebugFlags.java
@@ -34,5 +34,21 @@ public class DebugFlags {
     public static final boolean TRACE_JAVASCRIPT_BRIDGE = false;
     public static final boolean URL_UTIL = false;
     public static final boolean WEB_SYNC_MANAGER = false;
+     // TODO: Delete these when WebViewClassic is moved
+    public static final boolean BROWSER_FRAME = false;
+    public static final boolean CACHE_MANAGER = false;
+    public static final boolean CALLBACK_PROXY = false;
+    public static final boolean COOKIE_MANAGER = false;
+    public static final boolean FRAME_LOADER = false;
+    public static final boolean J_WEB_CORE_JAVA_BRIDGE = false;// HIGHLY VERBOSE
+    public static final boolean LOAD_LISTENER = false;
+    public static final boolean MEASURE_PAGE_SWAP_FPS = false;
+    public static final boolean NETWORK = false;
+    public static final boolean SSL_ERROR_HANDLER = false;
+    public static final boolean STREAM_LOADER = false;
+    public static final boolean WEB_BACK_FORWARD_LIST = false;
+    public static final boolean WEB_SETTINGS = false;
+    public static final boolean WEB_VIEW = false;
+    public static final boolean WEB_VIEW_CORE = false;
 
 }
diff --git a/core/java/android/webkit/WebViewFactory.java b/core/java/android/webkit/WebViewFactory.java
index b9131bf3..304c335b 100644
--- a/core/java/android/webkit/WebViewFactory.java
+++ b/core/java/android/webkit/WebViewFactory.java
@@ -29,6 +29,12 @@ import android.util.Log;
  */
 public final class WebViewFactory {
 
+    private static final String FORCE_PROVIDER_PROPERTY = "persist.webview.provider";
+    private static final String FORCE_PROVIDER_PROPERTY_VALUE_CHROMIUM = "chromium";
+    private static final String FORCE_PROVIDER_PROPERTY_VALUE_CLASSIC = "classic";
+
+    // Default Provider factory class name.
+    private static final String DEFAULT_WEBVIEW_FACTORY = "android.webkit.WebViewClassic$Factory";
     private static final String CHROMIUM_WEBVIEW_FACTORY =
             "com.android.webview.chromium.WebViewChromiumFactoryProvider";
 
@@ -52,32 +58,33 @@ public final class WebViewFactory {
     private static WebViewFactoryProvider sProviderInstance;
     private static final Object sProviderLock = new Object();
 
-    public static boolean isExperimentalWebViewAvailable() {
-        // TODO: Remove callers of this method then remove it.
-        return false;  // Hide the toggle in Developer Settings.
+    public static boolean isClassicWebViewAvailable() {
+        return true;
     }
 
     /** @hide */
-    public static void setUseExperimentalWebView(boolean enable) {
-        // TODO: Remove callers of this method then remove it.
+    public static void setUseClassicWebView(boolean enable) {
+        SystemProperties.set(FORCE_PROVIDER_PROPERTY, enable ? FORCE_PROVIDER_PROPERTY_VALUE_CLASSIC : FORCE_PROVIDER_PROPERTY_VALUE_CHROMIUM);
+        Log.i(LOGTAG, "Use Classic WebView changed: "
+                + SystemProperties.get(WebViewFactory.FORCE_PROVIDER_PROPERTY, ""));
     }
 
     /** @hide */
-    public static boolean useExperimentalWebView() {
-        // TODO: Remove callers of this method then remove it.
-        return true;
+    public static boolean useClassicWebView() {
+        return (SystemProperties.get(FORCE_PROVIDER_PROPERTY,
+             "") == FORCE_PROVIDER_PROPERTY_VALUE_CLASSIC);
     }
 
     /** @hide */
-    public static boolean isUseExperimentalWebViewSet() {
-        // TODO: Remove callers of this method then remove it.
-        return false;  // User has not modifed Developer Settings
+    public static boolean isUseClassicWebViewSet() {
+        return (SystemProperties.get(FORCE_PROVIDER_PROPERTY,
+             "") == FORCE_PROVIDER_PROPERTY_VALUE_CLASSIC);
     }
 
     static WebViewFactoryProvider getProvider() {
         synchronized (sProviderLock) {
             // For now the main purpose of this function (and the factory abstraction) is to keep
-            // us honest and minimize usage of WebView internals when binding the proxy.
+            // us honest and minimize usage of WebViewClassic internals when binding the proxy.
             if (sProviderInstance != null) return sProviderInstance;
 
             Class<WebViewFactoryProvider> providerClass;
@@ -110,8 +117,25 @@ public final class WebViewFactory {
             }
         }
     }
+    // We allow a system property to specify that we should use the classic Chromium powered
+    // WebView. This enables us to switch between implementations at runtime.
+    private static boolean isClassicWebViewEnabled() {
+        String forceProviderName = SystemProperties.get(FORCE_PROVIDER_PROPERTY);
+        if (forceProviderName.isEmpty()) return true;
+
+        Log.i(LOGTAG, String.format("Provider overridden by property: %s=%s",
+                FORCE_PROVIDER_PROPERTY, forceProviderName));
+        if (forceProviderName.equals(FORCE_PROVIDER_PROPERTY_VALUE_CHROMIUM)) return false;
+        if (forceProviderName.equals(FORCE_PROVIDER_PROPERTY_VALUE_CLASSIC)) return true;
+        Log.e(LOGTAG, String.format("Unrecognized provider: %s", forceProviderName));
+        return true;
+    }
 
     private static Class<WebViewFactoryProvider> getFactoryClass() throws ClassNotFoundException {
-        return (Class<WebViewFactoryProvider>) Class.forName(CHROMIUM_WEBVIEW_FACTORY);
+    if (isClassicWebViewEnabled()) {
+            return (Class<WebViewFactoryProvider>) Class.forName(DEFAULT_WEBVIEW_FACTORY);
+        } else  {
+            return (Class<WebViewFactoryProvider>) Class.forName(CHROMIUM_WEBVIEW_FACTORY);
+        }
     }
 }
diff --git a/core/java/com/android/internal/app/ProcessStats.java b/core/java/com/android/internal/app/ProcessStats.java
index 0cad33cf..c4a4962a 100644
--- a/core/java/com/android/internal/app/ProcessStats.java
+++ b/core/java/com/android/internal/app/ProcessStats.java
@@ -1054,7 +1054,7 @@ public final class ProcessStats implements Parcelable {
                 mRuntime = runtime;
             }
         }
-        String webview = WebViewFactory.useExperimentalWebView() ? "chromeview" : "webview";
+        String webview = WebViewFactory.useClassicWebView() ? "chromeview" : "webview";
         if (!Objects.equals(webview, mWebView)) {
             changed = true;
             if (update) {
diff --git a/core/jni/android/graphics/Bitmap.cpp b/core/jni/android/graphics/Bitmap.cpp
index 7f3da750..fa79c8ef 100644
--- a/core/jni/android/graphics/Bitmap.cpp
+++ b/core/jni/android/graphics/Bitmap.cpp
@@ -233,7 +233,7 @@ static void __BITMAP_OPTS ToColor_SI8_Alpha(SkColor dst[], const void* src, int
     do {
         *dst++ = SkUnPreMultiply::PMColorToColor(colors[*s++]);
     } while (--width != 0);
-    ctable->unlockColors(false);
+    ctable->unlockColors();
 }
 
 static void __BITMAP_OPTS ToColor_SI8_Raw(SkColor dst[], const void* src, int width,
@@ -246,7 +246,7 @@ static void __BITMAP_OPTS ToColor_SI8_Raw(SkColor dst[], const void* src, int wi
         *dst++ = SkColorSetARGB(SkGetPackedA32(c), SkGetPackedR32(c),
                                 SkGetPackedG32(c), SkGetPackedB32(c));
     } while (--width != 0);
-    ctable->unlockColors(false);
+    ctable->unlockColors();
 }
 
 static void __BITMAP_OPTS ToColor_SI8_Opaque(SkColor dst[], const void* src, int width,
@@ -259,7 +259,7 @@ static void __BITMAP_OPTS ToColor_SI8_Opaque(SkColor dst[], const void* src, int
         *dst++ = SkColorSetRGB(SkGetPackedR32(c), SkGetPackedG32(c),
                                SkGetPackedB32(c));
     } while (--width != 0);
-    ctable->unlockColors(false);
+    ctable->unlockColors();
 }
 
 // can return NULL
@@ -448,9 +448,15 @@ static jboolean Bitmap_hasAlpha(JNIEnv* env, jobject, SkBitmap* bitmap) {
     return !bitmap->isOpaque();
 }
 
-static void Bitmap_setHasAlpha(JNIEnv* env, jobject, SkBitmap* bitmap,
-                               jboolean hasAlpha) {
-    bitmap->setIsOpaque(!hasAlpha);
+static void Bitmap_setAlphaAndPremultiplied(JNIEnv* env, jobject, SkBitmap* bitmap,
+                                            jboolean hasAlpha, jboolean isPremul) {
+    if (!hasAlpha) {
+        bitmap->setAlphaType(kOpaque_SkAlphaType);
+    } else if (isPremul) {
+        bitmap->setAlphaType(kPremul_SkAlphaType);
+    } else {
+        bitmap->setAlphaType(kUnpremul_SkAlphaType);
+    }
 }
 
 static jboolean Bitmap_hasMipMap(JNIEnv* env, jobject, SkBitmap* bitmap) {
@@ -488,24 +494,33 @@ static jobject Bitmap_createFromParcel(JNIEnv* env, jobject, jobject parcel) {
         return NULL;
     }
 
-    SkBitmap* bitmap = new SkBitmap;
+    SkAutoTDelete<SkBitmap> bitmap(new SkBitmap);
 
-    bitmap->setConfig(config, width, height, rowBytes);
+    if (!bitmap->setConfig(config, width, height, rowBytes)) {
+        return NULL;
+    }
 
     SkColorTable* ctable = NULL;
     if (config == SkBitmap::kIndex8_Config) {
         int count = p->readInt32();
+        if (count < 0 || count > 256) {
+            // The data is corrupt, since SkColorTable enforces a value between 0 and 256,
+            // inclusive.
+            return NULL;
+        }
         if (count > 0) {
             size_t size = count * sizeof(SkPMColor);
             const SkPMColor* src = (const SkPMColor*)p->readInplace(size);
+            if (src == NULL) {
+                return NULL;
+            }
             ctable = new SkColorTable(src, count);
         }
     }
 
-    jbyteArray buffer = GraphicsJNI::allocateJavaPixelRef(env, bitmap, ctable);
+    jbyteArray buffer = GraphicsJNI::allocateJavaPixelRef(env, bitmap.get(), ctable);
     if (NULL == buffer) {
         SkSafeUnref(ctable);
-        delete bitmap;
         return NULL;
     }
 
@@ -517,7 +532,6 @@ static jobject Bitmap_createFromParcel(JNIEnv* env, jobject, jobject parcel) {
     android::status_t status = p->readBlob(size, &blob);
     if (status) {
         doThrowRE(env, "Could not read bitmap from parcel blob.");
-        delete bitmap;
         return NULL;
     }
 
@@ -527,8 +541,8 @@ static jobject Bitmap_createFromParcel(JNIEnv* env, jobject, jobject parcel) {
 
     blob.release();
 
-    return GraphicsJNI::createBitmap(env, bitmap, buffer, getPremulBitmapCreateFlags(isMutable),
-            NULL, NULL, density);
+    return GraphicsJNI::createBitmap(env, bitmap.detach(), buffer,
+            getPremulBitmapCreateFlags(isMutable), NULL, NULL, density);
 }
 
 static jboolean Bitmap_writeToParcel(JNIEnv* env, jobject,
@@ -549,14 +563,14 @@ static jboolean Bitmap_writeToParcel(JNIEnv* env, jobject,
     p->writeInt32(bitmap->rowBytes());
     p->writeInt32(density);
 
-    if (bitmap->getConfig() == SkBitmap::kIndex8_Config) {
+    if (bitmap->config() == SkBitmap::kIndex8_Config) {
         SkColorTable* ctable = bitmap->getColorTable();
         if (ctable != NULL) {
             int count = ctable->count();
             p->writeInt32(count);
             memcpy(p->writeInplace(count * sizeof(SkPMColor)),
                    ctable->lockColors(), count * sizeof(SkPMColor));
-            ctable->unlockColors(false);
+            ctable->unlockColors();
         } else {
             p->writeInt32(0);   // indicate no ctable
         }
@@ -776,7 +790,7 @@ static JNINativeMethod gBitmapMethods[] = {
     {   "nativeRowBytes",           "(I)I", (void*)Bitmap_rowBytes },
     {   "nativeConfig",             "(I)I", (void*)Bitmap_config },
     {   "nativeHasAlpha",           "(I)Z", (void*)Bitmap_hasAlpha },
-    {   "nativeSetHasAlpha",        "(IZ)V", (void*)Bitmap_setHasAlpha },
+    {   "nativeSetAlphaAndPremultiplied", "(IZZ)V", (void*)Bitmap_setAlphaAndPremultiplied},
     {   "nativeHasMipMap",          "(I)Z", (void*)Bitmap_hasMipMap },
     {   "nativeSetHasMipMap",       "(IZ)V", (void*)Bitmap_setHasMipMap },
     {   "nativeCreateFromParcel",
diff --git a/core/jni/android/graphics/BitmapFactory.cpp b/core/jni/android/graphics/BitmapFactory.cpp
index 5b0abb73..2cbe4f22 100644
--- a/core/jni/android/graphics/BitmapFactory.cpp
+++ b/core/jni/android/graphics/BitmapFactory.cpp
@@ -22,6 +22,7 @@
 #include <androidfw/Asset.h>
 #include <androidfw/ResourceTypes.h>
 #include <netinet/in.h>
+#include <stdio.h>
 #include <sys/mman.h>
 #include <sys/stat.h>
 
@@ -127,12 +128,18 @@ static void scaleNinePatchChunk(android::Res_png_9patch* chunk, float scale) {
 static SkPixelRef* installPixelRef(SkBitmap* bitmap, SkStreamRewindable* stream,
         int sampleSize, bool ditherImage) {
 
+    SkImageInfo bitmapInfo;
+    if (!bitmap->asImageInfo(&bitmapInfo)) {
+        ALOGW("bitmap has unknown configuration so no memory has been allocated");
+        return NULL;
+    }
+
     SkImageRef* pr;
     // only use ashmem for large images, since mmaps come at a price
     if (bitmap->getSize() >= 32 * 1024) {
-        pr = new SkImageRef_ashmem(stream, bitmap->config(), sampleSize);
+        pr = new SkImageRef_ashmem(bitmapInfo, stream, sampleSize);
     } else {
-        pr = new SkImageRef_GlobalPool(stream, bitmap->config(), sampleSize);
+        pr = new SkImageRef_GlobalPool(bitmapInfo, stream, sampleSize);
     }
     pr->setDitherImage(ditherImage);
     bitmap->setPixelRef(pr)->unref();
@@ -160,7 +167,7 @@ public:
     virtual bool allocPixelRef(SkBitmap* bitmap, SkColorTable* ctable) {
         // accounts for scale in final allocation, using eventual size and config
         const int bytesPerPixel = SkBitmap::ComputeBytesPerPixel(
-                configForScaledOutput(bitmap->getConfig()));
+                configForScaledOutput(bitmap->config()));
         const int requestedSize = bytesPerPixel *
                 int(bitmap->width() * mScale + 0.5f) *
                 int(bitmap->height() * mScale + 0.5f);
@@ -194,8 +201,15 @@ public:
             return false;
         }
 
+        SkImageInfo bitmapInfo;
+        if (!bitmap->asImageInfo(&bitmapInfo)) {
+            ALOGW("unable to reuse a bitmap as the target has an unknown bitmap configuration");
+            return false;
+        }
+
         // Create a new pixelref with the new ctable that wraps the previous pixelref
-        SkPixelRef* pr = new AndroidPixelRef(*static_cast<AndroidPixelRef*>(mPixelRef), ctable);
+        SkPixelRef* pr = new AndroidPixelRef(*static_cast<AndroidPixelRef*>(mPixelRef),
+                bitmapInfo, bitmap->rowBytes(), ctable);
 
         bitmap->setPixelRef(pr)->unref();
         // since we're already allocated, we lockPixels right away
@@ -404,8 +418,11 @@ static jobject doDecode(JNIEnv* env, SkStreamRewindable* stream, jobject padding
 
         // TODO: avoid copying when scaled size equals decodingBitmap size
         SkBitmap::Config config = configForScaledOutput(decodingBitmap.config());
-        outputBitmap->setConfig(config, scaledWidth, scaledHeight);
-        outputBitmap->setIsOpaque(decodingBitmap.isOpaque());
+        // FIXME: If the alphaType is kUnpremul and the image has alpha, the
+        // colors may not be correct, since Skia does not yet support drawing
+        // to/from unpremultiplied bitmaps.
+        outputBitmap->setConfig(config, scaledWidth, scaledHeight, 0,
+                                decodingBitmap.alphaType());
         if (!outputBitmap->allocPixels(outputAllocator, NULL)) {
             return nullObjectReturn("allocation failed for scaled bitmap");
         }
@@ -417,7 +434,7 @@ static jobject doDecode(JNIEnv* env, SkStreamRewindable* stream, jobject padding
         }
 
         SkPaint paint;
-        paint.setFilterBitmap(true);
+        paint.setFilterLevel(SkPaint::kLow_FilterLevel);
 
         SkCanvas canvas(*outputBitmap);
         canvas.scale(sx, sy);
@@ -473,6 +490,12 @@ static jobject doDecode(JNIEnv* env, SkStreamRewindable* stream, jobject padding
             bitmapCreateFlags, ninePatchChunk, layoutBounds, -1);
 }
 
+// Need to buffer enough input to be able to rewind as much as might be read by a decoder
+// trying to determine the stream's format. Currently the most is 64, read by
+// SkImageDecoder_libwebp.
+// FIXME: Get this number from SkImageDecoder
+#define BYTES_TO_BUFFER 64
+
 static jobject nativeDecodeStream(JNIEnv* env, jobject clazz, jobject is, jbyteArray storage,
         jobject padding, jobject options) {
 
@@ -480,11 +503,8 @@ static jobject nativeDecodeStream(JNIEnv* env, jobject clazz, jobject is, jbyteA
     SkAutoTUnref<SkStream> stream(CreateJavaInputStreamAdaptor(env, is, storage));
 
     if (stream.get()) {
-        // Need to buffer enough input to be able to rewind as much as might be read by a decoder
-        // trying to determine the stream's format. Currently the most is 64, read by
-        // SkImageDecoder_libwebp.
-        // FIXME: Get this number from SkImageDecoder
-        SkAutoTUnref<SkStreamRewindable> bufferedStream(SkFrontBufferedStream::Create(stream, 64));
+        SkAutoTUnref<SkStreamRewindable> bufferedStream(
+                SkFrontBufferedStream::Create(stream, BYTES_TO_BUFFER));
         SkASSERT(bufferedStream.get() != NULL);
         // for now we don't allow purgeable with java inputstreams
         bitmap = doDecode(env, bufferedStream, padding, options, false, false);
@@ -505,27 +525,49 @@ static jobject nativeDecodeFileDescriptor(JNIEnv* env, jobject clazz, jobject fi
         return nullObjectReturn("fstat return -1");
     }
 
-    bool isPurgeable = optionsPurgeable(env, bitmapFactoryOptions);
-    bool isShareable = optionsShareable(env, bitmapFactoryOptions);
-    bool weOwnTheFD = false;
-    if (isPurgeable && isShareable) {
-        int newFD = ::dup(descriptor);
-        if (-1 != newFD) {
-            weOwnTheFD = true;
-            descriptor = newFD;
-        }
+    // Restore the descriptor's offset on exiting this function.
+    AutoFDSeek autoRestore(descriptor);
+
+    descriptor = dup(descriptor);
+    FILE* file = fdopen(descriptor, "r");
+    if (file == NULL) {
+        return nullObjectReturn("Could not open file");
     }
 
-    SkAutoTUnref<SkData> data(SkData::NewFromFD(descriptor));
-    if (data.get() == NULL) {
-        return nullObjectReturn("NewFromFD failed in nativeDecodeFileDescriptor");
+    SkAutoTUnref<SkFILEStream> fileStream(new SkFILEStream(file,
+                         SkFILEStream::kCallerPasses_Ownership));
+
+    SkAutoTUnref<SkStreamRewindable> stream;
+
+    // Retain the old behavior of allowing purgeable if both purgeable and
+    // shareable are set to true.
+    bool isPurgeable = optionsPurgeable(env, bitmapFactoryOptions)
+                       && optionsShareable(env, bitmapFactoryOptions);
+    if (isPurgeable) {
+        // Copy the stream, so the image can be decoded multiple times without
+        // continuing to modify the original file descriptor.
+        // Copy beginning from the current position.
+        const size_t fileSize = fileStream->getLength() - fileStream->getPosition();
+        void* buffer = sk_malloc_flags(fileSize, 0);
+        if (buffer == NULL) {
+            return nullObjectReturn("Could not make a copy for ashmem");
+        }
+
+        SkAutoTUnref<SkData> data(SkData::NewFromMalloc(buffer, fileSize));
+
+        if (fileStream->read(buffer, fileSize) != fileSize) {
+            return nullObjectReturn("Could not read the file.");
+        }
+
+        stream.reset(new SkMemoryStream(data));
+    } else {
+        // Use a buffered stream. Although an SkFILEStream can be rewound, this
+        // ensures that SkImageDecoder::Factory never rewinds beyond the
+        // current position of the file descriptor.
+        stream.reset(SkFrontBufferedStream::Create(fileStream, BYTES_TO_BUFFER));
     }
-    SkAutoTUnref<SkMemoryStream> stream(new SkMemoryStream(data));
 
-    /* Allow purgeable iff we own the FD, i.e., in the puregeable and
-       shareable case.
-    */
-    return doDecode(env, stream, padding, bitmapFactoryOptions, weOwnTheFD);
+    return doDecode(env, stream, padding, bitmapFactoryOptions, isPurgeable);
 }
 
 static jobject nativeDecodeAsset(JNIEnv* env, jobject clazz, jint native_asset,
@@ -544,7 +586,9 @@ static jobject nativeDecodeAsset(JNIEnv* env, jobject clazz, jint native_asset,
     } else {
         // since we know we'll be done with the asset when we return, we can
         // just use a simple wrapper
-        stream = new AssetStreamAdaptor(asset);
+        stream = new AssetStreamAdaptor(asset,
+                                        AssetStreamAdaptor::kNo_OwnAsset,
+                                        AssetStreamAdaptor::kNo_HasMemoryBase);
     }
     SkAutoUnref aur(stream);
     return doDecode(env, stream, padding, options, forcePurgeable, forcePurgeable);
diff --git a/core/jni/android/graphics/BitmapRegionDecoder.cpp b/core/jni/android/graphics/BitmapRegionDecoder.cpp
index ee47ac46..1412a0e9 100644
--- a/core/jni/android/graphics/BitmapRegionDecoder.cpp
+++ b/core/jni/android/graphics/BitmapRegionDecoder.cpp
@@ -29,7 +29,6 @@
 #include "CreateJavaOutputStreamAdaptor.h"
 #include "Utils.h"
 #include "JNIHelp.h"
-#include "SkTScopedPtr.h"
 
 #include <android_runtime/AndroidRuntime.h>
 #include "android_util_Binder.h"
@@ -76,7 +75,7 @@ private:
     int fHeight;
 };
 
-static jobject createBitmapRegionDecoder(JNIEnv* env, SkStream* stream) {
+static jobject createBitmapRegionDecoder(JNIEnv* env, SkStreamRewindable* stream) {
     SkImageDecoder* decoder = SkImageDecoder::Factory(stream);
     int width, height;
     if (NULL == decoder) {
@@ -108,7 +107,7 @@ static jobject nativeNewInstanceFromByteArray(JNIEnv* env, jobject, jbyteArray b
         For now we just always copy the array's data if isShareable.
      */
     AutoJavaByteArray ar(env, byteArray);
-    SkStream* stream = new SkMemoryStream(ar.ptr() + offset, length, true);
+    SkStreamRewindable* stream = new SkMemoryStream(ar.ptr() + offset, length, true);
 
     jobject brd = createBitmapRegionDecoder(env, stream);
     SkSafeUnref(stream); // the decoder now holds a reference
@@ -215,7 +214,7 @@ static jobject nativeDecodeRegion(JNIEnv* env, jobject, SkBitmapRegionDecoder *b
     region.fRight = start_x + width;
     region.fBottom = start_y + height;
     SkBitmap* bitmap = NULL;
-    SkTScopedPtr<SkBitmap> adb;
+    SkAutoTDelete<SkBitmap> adb;
 
     if (tileBitmap != NULL) {
         // Re-use bitmap.
@@ -246,7 +245,7 @@ static jobject nativeDecodeRegion(JNIEnv* env, jobject, SkBitmapRegionDecoder *b
     }
 
     // detach bitmap from its autodeleter, since we want to own it now
-    adb.release();
+    adb.detach();
 
     JavaPixelAllocator* allocator = (JavaPixelAllocator*) decoder->getAllocator();
     jbyteArray buff = allocator->getStorageObjAndReset();
diff --git a/core/jni/android/graphics/Canvas.cpp b/core/jni/android/graphics/Canvas.cpp
index 813dd5af..edf3b4a0 100644
--- a/core/jni/android/graphics/Canvas.cpp
+++ b/core/jni/android/graphics/Canvas.cpp
@@ -476,7 +476,7 @@ public:
                 if (paint) {
                     filteredPaint = *paint;
                 }
-                filteredPaint.setFilterBitmap(true);
+                filteredPaint.setFilterLevel(SkPaint::kLow_FilterLevel);
                 canvas->drawBitmap(*bitmap, left_, top_, &filteredPaint);
             } else {
                 canvas->drawBitmap(*bitmap, left_, top_, paint);
@@ -491,7 +491,7 @@ public:
             if (paint) {
                 filteredPaint = *paint;
             }
-            filteredPaint.setFilterBitmap(true);
+            filteredPaint.setFilterLevel(SkPaint::kLow_FilterLevel);
 
             canvas->drawBitmap(*bitmap, 0, 0, &filteredPaint);
 
@@ -514,7 +514,7 @@ public:
             if (paint) {
                 filteredPaint = *paint;
             }
-            filteredPaint.setFilterBitmap(true);
+            filteredPaint.setFilterLevel(SkPaint::kLow_FilterLevel);
             canvas->drawBitmapRect(*bitmap, srcPtr, dst, &filteredPaint);
         } else {
             canvas->drawBitmapRect(*bitmap, srcPtr, dst, paint);
diff --git a/core/jni/android/graphics/Graphics.cpp b/core/jni/android/graphics/Graphics.cpp
index 8cb152db..3090ad2f 100644
--- a/core/jni/android/graphics/Graphics.cpp
+++ b/core/jni/android/graphics/Graphics.cpp
@@ -346,6 +346,18 @@ SkRegion* GraphicsJNI::getNativeRegion(JNIEnv* env, jobject region)
 
 ///////////////////////////////////////////////////////////////////////////////////////////
 
+// Assert that bitmap's SkAlphaType is consistent with isPremultiplied.
+static void assert_premultiplied(const SkBitmap& bitmap, bool isPremultiplied) {
+    // kOpaque_SkAlphaType and kIgnore_SkAlphaType mean that isPremultiplied is
+    // irrelevant. This just tests to ensure that the SkAlphaType is not
+    // opposite of isPremultiplied.
+    if (isPremultiplied) {
+        SkASSERT(bitmap.alphaType() != kUnpremul_SkAlphaType);
+    } else {
+        SkASSERT(bitmap.alphaType() != kPremul_SkAlphaType);
+    }
+}
+
 jobject GraphicsJNI::createBitmap(JNIEnv* env, SkBitmap* bitmap, jbyteArray buffer,
         int bitmapCreateFlags, jbyteArray ninepatch, jintArray layoutbounds, int density)
 {
@@ -354,6 +366,10 @@ jobject GraphicsJNI::createBitmap(JNIEnv* env, SkBitmap* bitmap, jbyteArray buff
     bool isMutable = bitmapCreateFlags & kBitmapCreateFlag_Mutable;
     bool isPremultiplied = bitmapCreateFlags & kBitmapCreateFlag_Premultiplied;
 
+    // The caller needs to have already set the alpha type properly, so the
+    // native SkBitmap stays in sync with the Java Bitmap.
+    assert_premultiplied(*bitmap, isPremultiplied);
+
     jobject obj = env->NewObject(gBitmap_class, gBitmap_constructorMethodID,
             static_cast<jint>(reinterpret_cast<uintptr_t>(bitmap)), buffer,
             bitmap->width(), bitmap->height(), density, isMutable, isPremultiplied,
@@ -371,6 +387,10 @@ jobject GraphicsJNI::createBitmap(JNIEnv* env, SkBitmap* bitmap, int bitmapCreat
 void GraphicsJNI::reinitBitmap(JNIEnv* env, jobject javaBitmap, SkBitmap* bitmap,
         bool isPremultiplied)
 {
+    // The caller needs to have already set the alpha type properly, so the
+    // native SkBitmap stays in sync with the Java Bitmap.
+    assert_premultiplied(*bitmap, isPremultiplied);
+
     env->CallVoidMethod(javaBitmap, gBitmap_reinitMethodID,
             bitmap->width(), bitmap->height(), isPremultiplied);
 }
@@ -413,8 +433,9 @@ static JNIEnv* vm2env(JavaVM* vm)
 
 ///////////////////////////////////////////////////////////////////////////////
 
-AndroidPixelRef::AndroidPixelRef(JNIEnv* env, void* storage, size_t size, jbyteArray storageObj,
-        SkColorTable* ctable) : SkMallocPixelRef(storage, size, ctable, (storageObj == NULL)),
+AndroidPixelRef::AndroidPixelRef(JNIEnv* env, const SkImageInfo& info, void* storage,
+        size_t rowBytes, jbyteArray storageObj, SkColorTable* ctable) :
+        SkMallocPixelRef(info, storage, rowBytes, ctable, (storageObj == NULL)),
         fWrappedPixelRef(NULL) {
     SkASSERT(storage);
     SkASSERT(env);
@@ -429,13 +450,13 @@ AndroidPixelRef::AndroidPixelRef(JNIEnv* env, void* storage, size_t size, jbyteA
 
     // If storageObj is NULL, the memory was NOT allocated on the Java heap
     fOnJavaHeap = (storageObj != NULL);
-
 }
 
-AndroidPixelRef::AndroidPixelRef(AndroidPixelRef& wrappedPixelRef, SkColorTable* ctable) :
-        SkMallocPixelRef(wrappedPixelRef.getAddr(), wrappedPixelRef.getSize(), ctable, false),
+AndroidPixelRef::AndroidPixelRef(AndroidPixelRef& wrappedPixelRef, const SkImageInfo& info,
+        size_t rowBytes, SkColorTable* ctable) :
+        SkMallocPixelRef(info, wrappedPixelRef.getAddr(), rowBytes, ctable, false),
         fWrappedPixelRef(wrappedPixelRef.fWrappedPixelRef ?
-            wrappedPixelRef.fWrappedPixelRef : &wrappedPixelRef)
+                wrappedPixelRef.fWrappedPixelRef : &wrappedPixelRef)
 {
     SkASSERT(fWrappedPixelRef);
     SkSafeRef(fWrappedPixelRef);
@@ -540,13 +561,21 @@ jbyteArray GraphicsJNI::allocateJavaPixelRef(JNIEnv* env, SkBitmap* bitmap,
         return NULL;
     }
 
+    SkImageInfo bitmapInfo;
+    if (!bitmap->asImageInfo(&bitmapInfo)) {
+        jniThrowException(env, "java/lang/IllegalArgumentException",
+                "unknown bitmap configuration");
+        return NULL;
+    }
+
     size_t size = size64.get32();
     jbyteArray arrayObj = env->NewByteArray(size);
     if (arrayObj) {
         // TODO: make this work without jniGetNonMovableArrayElements
         jbyte* addr = jniGetNonMovableArrayElements(&env->functions, arrayObj);
         if (addr) {
-            SkPixelRef* pr = new AndroidPixelRef(env, (void*) addr, size, arrayObj, ctable);
+            SkPixelRef* pr = new AndroidPixelRef(env, bitmapInfo, (void*) addr,
+                    bitmap->rowBytes(), arrayObj, ctable);
             bitmap->setPixelRef(pr)->unref();
             // since we're already allocated, we lockPixels right away
             // HeapAllocator behaves this way too
diff --git a/core/jni/android/graphics/GraphicsJNI.h b/core/jni/android/graphics/GraphicsJNI.h
index f4590b95..cb154aaf 100644
--- a/core/jni/android/graphics/GraphicsJNI.h
+++ b/core/jni/android/graphics/GraphicsJNI.h
@@ -57,6 +57,7 @@ public:
 
     /** Create a java Bitmap object given the native bitmap (required) and optional
         storage array (may be null).
+        bitmap's SkAlphaType must already be in sync with bitmapCreateFlags.
     */
     static jobject createBitmap(JNIEnv* env, SkBitmap* bitmap, jbyteArray buffer,
             int bitmapCreateFlags, jbyteArray ninepatch, jintArray layoutbounds, int density = -1);
@@ -64,6 +65,9 @@ public:
     static jobject createBitmap(JNIEnv* env, SkBitmap* bitmap, int bitmapCreateFlags,
             jbyteArray ninepatch, int density = -1);
 
+    /** Reinitialize a bitmap. bitmap must already have its SkAlphaType set in
+        sync with isPremultiplied
+    */
     static void reinitBitmap(JNIEnv* env, jobject javaBitmap, SkBitmap* bitmap,
             bool isPremultiplied);
 
@@ -88,15 +92,16 @@ public:
 
 class AndroidPixelRef : public SkMallocPixelRef {
 public:
-    AndroidPixelRef(JNIEnv* env, void* storage, size_t size, jbyteArray storageObj,
-                    SkColorTable* ctable);
+    AndroidPixelRef(JNIEnv* env, const SkImageInfo& info, void* storage, size_t rowBytes,
+            jbyteArray storageObj, SkColorTable* ctable);
 
     /**
      * Creates an AndroidPixelRef that wraps (and refs) another to reuse/share
      * the same storage and java byte array refcounting, yet have a different
      * color table.
      */
-    AndroidPixelRef(AndroidPixelRef& wrappedPixelRef, SkColorTable* ctable);
+    AndroidPixelRef(AndroidPixelRef& wrappedPixelRef, const SkImageInfo& info,
+            size_t rowBytes, SkColorTable* ctable);
 
     virtual ~AndroidPixelRef();
 
diff --git a/core/jni/android/graphics/Movie.cpp b/core/jni/android/graphics/Movie.cpp
index feb2decd..55be7c19 100644
--- a/core/jni/android/graphics/Movie.cpp
+++ b/core/jni/android/graphics/Movie.cpp
@@ -85,7 +85,9 @@ static void movie_draw(JNIEnv* env, jobject movie, jobject canvas,
 static jobject movie_decodeAsset(JNIEnv* env, jobject clazz, jint native_asset) {
     android::Asset* asset = reinterpret_cast<android::Asset*>(native_asset);
     if (asset == NULL) return NULL;
-    SkAutoTUnref<SkStreamRewindable> stream (new android::AssetStreamAdaptor(asset));
+    SkAutoTUnref<SkStreamRewindable> stream (new android::AssetStreamAdaptor(asset,
+            android::AssetStreamAdaptor::kNo_OwnAsset,
+            android::AssetStreamAdaptor::kNo_HasMemoryBase));
     SkMovie* moov = SkMovie::DecodeStream(stream.get());
     return create_jmovie(env, moov);
 }
diff --git a/core/jni/android/graphics/NinePatchPeeker.cpp b/core/jni/android/graphics/NinePatchPeeker.cpp
index df996afd..d3482da3 100644
--- a/core/jni/android/graphics/NinePatchPeeker.cpp
+++ b/core/jni/android/graphics/NinePatchPeeker.cpp
@@ -40,15 +40,14 @@ bool NinePatchPeeker::peek(const char tag[], const void* data, size_t length) {
         // now update our host to force index or 32bit config
         // 'cause we don't want 565 predithered, since as a 9patch, we know
         // we will be stretched, and therefore we want to dither afterwards.
-        static const SkBitmap::Config gNo565Pref[] = {
-            SkBitmap::kIndex8_Config,
-            SkBitmap::kIndex8_Config,
-            SkBitmap::kARGB_8888_Config,
-            SkBitmap::kARGB_8888_Config,
-            SkBitmap::kARGB_8888_Config,
-            SkBitmap::kARGB_8888_Config,
-        };
-        fHost->setPrefConfigTable(gNo565Pref);
+        SkImageDecoder::PrefConfigTable table;
+        table.fPrefFor_8Index_NoAlpha_src   = SkBitmap::kIndex8_Config;
+        table.fPrefFor_8Index_YesAlpha_src  = SkBitmap::kIndex8_Config;
+        table.fPrefFor_8Gray_src            = SkBitmap::kARGB_8888_Config;
+        table.fPrefFor_8bpc_NoAlpha_src     = SkBitmap::kARGB_8888_Config;
+        table.fPrefFor_8bpc_YesAlpha_src    = SkBitmap::kARGB_8888_Config;
+
+        fHost->setPrefConfigTable(table);
     } else if (strcmp("npLb", tag) == 0 && length == sizeof(int) * 4) {
         fLayoutBounds = new int[4];
         memcpy(fLayoutBounds, data, sizeof(int) * 4);
diff --git a/core/jni/android/graphics/Paint.cpp b/core/jni/android/graphics/Paint.cpp
index bf3ca545..446e2b3c 100644
--- a/core/jni/android/graphics/Paint.cpp
+++ b/core/jni/android/graphics/Paint.cpp
@@ -148,7 +148,8 @@ public:
 
     static void setFilterBitmap(JNIEnv* env, jobject paint, jboolean filterBitmap) {
         NPE_CHECK_RETURN_VOID(env, paint);
-        GraphicsJNI::getNativePaint(env, paint)->setFilterBitmap(filterBitmap);
+        GraphicsJNI::getNativePaint(env, paint)->setFilterLevel(
+                filterBitmap ? SkPaint::kLow_FilterLevel : SkPaint::kNone_FilterLevel);
     }
 
     static void setDither(JNIEnv* env, jobject paint, jboolean dither) {
@@ -565,7 +566,7 @@ public:
                 return 0;
             }
         }
-        jfloat *advancesArray = new jfloat[count];
+        jfloat* advancesArray = new jfloat[count];
         jfloat totalAdvance = 0;
 
         TextLayout::getTextRunAdvances(paint, text, start, count, contextCount, flags,
@@ -574,9 +575,7 @@ public:
         if (advances != NULL) {
             env->SetFloatArrayRegion(advances, advancesIndex, count, advancesArray);
         }
-
         delete [] advancesArray;
-
         return totalAdvance;
     }
 
diff --git a/core/jni/android/graphics/Region.cpp b/core/jni/android/graphics/Region.cpp
index ded21860..d901e9ce 100644
--- a/core/jni/android/graphics/Region.cpp
+++ b/core/jni/android/graphics/Region.cpp
@@ -175,9 +175,18 @@ static SkRegion* Region_createFromParcel(JNIEnv* env, jobject clazz, jobject par
 
     android::Parcel* p = android::parcelForJavaObject(env, parcel);
 
+    const size_t size = p->readInt32();
+    const void* regionData = p->readInplace(size);
+    if (regionData == NULL) {
+        return NULL;
+    }
     SkRegion* region = new SkRegion;
-    size_t size = p->readInt32();
-    region->readFromMemory(p->readInplace(size));
+    size_t actualSize = region->readFromMemory(regionData, size);
+
+    if (size != actualSize) {
+        delete region;
+        return NULL;
+    }
 
     return region;
 }
diff --git a/core/jni/android/graphics/TextLayoutCache.cpp b/core/jni/android/graphics/TextLayoutCache.cpp
index 92d253f0..144ac399 100644
--- a/core/jni/android/graphics/TextLayoutCache.cpp
+++ b/core/jni/android/graphics/TextLayoutCache.cpp
@@ -20,6 +20,7 @@
 
 #include "TextLayoutCache.h"
 #include "TextLayout.h"
+#include "SkGlyphCache.h"
 #include "SkTypeface_android.h"
 #include "HarfBuzzNGFaceSkia.h"
 #include <unicode/unistr.h>
@@ -757,8 +758,8 @@ void TextLayoutShaper::computeRunValues(const SkPaint* paint, const UChar* conte
             outPos->add(ypos);
             totalAdvance += xAdvance;
 
-            // TODO: consider using glyph cache
-            const SkGlyph& metrics = mShapingPaint.getGlyphMetrics(glyphId, NULL);
+            SkAutoGlyphCache autoCache(mShapingPaint, NULL, NULL);
+            const SkGlyph& metrics = autoCache.getCache()->getGlyphIDMetrics(glyphId);
             outBounds->join(xpos + metrics.fLeft, ypos + metrics.fTop,
                     xpos + metrics.fLeft + metrics.fWidth, ypos + metrics.fTop + metrics.fHeight);
 
diff --git a/core/jni/android/graphics/Typeface.cpp b/core/jni/android/graphics/Typeface.cpp
index 631845a2..3eaaabad 100644
--- a/core/jni/android/graphics/Typeface.cpp
+++ b/core/jni/android/graphics/Typeface.cpp
@@ -4,6 +4,7 @@
 #include "GraphicsJNI.h"
 #include "SkStream.h"
 #include "SkTypeface.h"
+#include "Utils.h"
 #include <android_runtime/android_util_AssetManager.h>
 #include <androidfw/AssetManager.h>
 
@@ -77,65 +78,6 @@ static int Typeface_getStyle(JNIEnv* env, jobject obj, SkTypeface* face) {
     return face->style();
 }
 
-class AssetStream : public SkStream {
-public:
-    AssetStream(Asset* asset, bool hasMemoryBase) : fAsset(asset)
-    {
-        fMemoryBase = hasMemoryBase ? fAsset->getBuffer(false) : NULL;
-    }
-
-    virtual ~AssetStream()
-    {
-        delete fAsset;
-    }
-
-    virtual const void* getMemoryBase()
-    {
-        return fMemoryBase;
-    }
-
-	virtual bool rewind()
-    {
-        off64_t pos = fAsset->seek(0, SEEK_SET);
-        return pos != (off64_t)-1;
-    }
-
-	virtual size_t read(void* buffer, size_t size)
-    {
-        ssize_t amount;
-
-        if (NULL == buffer)
-        {
-            if (0 == size)  // caller is asking us for our total length
-                return fAsset->getLength();
-
-            // asset->seek returns new total offset
-            // we want to return amount that was skipped
-
-            off64_t oldOffset = fAsset->seek(0, SEEK_CUR);
-            if (-1 == oldOffset)
-                return 0;
-            off64_t newOffset = fAsset->seek(size, SEEK_CUR);
-            if (-1 == newOffset)
-                return 0;
-
-            amount = newOffset - oldOffset;
-        }
-        else
-        {
-            amount = fAsset->read(buffer, size);
-        }
-
-        if (amount < 0)
-            amount = 0;
-        return amount;
-    }
-
-private:
-    Asset*      fAsset;
-    const void* fMemoryBase;
-};
-
 static SkTypeface* Typeface_createFromAsset(JNIEnv* env, jobject,
                                             jobject jassetMgr,
                                             jstring jpath) {
@@ -154,7 +96,9 @@ static SkTypeface* Typeface_createFromAsset(JNIEnv* env, jobject,
         return NULL;
     }
 
-    SkStream* stream = new AssetStream(asset, true);
+    SkStream* stream = new AssetStreamAdaptor(asset,
+                                              AssetStreamAdaptor::kYes_OwnAsset,
+                                              AssetStreamAdaptor::kYes_HasMemoryBase);
     SkTypeface* face = SkTypeface::CreateFromStream(stream);
     // SkTypeFace::CreateFromStream calls ref() on the stream, so we
     // need to unref it here or it won't be freed later on
diff --git a/core/jni/android/graphics/Utils.cpp b/core/jni/android/graphics/Utils.cpp
index b7d1f3ab..eb416cbe 100644
--- a/core/jni/android/graphics/Utils.cpp
+++ b/core/jni/android/graphics/Utils.cpp
@@ -19,6 +19,21 @@
 
 using namespace android;
 
+AssetStreamAdaptor::AssetStreamAdaptor(Asset* asset, OwnAsset ownAsset,
+                                       HasMemoryBase hasMemoryBase)
+    : fAsset(asset)
+    , fMemoryBase(kYes_HasMemoryBase == hasMemoryBase ?
+                  asset->getBuffer(false) : NULL)
+    , fOwnAsset(ownAsset)
+{
+}
+
+AssetStreamAdaptor::~AssetStreamAdaptor() {
+    if (kYes_OwnAsset == fOwnAsset) {
+        delete fAsset;
+    }
+}
+
 bool AssetStreamAdaptor::rewind() {
     off64_t pos = fAsset->seek(0, SEEK_SET);
     if (pos == (off64_t)-1) {
diff --git a/core/jni/android/graphics/Utils.h b/core/jni/android/graphics/Utils.h
index a1ac72a0..b90593cd 100644
--- a/core/jni/android/graphics/Utils.h
+++ b/core/jni/android/graphics/Utils.h
@@ -28,16 +28,36 @@ namespace android {
 
 class AssetStreamAdaptor : public SkStreamRewindable {
 public:
-    AssetStreamAdaptor(Asset* a) : fAsset(a) {}
+    // Enum passed to constructor. If set to kYes_OwnAsset,
+    // the passed in Asset will be deleted upon destruction.
+    enum OwnAsset {
+        kYes_OwnAsset,
+        kNo_OwnAsset,
+    };
+
+    // Enum passed to constructor. If set to kYes_HasMemoryBase,
+    // getMemoryBase will return the Asset's buffer.
+    enum HasMemoryBase {
+        kYes_HasMemoryBase,
+        kNo_HasMemoryBase,
+    };
+
+    AssetStreamAdaptor(Asset*, OwnAsset, HasMemoryBase);
+    ~AssetStreamAdaptor();
+
     virtual bool rewind();
     virtual size_t read(void* buffer, size_t size);
     virtual bool hasLength() const { return true; }
     virtual size_t getLength() const;
     virtual bool isAtEnd() const;
 
+    virtual const void* getMemoryBase() { return fMemoryBase; }
+
     virtual SkStreamRewindable* duplicate() const;
 private:
-    Asset*  fAsset;
+    Asset*              fAsset;
+    const void* const   fMemoryBase;
+    const OwnAsset      fOwnAsset;
 };
 
 /**
diff --git a/core/jni/android/opengl/util.cpp b/core/jni/android/opengl/util.cpp
index 44af1993..4bb091d1 100644
--- a/core/jni/android/opengl/util.cpp
+++ b/core/jni/android/opengl/util.cpp
@@ -632,7 +632,7 @@ static jint util_getInternalFormat(JNIEnv *env, jclass clazz,
     SkBitmap const * nativeBitmap =
             (SkBitmap const *)env->GetIntField(jbitmap, nativeBitmapID);
     const SkBitmap& bitmap(*nativeBitmap);
-    SkBitmap::Config config = bitmap.getConfig();
+    SkBitmap::Config config = bitmap.config();
     return getInternalFormat(config);
 }
 
@@ -642,7 +642,7 @@ static jint util_getType(JNIEnv *env, jclass clazz,
     SkBitmap const * nativeBitmap =
             (SkBitmap const *)env->GetIntField(jbitmap, nativeBitmapID);
     const SkBitmap& bitmap(*nativeBitmap);
-    SkBitmap::Config config = bitmap.getConfig();
+    SkBitmap::Config config = bitmap.config();
     return getType(config);
 }
 
@@ -653,7 +653,7 @@ static jint util_texImage2D(JNIEnv *env, jclass clazz,
     SkBitmap const * nativeBitmap =
             (SkBitmap const *)env->GetIntField(jbitmap, nativeBitmapID);
     const SkBitmap& bitmap(*nativeBitmap);
-    SkBitmap::Config config = bitmap.getConfig();
+    SkBitmap::Config config = bitmap.config();
     if (internalformat < 0) {
         internalformat = getInternalFormat(config);
     }
@@ -681,7 +681,7 @@ static jint util_texImage2D(JNIEnv *env, jclass clazz,
             SkColorTable* ctable = bitmap.getColorTable();
             memcpy(data, ctable->lockColors(), ctable->count() * sizeof(SkPMColor));
             memcpy(pixels, p, size);
-            ctable->unlockColors(false);
+            ctable->unlockColors();
             glCompressedTexImage2D(target, level, internalformat, w, h, border, imageSize, data);
             free(data);
         } else {
@@ -702,7 +702,7 @@ static jint util_texSubImage2D(JNIEnv *env, jclass clazz,
     SkBitmap const * nativeBitmap =
             (SkBitmap const *)env->GetIntField(jbitmap, nativeBitmapID);
     const SkBitmap& bitmap(*nativeBitmap);
-    SkBitmap::Config config = bitmap.getConfig();
+    SkBitmap::Config config = bitmap.config();
     if (format < 0) {
         format = getInternalFormat(config);
         if (format == GL_PALETTE8_RGBA8_OES)
diff --git a/core/jni/android_view_Surface.cpp b/core/jni/android_view_Surface.cpp
index 1173d742..4cdd6128 100644
--- a/core/jni/android_view_Surface.cpp
+++ b/core/jni/android_view_Surface.cpp
@@ -39,6 +39,7 @@
 
 #include <SkCanvas.h>
 #include <SkBitmap.h>
+#include <SkImage.h>
 #include <SkRegion.h>
 
 #include <utils/misc.h>
@@ -178,7 +179,8 @@ static jboolean nativeIsConsumerRunningBehind(JNIEnv* env, jclass clazz, jint na
 static inline SkBitmap::Config convertPixelFormat(PixelFormat format) {
     /* note: if PIXEL_FORMAT_RGBX_8888 means that all alpha bytes are 0xFF, then
         we can map to SkBitmap::kARGB_8888_Config, and optionally call
-        bitmap.setIsOpaque(true) on the resulting SkBitmap (as an accelerator)
+        bitmap.setAlphaType(kOpaque_SkAlphaType) on the resulting SkBitmap
+        (as an accelerator)
     */
     switch (format) {
     case PIXEL_FORMAT_RGBX_8888:    return SkBitmap::kARGB_8888_Config;
@@ -255,7 +257,7 @@ static jint nativeLockCanvas(JNIEnv* env, jclass clazz,
     ssize_t bpr = outBuffer.stride * bytesPerPixel(outBuffer.format);
     bitmap.setConfig(convertPixelFormat(outBuffer.format), outBuffer.width, outBuffer.height, bpr);
     if (outBuffer.format == PIXEL_FORMAT_RGBX_8888) {
-        bitmap.setIsOpaque(true);
+        bitmap.setAlphaType(kOpaque_SkAlphaType);
     }
     if (outBuffer.width > 0 && outBuffer.height > 0) {
         bitmap.setPixels(outBuffer.bits);
diff --git a/core/jni/android_view_SurfaceControl.cpp b/core/jni/android_view_SurfaceControl.cpp
index 67eade83..b8d3c20f 100644
--- a/core/jni/android_view_SurfaceControl.cpp
+++ b/core/jni/android_view_SurfaceControl.cpp
@@ -61,51 +61,21 @@ static struct {
 
 class ScreenshotPixelRef : public SkPixelRef {
 public:
-    ScreenshotPixelRef(SkColorTable* ctable) {
-        fCTable = ctable;
-        SkSafeRef(ctable);
+    ScreenshotPixelRef(const SkImageInfo& info, ScreenshotClient* screenshot) :
+      SkPixelRef(info),
+      mScreenshot(screenshot) {
         setImmutable();
     }
 
     virtual ~ScreenshotPixelRef() {
-        SkSafeUnref(fCTable);
-    }
-
-    status_t update(const sp<IBinder>& display, int width, int height,
-            int minLayer, int maxLayer, bool allLayers) {
-        status_t res = (width > 0 && height > 0)
-                ? (allLayers
-                        ? mScreenshot.update(display, width, height)
-                        : mScreenshot.update(display, width, height, minLayer, maxLayer))
-                : mScreenshot.update(display);
-        if (res != NO_ERROR) {
-            return res;
-        }
-
-        return NO_ERROR;
-    }
-
-    uint32_t getWidth() const {
-        return mScreenshot.getWidth();
-    }
-
-    uint32_t getHeight() const {
-        return mScreenshot.getHeight();
-    }
-
-    uint32_t getStride() const {
-        return mScreenshot.getStride();
-    }
-
-    uint32_t getFormat() const {
-        return mScreenshot.getFormat();
+        delete mScreenshot;
     }
 
 protected:
     // overrides from SkPixelRef
     virtual void* onLockPixels(SkColorTable** ct) {
-        *ct = fCTable;
-        return (void*)mScreenshot.getPixels();
+        *ct = NULL;
+        return (void*)mScreenshot->getPixels();
     }
 
     virtual void onUnlockPixels() {
@@ -113,8 +83,7 @@ protected:
 
     SK_DECLARE_UNFLATTENABLE_OBJECT()
 private:
-    ScreenshotClient mScreenshot;
-    SkColorTable*    fCTable;
+    ScreenshotClient* mScreenshot;
 
     typedef SkPixelRef INHERITED;
 };
@@ -147,19 +116,6 @@ static void nativeDestroy(JNIEnv* env, jclass clazz, jint nativeObject) {
     ctrl->decStrong((void *)nativeCreate);
 }
 
-static inline SkBitmap::Config convertPixelFormat(PixelFormat format) {
-    /* note: if PIXEL_FORMAT_RGBX_8888 means that all alpha bytes are 0xFF, then
-        we can map to SkBitmap::kARGB_8888_Config, and optionally call
-        bitmap.setIsOpaque(true) on the resulting SkBitmap (as an accelerator)
-    */
-    switch (format) {
-    case PIXEL_FORMAT_RGBX_8888:    return SkBitmap::kARGB_8888_Config;
-    case PIXEL_FORMAT_RGBA_8888:    return SkBitmap::kARGB_8888_Config;
-    case PIXEL_FORMAT_RGB_565:      return SkBitmap::kRGB_565_Config;
-    default:                        return SkBitmap::kNo_Config;
-    }
-}
-
 static jobject nativeScreenshotBitmap(JNIEnv* env, jclass clazz, jobject displayTokenObj,
         jint width, jint height, jint minLayer, jint maxLayer, bool allLayers) {
     sp<IBinder> displayToken = ibinderForJavaObject(env, displayTokenObj);
@@ -167,26 +123,50 @@ static jobject nativeScreenshotBitmap(JNIEnv* env, jclass clazz, jobject display
         return NULL;
     }
 
-    ScreenshotPixelRef* pixels = new ScreenshotPixelRef(NULL);
-    if (pixels->update(displayToken, width, height,
-            minLayer, maxLayer, allLayers) != NO_ERROR) {
-        delete pixels;
+    ScreenshotClient* screenshot = new ScreenshotClient();
+    status_t res = (width > 0 && height > 0)
+            ? (allLayers
+                    ? screenshot->update(displayToken, width, height)
+                    : screenshot->update(displayToken, width, height, minLayer, maxLayer))
+            : screenshot->update(displayToken);
+    if (res != NO_ERROR) {
+        delete screenshot;
         return NULL;
     }
 
-    uint32_t w = pixels->getWidth();
-    uint32_t h = pixels->getHeight();
-    uint32_t s = pixels->getStride();
-    uint32_t f = pixels->getFormat();
-    ssize_t bpr = s * android::bytesPerPixel(f);
+    SkImageInfo screenshotInfo;
+    screenshotInfo.fWidth = screenshot->getWidth();
+    screenshotInfo.fHeight = screenshot->getHeight();
 
-    SkBitmap* bitmap = new SkBitmap();
-    bitmap->setConfig(convertPixelFormat(f), w, h, bpr);
-    if (f == PIXEL_FORMAT_RGBX_8888) {
-        bitmap->setIsOpaque(true);
+    switch (screenshot->getFormat()) {
+        case PIXEL_FORMAT_RGBX_8888: {
+            screenshotInfo.fColorType = kRGBA_8888_SkColorType;
+            screenshotInfo.fAlphaType = kIgnore_SkAlphaType;
+            break;
+        }
+        case PIXEL_FORMAT_RGBA_8888: {
+            screenshotInfo.fColorType = kRGBA_8888_SkColorType;
+            screenshotInfo.fAlphaType = kPremul_SkAlphaType;
+            break;
+        }
+        case PIXEL_FORMAT_RGB_565: {
+            screenshotInfo.fColorType = kRGB_565_SkColorType;
+            screenshotInfo.fAlphaType = kIgnore_SkAlphaType;
+            break;
+        }
+        default: {
+            delete screenshot;
+            return NULL;
+        }
     }
 
-    if (w > 0 && h > 0) {
+    // takes ownership of ScreenshotClient
+    ScreenshotPixelRef* pixels = new ScreenshotPixelRef(screenshotInfo, screenshot);
+    ssize_t rowBytes = screenshot->getStride() * android::bytesPerPixel(screenshot->getFormat());
+
+    SkBitmap* bitmap = new SkBitmap();
+    bitmap->setConfig(screenshotInfo, rowBytes);
+    if (screenshotInfo.fWidth > 0 && screenshotInfo.fHeight > 0) {
         bitmap->setPixelRef(pixels)->unref();
         bitmap->lockPixels();
     } else {
diff --git a/core/jni/android_view_TextureView.cpp b/core/jni/android_view_TextureView.cpp
index 0f429005..7a4a20a9 100644
--- a/core/jni/android_view_TextureView.cpp
+++ b/core/jni/android_view_TextureView.cpp
@@ -27,6 +27,7 @@
 
 #include <SkBitmap.h>
 #include <SkCanvas.h>
+#include <SkImage.h>
 
 namespace android {
 
@@ -156,7 +157,7 @@ static jboolean android_view_TextureView_lockCanvas(JNIEnv* env, jobject,
     bitmap.setConfig(convertPixelFormat(buffer.format), buffer.width, buffer.height, bytesCount);
 
     if (buffer.format == WINDOW_FORMAT_RGBX_8888) {
-        bitmap.setIsOpaque(true);
+        bitmap.setAlphaType(kOpaque_SkAlphaType);
     }
 
     if (buffer.width > 0 && buffer.height > 0) {
diff --git a/data/etc/Android.mk b/data/etc/Android.mk
index 134ac0ca..7c255bd4 100644
--- a/data/etc/Android.mk
+++ b/data/etc/Android.mk
@@ -32,16 +32,16 @@ LOCAL_SRC_FILES := $(LOCAL_MODULE)
 include $(BUILD_PREBUILT)
 
 ########################
-#include $(CLEAR_VARS)
+include $(CLEAR_VARS)
 
-#LOCAL_MODULE := required_hardware.xml
+LOCAL_MODULE := android.hardware.usb.host.xml
 
-#LOCAL_MODULE_CLASS := ETC
+LOCAL_MODULE_CLASS := ETC
 
 # This will install the file in /system/etc/permissions
 #
-#LOCAL_MODULE_PATH := $(TARGET_OUT_ETC)/permissions
+LOCAL_MODULE_PATH := $(TARGET_OUT_ETC)/permissions
 
-#LOCAL_SRC_FILES := $(LOCAL_MODULE)
+LOCAL_SRC_FILES := $(LOCAL_MODULE)
 
-#include $(BUILD_PREBUILT)
+include $(BUILD_PREBUILT)
diff --git a/data/etc/platform.xml b/data/etc/platform.xml
old mode 100644
new mode 100755
index d857366f..92f9163b
--- a/data/etc/platform.xml
+++ b/data/etc/platform.xml
@@ -64,6 +64,7 @@
 
     <permission name="android.permission.READ_EXTERNAL_STORAGE" >
         <group gid="sdcard_r" />
+        <group gid="media_rw" />
     </permission>
 
     <permission name="android.permission.WRITE_EXTERNAL_STORAGE" >
diff --git a/graphics/java/android/graphics/Bitmap.java b/graphics/java/android/graphics/Bitmap.java
index 8c38d25d..74838ee2 100644
--- a/graphics/java/android/graphics/Bitmap.java
+++ b/graphics/java/android/graphics/Bitmap.java
@@ -67,6 +67,7 @@ public final class Bitmap implements Parcelable {
      * setPremultiplied() aren't order dependent, despite being setters.
      */
     private boolean mIsPremultiplied;
+
     private byte[] mNinePatchChunk;   // may be null
     private int[] mLayoutBounds;   // may be null
     private int mWidth;
@@ -390,7 +391,7 @@ public final class Bitmap implements Parcelable {
          * No color information is stored.
          * With this configuration, each pixel requires 1 byte of memory.
          */
-        ALPHA_8     (2),
+        ALPHA_8     (1),
 
         /**
          * Each pixel is stored on 2 bytes and only the RGB channels are
@@ -406,7 +407,7 @@ public final class Bitmap implements Parcelable {
          * This configuration may be useful when using opaque bitmaps
          * that do not require high color fidelity.
          */
-        RGB_565     (4),
+        RGB_565     (3),
 
         /**
          * Each pixel is stored on 2 bytes. The three RGB color channels
@@ -428,7 +429,7 @@ public final class Bitmap implements Parcelable {
          *             it is advised to use {@link #ARGB_8888} instead.
          */
         @Deprecated
-        ARGB_4444   (5),
+        ARGB_4444   (4),
 
         /**
          * Each pixel is stored on 4 bytes. Each channel (RGB and alpha
@@ -438,13 +439,13 @@ public final class Bitmap implements Parcelable {
          * This configuration is very flexible and offers the best
          * quality. It should be used whenever possible.
          */
-        ARGB_8888   (6);
+        ARGB_8888   (5);
 
         final int nativeInt;
 
         @SuppressWarnings({"deprecation"})
         private static Config sConfigs[] = {
-            null, null, ALPHA_8, null, RGB_565, ARGB_4444, ARGB_8888
+            null, ALPHA_8, null, RGB_565, ARGB_4444, ARGB_8888
         };
         
         Config(int ni) {
@@ -554,7 +555,7 @@ public final class Bitmap implements Parcelable {
         checkRecycled("Can't copy a recycled bitmap");
         Bitmap b = nativeCopy(mNativeBitmap, config.nativeInt, isMutable);
         if (b != null) {
-            b.mIsPremultiplied = mIsPremultiplied;
+            b.setAlphaAndPremultiplied(hasAlpha(), mIsPremultiplied);
             b.mDensity = mDensity;
         }
         return b;
@@ -727,12 +728,12 @@ public final class Bitmap implements Parcelable {
                 paint.setAntiAlias(true);
             }
         }
-        
+
         // The new bitmap was created from a known bitmap source so assume that
         // they use the same density
         bitmap.mDensity = source.mDensity;
-        bitmap.mIsPremultiplied = source.mIsPremultiplied;
-        
+        bitmap.setAlphaAndPremultiplied(source.hasAlpha(), source.mIsPremultiplied);
+
         canvas.setBitmap(bitmap);
         canvas.drawBitmap(source, srcR, dstR, paint);
         canvas.setBitmap(null);
@@ -810,9 +811,9 @@ public final class Bitmap implements Parcelable {
         if (display != null) {
             bm.mDensity = display.densityDpi;
         }
+        bm.setHasAlpha(hasAlpha);
         if (config == Config.ARGB_8888 && !hasAlpha) {
             nativeErase(bm.mNativeBitmap, 0xff000000);
-            nativeSetHasAlpha(bm.mNativeBitmap, hasAlpha);
         }
         // No need to initialize the bitmap to zeroes with other configs;
         // it is backed by a VM byte array which is by definition preinitialized
@@ -1041,11 +1042,23 @@ public final class Bitmap implements Parcelable {
      * <p>This method will not affect the behavior of a bitmap without an alpha
      * channel, or if {@link #hasAlpha()} returns false.</p>
      *
+     * <p>Calling createBitmap() or createScaledBitmap() with a source
+     * Bitmap whose colors are not pre-multiplied may result in a RuntimeException,
+     * since those functions require drawing the source, which is not supported for
+     * un-pre-multiplied Bitmaps.</p>
+     *
      * @see Bitmap#isPremultiplied()
      * @see BitmapFactory.Options#inPremultiplied
      */
     public final void setPremultiplied(boolean premultiplied) {
         mIsPremultiplied = premultiplied;
+        nativeSetAlphaAndPremultiplied(mNativeBitmap, hasAlpha(), premultiplied);
+    }
+
+    /** Helper function to set both alpha and premultiplied. **/
+    private final void setAlphaAndPremultiplied(boolean hasAlpha, boolean premultiplied) {
+        mIsPremultiplied = premultiplied;
+        nativeSetAlphaAndPremultiplied(mNativeBitmap, hasAlpha, premultiplied);
     }
 
     /** Returns the bitmap's width */
@@ -1206,7 +1219,7 @@ public final class Bitmap implements Parcelable {
      * non-opaque per-pixel alpha values.
      */
     public void setHasAlpha(boolean hasAlpha) {
-        nativeSetHasAlpha(mNativeBitmap, hasAlpha);
+        nativeSetAlphaAndPremultiplied(mNativeBitmap, hasAlpha, mIsPremultiplied);
     }
 
     /**
@@ -1611,7 +1624,8 @@ public final class Bitmap implements Parcelable {
 
     private static native void nativePrepareToDraw(int nativeBitmap);
     private static native boolean nativeHasAlpha(int nativeBitmap);
-    private static native void nativeSetHasAlpha(int nBitmap, boolean hasAlpha);
+    private static native void nativeSetAlphaAndPremultiplied(int nBitmap, boolean hasAlpha,
+                                                              boolean isPremul);
     private static native boolean nativeHasMipMap(int nativeBitmap);
     private static native void nativeSetHasMipMap(int nBitmap, boolean hasMipMap);
     private static native boolean nativeSameAs(int nb0, int nb1);
diff --git a/graphics/java/android/graphics/BitmapFactory.java b/graphics/java/android/graphics/BitmapFactory.java
index b08ce097..9b07da98 100644
--- a/graphics/java/android/graphics/BitmapFactory.java
+++ b/graphics/java/android/graphics/BitmapFactory.java
@@ -153,8 +153,12 @@ public class BitmapFactory {
          *
          * <p>This does not affect bitmaps without an alpha channel.</p>
          *
+         * <p>Setting this flag to false while setting {@link #inScaled} to true
+         * may result in incorrect colors.</p>
+         *
          * @see Bitmap#hasAlpha()
          * @see Bitmap#isPremultiplied()
+         * @see #inScaled
          */
         public boolean inPremultiplied;
 
@@ -249,6 +253,9 @@ public class BitmapFactory {
          * <p>This flag is turned on by default and should be turned off if you need
          * a non-scaled version of the bitmap.  Nine-patch bitmaps ignore this
          * flag and are always scaled.
+         *
+         * <p>If {@link #inPremultiplied} is set to false, and the image has alpha,
+         * setting this flag to true may result in incorrect colors.
          */
         public boolean inScaled;
 
diff --git a/libs/hwui/TextureCache.cpp b/libs/hwui/TextureCache.cpp
index ad235a94..c6e0c2e0 100644
--- a/libs/hwui/TextureCache.cpp
+++ b/libs/hwui/TextureCache.cpp
@@ -321,3 +321,4 @@ void TextureCache::uploadToTexture(bool resize, GLenum format, GLsizei stride,
 
 }; // namespace uirenderer
 }; // namespace android
+
diff --git a/libs/hwui/font/Font.cpp b/libs/hwui/font/Font.cpp
index eb33cf1f..b1157568 100644
--- a/libs/hwui/font/Font.cpp
+++ b/libs/hwui/font/Font.cpp
@@ -23,6 +23,7 @@
 #include <utils/Trace.h>
 
 #include <SkGlyph.h>
+#include <SkGlyphCache.h>
 #include <SkUtils.h>
 
 #include "FontUtil.h"
@@ -282,9 +283,9 @@ CachedGlyphInfo* Font::getCachedGlyph(SkPaint* paint, glyph_t textUnit, bool pre
     if (cachedGlyph) {
         // Is the glyph still in texture cache?
         if (!cachedGlyph->mIsValid) {
-            const SkGlyph& skiaGlyph = GET_METRICS(paint, textUnit,
-                    &mDescription.mLookupTransform);
-            updateGlyphCache(paint, skiaGlyph, cachedGlyph, precaching);
+            SkAutoGlyphCache autoCache(*paint, NULL, &mDescription.mLookupTransform);
+            const SkGlyph& skiaGlyph = GET_METRICS(autoCache.getCache(), textUnit);
+            updateGlyphCache(paint, skiaGlyph, autoCache.getCache(), cachedGlyph, precaching);
         }
     } else {
         cachedGlyph = cacheGlyph(paint, textUnit, precaching);
@@ -426,8 +427,8 @@ void Font::render(SkPaint* paint, const char* text, uint32_t start, uint32_t len
     }
 }
 
-void Font::updateGlyphCache(SkPaint* paint, const SkGlyph& skiaGlyph, CachedGlyphInfo* glyph,
-        bool precaching) {
+void Font::updateGlyphCache(SkPaint* paint, const SkGlyph& skiaGlyph, SkGlyphCache* skiaGlyphCache,
+        CachedGlyphInfo* glyph, bool precaching) {
     glyph->mAdvanceX = skiaGlyph.fAdvanceX;
     glyph->mAdvanceY = skiaGlyph.fAdvanceY;
     glyph->mBitmapLeft = skiaGlyph.fLeft;
@@ -440,7 +441,7 @@ void Font::updateGlyphCache(SkPaint* paint, const SkGlyph& skiaGlyph, CachedGlyp
 
     // Get the bitmap for the glyph
     if (!skiaGlyph.fImage) {
-        paint->findImage(skiaGlyph, &mDescription.mLookupTransform);
+        skiaGlyphCache->findImage(skiaGlyph);
     }
     mState->cacheBitmap(skiaGlyph, glyph, &startX, &startY, precaching);
 
@@ -474,11 +475,12 @@ CachedGlyphInfo* Font::cacheGlyph(SkPaint* paint, glyph_t glyph, bool precaching
     CachedGlyphInfo* newGlyph = new CachedGlyphInfo();
     mCachedGlyphs.add(glyph, newGlyph);
 
-    const SkGlyph& skiaGlyph = GET_METRICS(paint, glyph, &mDescription.mLookupTransform);
+    SkAutoGlyphCache autoCache(*paint, NULL, &mDescription.mLookupTransform);
+    const SkGlyph& skiaGlyph = GET_METRICS(autoCache.getCache(), glyph);
     newGlyph->mIsValid = false;
     newGlyph->mGlyphIndex = skiaGlyph.fID;
 
-    updateGlyphCache(paint, skiaGlyph, newGlyph, precaching);
+    updateGlyphCache(paint, skiaGlyph, autoCache.getCache(), newGlyph, precaching);
 
     return newGlyph;
 }
diff --git a/libs/hwui/font/Font.h b/libs/hwui/font/Font.h
index 9e7ec2dc..f68b4308 100644
--- a/libs/hwui/font/Font.h
+++ b/libs/hwui/font/Font.h
@@ -19,6 +19,7 @@
 
 #include <utils/KeyedVector.h>
 
+#include <SkGlyphCache.h>
 #include <SkScalerContext.h>
 #include <SkPaint.h>
 #include <SkPathMeasure.h>
@@ -117,8 +118,8 @@ private:
     void invalidateTextureCache(CacheTexture* cacheTexture = NULL);
 
     CachedGlyphInfo* cacheGlyph(SkPaint* paint, glyph_t glyph, bool precaching);
-    void updateGlyphCache(SkPaint* paint, const SkGlyph& skiaGlyph, CachedGlyphInfo* glyph,
-            bool precaching);
+    void updateGlyphCache(SkPaint* paint, const SkGlyph& skiaGlyph, SkGlyphCache* skiaGlyphCache,
+            CachedGlyphInfo* glyph, bool precaching);
 
     void measureCachedGlyph(CachedGlyphInfo* glyph, int x, int y,
             uint8_t *bitmap, uint32_t bitmapW, uint32_t bitmapH,
diff --git a/libs/hwui/font/FontUtil.h b/libs/hwui/font/FontUtil.h
index cdcb23c4..c2fd5f58 100644
--- a/libs/hwui/font/FontUtil.h
+++ b/libs/hwui/font/FontUtil.h
@@ -40,7 +40,7 @@
 #if RENDER_TEXT_AS_GLYPHS
     typedef uint16_t glyph_t;
     #define TO_GLYPH(g) g
-    #define GET_METRICS(paint, glyph, matrix) paint->getGlyphMetrics(glyph, matrix)
+    #define GET_METRICS(cache, glyph) cache->getGlyphIDMetrics(glyph)
     #define GET_GLYPH(text) nextGlyph((const uint16_t**) &text)
     #define IS_END_OF_STRING(glyph) false
 
@@ -53,7 +53,7 @@
 #else
     typedef SkUnichar glyph_t;
     #define TO_GLYPH(g) ((SkUnichar) g)
-    #define GET_METRICS(paint, glyph, matrix) paint->getUnicharMetrics(glyph, matrix)
+    #define GET_METRICS(cache, glyph) cache->getUnicharMetrics(glyph)
     #define GET_GLYPH(text) SkUTF16_NextUnichar((const uint16_t**) &text)
     #define IS_END_OF_STRING(glyph) glyph < 0
 #endif
diff --git a/media/jni/Android.mk b/media/jni/Android.mk
index 68076331..fad24d54 100644
--- a/media/jni/Android.mk
+++ b/media/jni/Android.mk
@@ -52,7 +52,7 @@ LOCAL_STATIC_LIBRARIES := \
     libstagefright_amrnbenc
 
 LOCAL_C_INCLUDES += \
-    external/jhead \
+    external/libexif \
     external/tremor/Tremor \
     frameworks/base/core/jni \
     frameworks/av/media/libmedia \
diff --git a/media/jni/android_mtp_MtpDatabase.cpp b/media/jni/android_mtp_MtpDatabase.cpp
index 232bb487..9763389c 100644
--- a/media/jni/android_mtp_MtpDatabase.cpp
+++ b/media/jni/android_mtp_MtpDatabase.cpp
@@ -37,7 +37,11 @@
 #include "mtp.h"
 
 extern "C" {
-#include "jhead.h"
+#include "libexif/exif-content.h"
+#include "libexif/exif-data.h"
+#include "libexif/exif-tag.h"
+#include "libexif/exif-utils.h"
+
 }
 
 using namespace android;
@@ -748,6 +752,22 @@ MtpResponseCode MyMtpDatabase::getObjectPropertyList(MtpObjectHandle handle,
     return result;
 }
 
+static void foreachentry(ExifEntry *entry, void *user) {
+    char buf[1024];
+    ALOGI("entry %x, format %d, size %d: %s",
+            entry->tag, entry->format, entry->size, exif_entry_get_value(entry, buf, sizeof(buf)));
+}
+
+static void foreachcontent(ExifContent *content, void *user) {
+    ALOGI("content %d", exif_content_get_ifd(content));
+    exif_content_foreach_entry(content, foreachentry, user);
+}
+
+static long getLongFromExifEntry(ExifEntry *e) {
+    ExifByteOrder o = exif_data_get_byte_order(e->parent->parent);
+    return exif_get_long(e->data, o);
+}
+
 MtpResponseCode MyMtpDatabase::getObjectInfo(MtpObjectHandle handle,
                                             MtpObjectInfo& info) {
     char            date[20];
@@ -790,23 +810,22 @@ MtpResponseCode MyMtpDatabase::getObjectInfo(MtpObjectHandle handle,
 
     // read EXIF data for thumbnail information
     if (info.mFormat == MTP_FORMAT_EXIF_JPEG || info.mFormat == MTP_FORMAT_JFIF) {
-        ResetJpgfile();
-         // Start with an empty image information structure.
-        memset(&ImageInfo, 0, sizeof(ImageInfo));
-        ImageInfo.FlashUsed = -1;
-        ImageInfo.MeteringMode = -1;
-        ImageInfo.Whitebalance = -1;
-        strncpy(ImageInfo.FileName, (const char *)path, PATH_MAX);
-        if (ReadJpegFile((const char*)path, READ_METADATA)) {
-            Section_t* section = FindSection(M_EXIF);
-            if (section) {
-                info.mThumbCompressedSize = ImageInfo.ThumbnailSize;
-                info.mThumbFormat = MTP_FORMAT_EXIF_JPEG;
-                info.mImagePixWidth = ImageInfo.Width;
-                info.mImagePixHeight = ImageInfo.Height;
-            }
+    ExifData *exifdata = exif_data_new_from_file(path);
+        if (exifdata) {
+            //exif_data_foreach_content(exifdata, foreachcontent, NULL);
+
+            // XXX get this from exif, or parse jpeg header instead?
+            ExifEntry *w = exif_content_get_entry(
+                    exifdata->ifd[EXIF_IFD_EXIF], EXIF_TAG_PIXEL_X_DIMENSION);
+            ExifEntry *h = exif_content_get_entry(
+                    exifdata->ifd[EXIF_IFD_EXIF], EXIF_TAG_PIXEL_Y_DIMENSION);
+            info.mThumbCompressedSize = exifdata->data ? exifdata->size : 0;
+            info.mThumbFormat = MTP_FORMAT_EXIF_JPEG;
+            info.mImagePixWidth = w ? getLongFromExifEntry(w) : 0;
+            info.mImagePixHeight = h ? getLongFromExifEntry(h) : 0;
+            exif_data_unref(exifdata);
+
         }
-        DiscardData();
     }
 
     checkAndClearExceptionFromCallback(env, __FUNCTION__);
@@ -822,22 +841,15 @@ void* MyMtpDatabase::getThumbnail(MtpObjectHandle handle, size_t& outThumbSize)
 
     if (getObjectFilePath(handle, path, length, format) == MTP_RESPONSE_OK
             && (format == MTP_FORMAT_EXIF_JPEG || format == MTP_FORMAT_JFIF)) {
-        ResetJpgfile();
-         // Start with an empty image information structure.
-        memset(&ImageInfo, 0, sizeof(ImageInfo));
-        ImageInfo.FlashUsed = -1;
-        ImageInfo.MeteringMode = -1;
-        ImageInfo.Whitebalance = -1;
-        strncpy(ImageInfo.FileName, (const char *)path, PATH_MAX);
-        if (ReadJpegFile((const char*)path, READ_METADATA)) {
-            Section_t* section = FindSection(M_EXIF);
-            if (section) {
-                outThumbSize = ImageInfo.ThumbnailSize;
-                result = malloc(outThumbSize);
-                if (result)
-                    memcpy(result, section->Data + ImageInfo.ThumbnailOffset + 8, outThumbSize);
-            }
-            DiscardData();
+        ExifData *exifdata = exif_data_new_from_file(path);
+        if (exifdata) {
+            if (exifdata->data) {
+                result = malloc(exifdata->size);
+                if (result) {
+                    memcpy(result, exifdata->data, exifdata->size);
+                }
+             }
+            exif_data_unref(exifdata);
         }
     }
 
diff --git a/media/tests/omxjpegdecoder/omx_jpeg_decoder.cpp b/media/tests/omxjpegdecoder/omx_jpeg_decoder.cpp
index 6424744a..53f04bc6 100644
--- a/media/tests/omxjpegdecoder/omx_jpeg_decoder.cpp
+++ b/media/tests/omxjpegdecoder/omx_jpeg_decoder.cpp
@@ -30,6 +30,7 @@
 #include <media/stagefright/MetaData.h>
 #include <media/stagefright/OMXClient.h>
 #include <media/stagefright/OMXCodec.h>
+#include <SkImage.h>
 #include <SkMallocPixelRef.h>
 
 #include "omx_jpeg_decoder.h"
@@ -184,8 +185,7 @@ void OmxJpegImageDecoder::installPixelRef(MediaBuffer *buffer, sp<MediaSource> d
 
 void OmxJpegImageDecoder::configBitmapSize(SkBitmap* bm, SkBitmap::Config pref,
         int width, int height) {
-    bm->setConfig(getColorSpaceConfig(pref), width, height);
-    bm->setIsOpaque(true);
+    bm->setConfig(getColorSpaceConfig(pref), width, height, 0, kOpaque_SkAlphaType);
 }
 
 SkBitmap::Config OmxJpegImageDecoder::getColorSpaceConfig(
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/phone/BarTransitions.java b/packages/SystemUI/src/com/android/systemui/statusbar/phone/BarTransitions.java
index 41d73840..33628d9a 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/phone/BarTransitions.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/phone/BarTransitions.java
@@ -49,7 +49,7 @@ public class BarTransitions {
 
     private final String mTag;
     private final View mView;
-    private final boolean mSupportsTransitions = ActivityManager.isHighEndGfx();
+    private final boolean mSupportsTransitions = true;
     private final BarBackgroundDrawable mBarBackground;
 
     private int mMode;
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBar.java b/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBar.java
index f44c8703..7e29f8b4 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBar.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBar.java
@@ -24,7 +24,6 @@ import static com.android.systemui.statusbar.phone.BarTransitions.MODE_OPAQUE;
 import static com.android.systemui.statusbar.phone.BarTransitions.MODE_SEMI_TRANSPARENT;
 import static com.android.systemui.statusbar.phone.BarTransitions.MODE_TRANSLUCENT;
 import static com.android.systemui.statusbar.phone.BarTransitions.MODE_LIGHTS_OUT;
-import static com.android.systemui.statusbar.phone.BarTransitions.MODE_TRANSPARENT;
 
 import android.animation.Animator;
 import android.animation.AnimatorListenerAdapter;
@@ -49,7 +48,7 @@ import android.content.IntentFilter;
 import android.content.SharedPreferences;
 import android.content.SharedPreferences.Editor;
 import android.content.res.Configuration;
-import android.content.res.CustomTheme;
+import android.content.res.ThemeConfig;
 import android.content.res.Resources;
 import android.database.ContentObserver;
 import android.graphics.Bitmap;
@@ -103,7 +102,7 @@ import android.view.animation.AccelerateInterpolator;
 import android.view.animation.Animation;
 import android.view.animation.AnimationUtils;
 import android.view.animation.DecelerateInterpolator;
-import android.widget.FrameLayout;
+//import android.widget.FrameLayout;
 import android.widget.ImageView;
 import android.widget.FrameLayout;
 import android.widget.LinearLayout;
@@ -140,7 +139,7 @@ import com.android.systemui.statusbar.policy.LocationController;
 import com.android.systemui.statusbar.policy.NetworkController;
 import com.android.systemui.statusbar.policy.NotificationRowLayout;
 import com.android.systemui.statusbar.policy.OnSizeChangedListener;
-import com.android.systemui.statusbar.policy.RotationLockController;
+//import com.android.systemui.statusbar.policy.RotationLockController;
 
 import com.android.systemui.omni.StatusHeaderMachine;
 //import com.android.internal.util.slim.QuietHoursHelper; (Notification Reminder 1/2)
@@ -348,7 +347,7 @@ public class PhoneStatusBar extends BaseStatusBar implements DemoMode {
 
     // last theme that was applied in order to detect theme change (as opposed
     // to some other configuration change).
-    CustomTheme mCurrentTheme;
+    ThemeConfig mCurrentTheme; 
     private boolean mRecreating = false;
 	private StatusHeaderMachine mStatusHeaderMachine;
     private Runnable mStatusHeaderUpdater;
@@ -636,9 +635,9 @@ public class PhoneStatusBar extends BaseStatusBar implements DemoMode {
                 .getDefaultDisplay();
         updateDisplaySize();
 
-        CustomTheme currentTheme = mContext.getResources().getConfiguration().customTheme;
+        ThemeConfig currentTheme = mContext.getResources().getConfiguration().themeConfig; 
         if (currentTheme != null) {
-            mCurrentTheme = (CustomTheme)currentTheme.clone();
+            mCurrentTheme = (ThemeConfig)currentTheme.clone();
 
         }
         
@@ -1309,7 +1308,7 @@ public class PhoneStatusBar extends BaseStatusBar implements DemoMode {
         if (DEBUG) Log.v(TAG, "addNavigationBar: about to add " + mNavigationBarView);
         if (mNavigationBarView == null) return;
 
-        CustomTheme newTheme = mContext.getResources().getConfiguration().customTheme;
+        ThemeConfig newTheme = mContext.getResources().getConfiguration().themeConfig;
         if (newTheme != null &&
                 (mCurrentTheme == null || !mCurrentTheme.equals(newTheme))) {
             // Nevermind, this will be re-created
@@ -3666,10 +3665,10 @@ public class PhoneStatusBar extends BaseStatusBar implements DemoMode {
         final Resources res = context.getResources();
 
         // detect theme change.
-        CustomTheme newTheme = res.getConfiguration().customTheme;
+       ThemeConfig newTheme = res.getConfiguration().themeConfig;
         if (newTheme != null &&
                 (mCurrentTheme == null || !mCurrentTheme.equals(newTheme))) {
-            mCurrentTheme = (CustomTheme)newTheme.clone();
+            mCurrentTheme = (ThemeConfig)newTheme.clone(); 
             recreateStatusBar();
             rebuildRecentsScreen();
         } else {
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/policy/NetworkController.java b/packages/SystemUI/src/com/android/systemui/statusbar/policy/NetworkController.java
index d137d485..4ac7b7b0 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/policy/NetworkController.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/policy/NetworkController.java
@@ -1127,7 +1127,7 @@ public class NetworkController extends BroadcastReceiver implements DemoMode {
                     mobileLabel = mNetworkName;
                 } else {
                     // Tablets, basically
-                    mobileLabel = "";
+                    mobileLabel = "vcc:pdr";
                 }
             } else {
                 mobileLabel
diff --git a/preloaded-classes b/preloaded-classes
index 467da258..d161bc16 100644
--- a/preloaded-classes
+++ b/preloaded-classes
@@ -1202,12 +1202,29 @@ android.view.inputmethod.InputMethodManager$ImeInputEventSender
 android.view.inputmethod.InputMethodManager$PendingEvent
 android.view.textservice.SpellCheckerSubtype
 android.view.textservice.SpellCheckerSubtype$1
+android.webkit.BrowserFrame
+android.webkit.BrowserFrame$ConfigCallback
+android.webkit.CallbackProxy
 android.webkit.CookieManager
 android.webkit.CookieSyncManager
+android.webkit.DeviceMotionAndOrientationManager
 android.webkit.GeolocationPermissions
+android.webkit.HTML5Audio
+android.webkit.HTML5VideoViewProxy
+android.webkit.JWebCoreJavaBridge
 android.webkit.JavascriptInterface
+android.webkit.L10nUtils
+android.webkit.MockGeolocation
+android.webkit.OverScrollGlow
+android.webkit.PluginManager
+android.webkit.QuadF
 android.webkit.URLUtil
+android.webkit.ViewManager
+android.webkit.ViewManager$2
+android.webkit.ViewManager$3
+android.webkit.ViewStateSerializer
 android.webkit.WebBackForwardList
+android.webkit.WebCoreThreadWatchdog
 android.webkit.WebHistoryItem
 android.webkit.WebIconDatabase
 android.webkit.WebSettings
@@ -1221,14 +1238,35 @@ android.webkit.WebSyncManager$SyncHandler
 android.webkit.WebView
 android.webkit.WebView$PrivateAccess
 android.webkit.WebViewClient
+android.webkit.WebViewCore$AutoFillData
+android.webkit.WebViewCore$DrawData
+android.webkit.WebViewCore$EventHub
+android.webkit.WebViewCore$EventHub$1
+android.webkit.WebViewCore$GetUrlData
+android.webkit.WebViewCore$TextFieldInitData
+android.webkit.WebViewCore$ViewState
+android.webkit.WebViewCore$WebCoreThread
+android.webkit.WebViewCore$WebCoreThread$1
 android.webkit.WebViewDatabase
 android.webkit.WebViewFactory
 android.webkit.WebViewFactory$Preloader
 android.webkit.WebViewFactoryProvider
 android.webkit.WebViewFactoryProvider$Statics
+android.webkit.WebViewInputDispatcher
+android.webkit.WebViewInputDispatcher$DispatchEventQueue
+android.webkit.WebViewInputDispatcher$TouchStream
+android.webkit.WebViewInputDispatcher$UiCallbacks
+android.webkit.WebViewInputDispatcher$UiHandler
+android.webkit.WebViewInputDispatcher$WebKitCallbacks
+android.webkit.WebViewInputDispatcher$WebKitHandler
 android.webkit.WebViewProvider
 android.webkit.WebViewProvider$ScrollDelegate
 android.webkit.WebViewProvider$ViewDelegate
+android.webkit.ZoomControlBase
+android.webkit.ZoomControlExternal
+android.webkit.ZoomManager
+android.webkit.ZoomManager$FocusMovementQueue
+android.webkit.ZoomManager$PostScale
 android.widget.AbsListView
 android.widget.AbsListView$1
 android.widget.AbsListView$AdapterDataSetObserver
diff --git a/services/java/com/android/server/AppsLaunchFailureReceiver.java b/services/java/com/android/server/AppsLaunchFailureReceiver.java
index 6da9a2d4..0b9f360c 100644
--- a/services/java/com/android/server/AppsLaunchFailureReceiver.java
+++ b/services/java/com/android/server/AppsLaunchFailureReceiver.java
@@ -20,7 +20,7 @@ import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.Intent;
 import android.content.pm.ThemeUtils;
-import android.content.res.CustomTheme;
+import android.content.res.ThemeConfig;
 import android.content.res.ThemeManager;
 import android.os.SystemClock;
 import android.provider.ThemesContract;
@@ -66,7 +66,7 @@ public class AppsLaunchFailureReceiver extends BroadcastReceiver {
                     components.add(ThemesContract.ThemesColumns.MODIFIES_NOTIFICATIONS);
                     components.add(ThemesContract.ThemesColumns.MODIFIES_OVERLAYS);
                     components.add(ThemesContract.ThemesColumns.MODIFIES_RINGTONES);
-                    tm.requestThemeChange(CustomTheme.HOLO_DEFAULT, components);
+                    tm.requestThemeChange(ThemeConfig.HOLO_DEFAULT, components);
                 }
             }
         } else if (action.equals(Intent.ACTION_APP_LAUNCH_FAILURE_RESET)
diff --git a/services/java/com/android/server/SystemServer.java b/services/java/com/android/server/SystemServer.java
index 43d2d645..6c5cc6ee 100644
--- a/services/java/com/android/server/SystemServer.java
+++ b/services/java/com/android/server/SystemServer.java
@@ -30,14 +30,14 @@ import android.content.pm.IPackageManager;
 import android.content.pm.PackageManager;
 import android.content.pm.ThemeUtils;
 import android.content.res.Configuration;
-import android.content.res.CustomTheme;
+import android.content.res.ThemeConfig;
 import android.database.ContentObserver;
 import android.media.AudioService;
 import android.net.wifi.p2p.WifiP2pService;
 import android.os.Environment;
 import android.net.INetworkPolicyManager;
 import android.net.INetworkStatsService;
-import android.os.IBinder;
+//import android.os.IBinder;
 import android.os.Handler;
 import android.os.HandlerThread;
 import android.os.Looper;
@@ -50,7 +50,7 @@ import android.os.SystemProperties;
 import android.os.UserHandle;
 import android.provider.Settings;
 import android.service.dreams.DreamService;
-import android.text.TextUtils;
+//import android.text.TextUtils;
 import android.util.DisplayMetrics;
 import android.util.EventLog;
 import android.util.Log;
@@ -1244,8 +1244,9 @@ class ServerThread {
                 try {
                     // now that the system is up, apply default theme if applicable
                     if (themeServiceF != null) themeServiceF.systemRunning();
-                    CustomTheme customTheme = CustomTheme.getBootTheme(contextF.getContentResolver());
-                    String iconPkg = customTheme.getIconPackPkgName();
+                    ThemeConfig themeConfig =
+                            ThemeConfig.getBootTheme(contextF.getContentResolver());
+                    String iconPkg = themeConfig.getIconPackPkgName(); 
                     pmf.updateIconMapping(iconPkg);
                 } catch (Throwable e) {
                     reportWtf("Icon Mapping failed", e);
diff --git a/services/java/com/android/server/ThemeService.java b/services/java/com/android/server/ThemeService.java
index 83d53d6e..6756a1ab 100644
--- a/services/java/com/android/server/ThemeService.java
+++ b/services/java/com/android/server/ThemeService.java
@@ -33,7 +33,7 @@ import android.content.pm.ResolveInfo;
 import android.content.pm.ThemeUtils;
 import android.content.res.AssetManager;
 import android.content.res.Configuration;
-import android.content.res.CustomTheme;
+import android.content.res.ThemeConfig;
 import android.content.res.IThemeChangeListener;
 import android.content.res.IThemeService;
 import android.database.Cursor;
@@ -70,7 +70,7 @@ import java.util.zip.ZipFile;
 
 import static android.content.pm.ThemeUtils.SYSTEM_THEME_PATH;
 import static android.content.pm.ThemeUtils.THEME_BOOTANIMATION_PATH;
-import static android.content.res.CustomTheme.HOLO_DEFAULT;
+import static android.content.res.ThemeConfig.HOLO_DEFAULT;
 
 import java.util.List;
 
@@ -565,8 +565,8 @@ public class ThemeService extends IThemeService.Stub {
             final long token = Binder.clearCallingIdentity();
             try {
                 Configuration config = am.getConfiguration();
-                CustomTheme.Builder themeBuilder = createBuilderFrom(config, components);
-                config.customTheme = themeBuilder.build();
+                ThemeConfig.Builder themeBuilder = createBuilderFrom(config, components);
+                config.themeConfig = themeBuilder.build(); 
                 am.updateConfiguration(config);
             } catch (RemoteException e) {
                 return false;
@@ -577,20 +577,27 @@ public class ThemeService extends IThemeService.Stub {
         return true;
     }
 
-    private CustomTheme.Builder createBuilderFrom(Configuration config, List<String> components) {
-        CustomTheme.Builder builder = new CustomTheme.Builder(config.customTheme);
+        private ThemeConfig.Builder createBuilderFrom(Configuration config, List<String> components) {
+        ThemeConfig.Builder builder = new ThemeConfig.Builder(config.themeConfig);
 
         if (components.contains(ThemesContract.ThemesColumns.MODIFIES_ICONS)) {
-            builder.icons(mPkgName);
+            builder.defaultIcon(mPkgName);
         }
 
         if (components.contains(ThemesContract.ThemesColumns.MODIFIES_OVERLAYS)) {
-            builder.overlay(mPkgName);
-            builder.systemUi(mPkgName);
+            builder.defaultOverlay(mPkgName);
         }
 
         if (components.contains(ThemesContract.ThemesColumns.MODIFIES_FONTS)) {
-            builder.fonts(mPkgName);
+            builder.defaultFont(mPkgName);
+        }
+
+        if (components.contains(ThemesContract.ThemesColumns.MODIFIES_STATUS_BAR)) {
+            builder.overlay("com.android.systemui", mPkgName);
+        }
+
+        if (components.contains(ThemesContract.ThemesColumns.MODIFIES_NAVIGATION_BAR)) {
+            builder.overlay(ThemeConfig.SYSTEMUI_NAVBAR_PKG, mPkgName); 
         }
 
         return builder;
diff --git a/services/java/com/android/server/am/ActivityManagerService.java b/services/java/com/android/server/am/ActivityManagerService.java
index 2b003e0a..5be04065 100644
--- a/services/java/com/android/server/am/ActivityManagerService.java
+++ b/services/java/com/android/server/am/ActivityManagerService.java
@@ -30,6 +30,7 @@ import static com.android.server.am.ActivityStackSupervisor.HOME_STACK_ID;
 import android.app.AppOpsManager;
 import android.appwidget.AppWidgetManager;
 import android.content.pm.ThemeUtils;
+import android.content.res.ThemeConfig;
 import android.util.ArrayMap;
 
 import com.android.internal.R;
@@ -127,9 +128,9 @@ import android.content.pm.ResolveInfo;
 import android.content.pm.ServiceInfo;
 import android.content.res.CompatibilityInfo;
 import android.content.res.Configuration;
-import android.content.res.CustomTheme;
+//import android.content.res.CustomTheme;
 import android.graphics.Bitmap;
-import android.graphics.Typeface;
+//import android.graphics.Typeface;
 import android.net.Proxy;
 import android.net.ProxyProperties;
 import android.net.Uri;
@@ -205,7 +206,7 @@ import java.util.Set;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicLong;
 
-import dalvik.system.Zygote;
+//import dalvik.system.Zygote;
 
 public final class ActivityManagerService extends ActivityManagerNative
         implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback {
@@ -14135,8 +14136,8 @@ public final class ActivityManagerService extends ActivityManagerNative
         Configuration ci;
         synchronized(this) {
             ci = new Configuration(mConfiguration);
-            if (ci.customTheme == null) {
-                ci.customTheme = CustomTheme.getBootTheme(mContext.getContentResolver());
+	if (ci.themeConfig == null) {
+                ci.themeConfig = ThemeConfig.getBootTheme(mContext.getContentResolver());
             }
         }
         return ci;
@@ -14212,9 +14213,9 @@ public final class ActivityManagerService extends ActivityManagerNative
                                      values.userSetLocale);
                 }
 
-                if (values.customTheme != null) {
-                    saveThemeResourceLocked(values.customTheme,
-                            !values.customTheme.equals(mConfiguration.customTheme));
+		if (values.themeConfig != null) {
+                    saveThemeResourceLocked(values.themeConfig,
+                            !values.themeConfig.equals(mConfiguration.themeConfig));
                 }
 
                 mConfigurationSeq++;
@@ -14366,12 +14367,10 @@ public final class ActivityManagerService extends ActivityManagerNative
         return srec.launchedFromPackage;
     }
 
-    private void saveThemeResourceLocked(CustomTheme t, boolean isDiff){
+    private void saveThemeResourceLocked(ThemeConfig t, boolean isDiff){
         if(isDiff) {
-            Settings.Secure.putString(mContext.getContentResolver(), Configuration.THEME_PACKAGE_NAME_PERSISTENCE_PROPERTY, t.getThemePackageName());
-            Settings.Secure.putString(mContext.getContentResolver(), Configuration.THEME_SYSTEMUI_PACKAGE_NAME_PERSISTENCE_PROPERTY, t.getSystemUiPackageName());
-            Settings.Secure.putString(mContext.getContentResolver(), Configuration.THEME_ICONPACK_PACKAGE_NAME_PERSISTENCE_PROPERTY, t.getIconPackPkgName());
-            Settings.Secure.putString(mContext.getContentResolver(), Configuration.THEME_FONT_PACKAGE_NAME_PERSISTENCE_PROPERTY, t.getFontPackPkgName());
+        Settings.Secure.putString(mContext.getContentResolver(),
+                    Configuration.THEME_PKG_CONFIGURATION_PERSISTENCE_PROPERTY, t.toJson());
         }
     }
 

project frameworks/opt/mms/
diff --git a/src/java/com/google/android/mms/pdu/PduPersister.java b/src/java/com/google/android/mms/pdu/PduPersister.java
index 902c2cd..d4fc296 100644
--- a/src/java/com/google/android/mms/pdu/PduPersister.java
+++ b/src/java/com/google/android/mms/pdu/PduPersister.java
@@ -1411,7 +1411,7 @@ public class PduPersister {
         values.put(Mms.TEXT_ONLY, textOnly ? 1 : 0);
 
         // Update subscription for MMS message
-        values.put(Mms.SUB_ID, subscription);
+        // values.put(Mms.SUB_ID, subscription);
 
         Uri res = null;
         if (existingUri) {

project frameworks/webview/
diff --git a/chromium/Android.mk b/chromium/Android.mk
index d715221..49c22cb 100644
--- a/chromium/Android.mk
+++ b/chromium/Android.mk
@@ -94,7 +94,7 @@ LOCAL_REQUIRED_MODULES := \
 LOCAL_PROGUARD_ENABLED := full
 LOCAL_PROGUARD_FLAG_FILES := proguard.flags
 
-LOCAL_JAVACFLAGS := -Xlint:unchecked -Werror
+LOCAL_JAVACFLAGS := -Xlint:unchecked
 
 include $(BUILD_JAVA_LIBRARY)
 
@@ -114,7 +114,13 @@ $(jar_check_ok): $(full_classes_jarjar_jar) $(LOCAL_PATH)/tools/jar_check.py $(L
 $(LOCAL_BUILT_MODULE): $(jar_check_ok)
 endif
 
-
+# Use prebuilt android_webview_java to satisfy webviewchromium's dependency
+# if we are working with prebuilt Chromium
+ifeq ($(PRODUCT_PREBUILT_WEBVIEWCHROMIUM),yes)
+include $(CLEAR_VARS)
+LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES := android_webview_java:../../../prebuilts/chromium/u8833/android_webview_java.jar
+include $(BUILD_MULTI_PREBUILT)
+endif
 
 # Native support library (libwebviewchromium_plat_support.so) - does NOT link
 # any native chromium code.

project hardware/libhardware_legacy/
diff --git a/include/hardware_legacy/AudioSystemLegacy.h b/include/hardware_legacy/AudioSystemLegacy.h
index 0552a2b..d4ad0d0 100644
--- a/include/hardware_legacy/AudioSystemLegacy.h
+++ b/include/hardware_legacy/AudioSystemLegacy.h
@@ -65,6 +65,9 @@ enum audio_source {
     AUDIO_SOURCE_CAMCORDER = 5,
     AUDIO_SOURCE_VOICE_RECOGNITION = 6,
     AUDIO_SOURCE_VOICE_COMMUNICATION = 7,
+#ifdef MTK_HARDWARE
+    AUDIO_SOURCE_FM_RX = 9,
+#endif
 #ifdef QCOM_HARDWARE
     AUDIO_SOURCE_REMOTE_SUBMIX = 8,
     AUDIO_SOURCE_FM_RX = 9,
@@ -319,6 +322,9 @@ public:
         DEVICE_IN_AUX_DIGITAL = 0x200000,
         DEVICE_IN_VOICE_CALL = 0x400000,
         DEVICE_IN_BACK_MIC = 0x800000,
+#ifdef MTK_HARDWARE
+        DEVICE_IN_FM = 0x20000000,
+#endif
         DEVICE_IN_DEFAULT = 0x80000000,
 #endif
 
@@ -329,6 +335,9 @@ public:
                 DEVICE_IN_FM_RX | DEVICE_IN_FM_RX_A2DP | DEVICE_IN_DEFAULT |
                 DEVICE_IN_ANLG_DOCK_HEADSET | DEVICE_IN_PROXY)
 #else
+#ifdef MTK_HARDWARE
+                DEVICE_IN_FM |
+#endif
                 DEVICE_IN_VOICE_CALL | DEVICE_IN_BACK_MIC | DEVICE_IN_DEFAULT)
 #endif
     };

project hardware/qcom/audio-caf/
diff --git a/Android.mk b/Android.mk
index 9324e00..47e0705 100644
--- a/Android.mk
+++ b/Android.mk
@@ -1,5 +1,5 @@
 ifeq ($(call my-dir),$(call project-path-for,qcom-audio))
-ifneq ($(filter msm8960 msm8660 msm8226 msm8x26 msm8610 msm8974 msm8x74 msm7x30 apq8084 msm8916,$(TARGET_BOARD_PLATFORM)),)
+ifneq ($(filter msm8960 msm8660 msm8226 msm8x26 msm8610 msm8974 msm8x74 msm7x27a msm7x30 apq8084 msm8916,$(TARGET_BOARD_PLATFORM)),)
 
 MY_LOCAL_PATH := $(call my-dir)
 

project kernel/huawei/huawei-kernel-3.4/
diff --git a/kernel/sys.c b/kernel/sys.c
index 0bec05ed..1a8fa419 100644
--- a/kernel/sys.c
+++ b/kernel/sys.c
@@ -476,6 +476,8 @@ static void migrate_to_reboot_cpu(void)
  */
 void kernel_restart(char *cmd)
 {
+	if (!cmd || cmd[0] == 0)
+		cmd = "reboot";
 	kernel_restart_prepare(cmd);
 	migrate_to_reboot_cpu();
 	syscore_shutdown();

project packages/apps/Bluetooth/
diff --git a/jni/com_android_bluetooth_gatt.cpp b/jni/com_android_bluetooth_gatt.cpp
index 1ffac4e..8cfb4cc 100644
--- a/jni/com_android_bluetooth_gatt.cpp
+++ b/jni/com_android_bluetooth_gatt.cpp
@@ -158,7 +158,7 @@ static jmethodID method_onGetDescriptor;
 static jmethodID method_onGetIncludedService;
 static jmethodID method_onRegisterForNotifications;
 static jmethodID method_onReadRemoteRssi;
-static jmethodID method_onAdvertiseCallback;
+// static jmethodID method_onAdvertiseCallback;
 
 /**
  * Server callback methods
@@ -422,14 +422,14 @@ void btgattc_remote_rssi_cb(int client_if,bt_bdaddr_t* bda, int rssi, int status
     sCallbackEnv->DeleteLocalRef(address);
     checkAndClearExceptionFromCallback(sCallbackEnv, __FUNCTION__);
 }
-
+/*
 void btgattc_advertise_cb(int status, int client_if)
 {
     CHECK_CALLBACK_ENV
     sCallbackEnv->CallVoidMethod(mCallbacksObj, method_onAdvertiseCallback, status, client_if);
     checkAndClearExceptionFromCallback(sCallbackEnv, __FUNCTION__);
 }
-
+*/
 static const btgatt_client_callbacks_t sGattClientCallbacks = {
     btgattc_register_app_cb,
     btgattc_scan_result_cb,
@@ -447,8 +447,8 @@ static const btgatt_client_callbacks_t sGattClientCallbacks = {
     btgattc_read_descriptor_cb,
     btgattc_write_descriptor_cb,
     btgattc_execute_write_cb,
-    btgattc_remote_rssi_cb,
-    btgattc_advertise_cb
+    btgattc_remote_rssi_cb //,
+//    btgattc_advertise_cb
 };
 
 
@@ -679,7 +679,7 @@ static void classInitNative(JNIEnv* env, jclass clazz) {
     method_onAttributeRead= env->GetMethodID(clazz, "onAttributeRead", "(Ljava/lang/String;IIIIZ)V");
     method_onAttributeWrite= env->GetMethodID(clazz, "onAttributeWrite", "(Ljava/lang/String;IIIIIZZ[B)V");
     method_onExecuteWrite= env->GetMethodID(clazz, "onExecuteWrite", "(Ljava/lang/String;III)V");
-    method_onAdvertiseCallback = env->GetMethodID(clazz, "onAdvertiseCallback", "(II)V");
+//    method_onAdvertiseCallback = env->GetMethodID(clazz, "onAdvertiseCallback", "(II)V");
 
     info("classInitNative: Success!");
 }
diff --git a/src/com/android/bluetooth/gatt/GattService.java b/src/com/android/bluetooth/gatt/GattService.java
index fa05c98..f090f11 100644
--- a/src/com/android/bluetooth/gatt/GattService.java
+++ b/src/com/android/bluetooth/gatt/GattService.java
@@ -13,37 +13,30 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
 package com.android.bluetooth.gatt;
-
 import android.app.Service;
 import android.bluetooth.BluetoothAdapter;
 import android.bluetooth.BluetoothDevice;
 import android.bluetooth.BluetoothProfile;
-import android.bluetooth.BluetoothUuid;
 import android.bluetooth.IBluetoothGatt;
 import android.bluetooth.IBluetoothGattCallback;
 import android.bluetooth.IBluetoothGattServerCallback;
 import android.content.Intent;
 import android.os.IBinder;
+import android.os.IBinder.DeathRecipient;
 import android.os.ParcelUuid;
 import android.os.RemoteException;
 import android.util.Log;
-
-import com.android.bluetooth.btservice.ProfileService;
-
-import java.nio.ByteBuffer;
-import java.nio.ByteOrder;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.HashSet;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import java.util.UUID;
-
-import com.android.bluetooth.LeScanRequestArbitrator;
-
+import com.android.bluetooth.btservice.ProfileService;
+import com.android.bluetooth.btservice.ProfileService.IProfileServiceBinder;
 /**
  * Provides Bluetooth Gatt profile, as a service in
  * the Bluetooth application.
@@ -52,75 +45,35 @@ import com.android.bluetooth.LeScanRequestArbitrator;
 public class GattService extends ProfileService {
     private static final boolean DBG = GattServiceConfig.DBG;
     private static final String TAG = GattServiceConfig.TAG_PREFIX + "GattService";
-    private static final int DEFAULT_SCAN_INTERVAL_MILLIS = 200;
-
-    /**
-     * Max packet size for ble advertising, defined in Bluetooth Specification Version 4.0 [Vol 3].
-     */
-    private static final int ADVERTISING_PACKET_MAX_BYTES = 31;
-    /**
-     * Size overhead for advertising flag.
-     */
-    private static final int ADVERTISING_FLAGS_BYTES = 3;
-    /**
-     * Size overhead per field. Usually it's just one byte of field length and one byte of
-     * field type.
-     */
-    private static final int FIELD_OVERHEAD_BYTES = 2;
-
-    /**
-     * Byte size of 16 bit service uuid.
-     */
-    private static final int SHORT_UUID_BYTES = 2;
-    /**
-     * Byte size of 128 bit service uuid.
-     */
-    private static final int FULL_UUID_BYTES = 16;
-
+    BluetoothAdapter mAdapter = BluetoothAdapter.getDefaultAdapter();
     /**
      * Search queue to serialize remote onbject inspection.
      */
     SearchQueue mSearchQueue = new SearchQueue();
-
     /**
      * List of our registered clients.
      */
-
     class ClientMap extends ContextMap<IBluetoothGattCallback> {}
     ClientMap mClientMap = new ClientMap();
-
     /**
      * List of our registered server apps.
      */
     class ServerMap extends ContextMap<IBluetoothGattServerCallback> {}
     ServerMap mServerMap = new ServerMap();
-
     /**
      * Server handle map.
      */
     HandleMap mHandleMap = new HandleMap();
-    private List<UUID> mAdvertisingServiceUuids = new ArrayList<UUID>();
-
-    private int mAdvertisingClientIf = 0;
-
-    private byte[] mServiceData = new byte[0];
-    private int mManufacturerCode = -1;
-    private byte[] mManufacturerData = new byte[0];
-    private Integer mAdvertisingState = BluetoothAdapter.STATE_ADVERTISE_STOPPED;
-    private final Object mLock = new Object();
-
     /**
      * Pending service declaration queue
      */
     private List<ServiceDeclaration> mServiceDeclarations = new ArrayList<ServiceDeclaration>();
-
     private ServiceDeclaration addDeclaration() {
         synchronized (mServiceDeclarations) {
             mServiceDeclarations.add(new ServiceDeclaration());
         }
         return getActiveDeclaration();
     }
-
     private ServiceDeclaration getActiveDeclaration() {
         synchronized (mServiceDeclarations) {
             if (mServiceDeclarations.size() > 0)
@@ -128,7 +81,6 @@ public class GattService extends ProfileService {
         }
         return null;
     }
-
     private ServiceDeclaration getPendingDeclaration() {
         synchronized (mServiceDeclarations) {
             if (mServiceDeclarations.size() > 0)
@@ -136,19 +88,16 @@ public class GattService extends ProfileService {
         }
         return null;
     }
-
     private void removePendingDeclaration() {
         synchronized (mServiceDeclarations) {
             if (mServiceDeclarations.size() > 0)
                 mServiceDeclarations.remove(0);
         }
     }
-
     /**
-     * List of clients interested in scan results.
+     * List of clients intereste in scan results.
      */
     private List<ScanClient> mScanQueue = new ArrayList<ScanClient>();
-
     private ScanClient getScanClient(int appIf, boolean isServer) {
         for(ScanClient client : mScanQueue) {
             if (client.appIf == appIf && client.isServer == isServer) {
@@ -157,39 +106,32 @@ public class GattService extends ProfileService {
         }
         return null;
     }
-
     private void removeScanClient(int appIf, boolean isServer) {
         for(ScanClient client : mScanQueue) {
-          if (client.appIf == appIf && client.isServer == isServer) {
+            if (client.appIf == appIf && client.isServer == isServer) {
                 mScanQueue.remove(client);
                 break;
             }
         }
     }
-
     /**
      * Reliable write queue
      */
     private Set<String> mReliableQueue = new HashSet<String>();
-
     static {
         classInitNative();
     }
-
     protected String getName() {
         return TAG;
     }
-
     protected IProfileServiceBinder initBinder() {
         return new BluetoothGattBinder(this);
     }
-
     protected boolean start() {
         if (DBG) Log.d(TAG, "start()");
         initializeNative();
         return true;
     }
-
     protected boolean stop() {
         if (DBG) Log.d(TAG, "stop()");
         mClientMap.clear();
@@ -201,13 +143,11 @@ public class GattService extends ProfileService {
         mReliableQueue.clear();
         return true;
     }
-
     protected boolean cleanup() {
         if (DBG) Log.d(TAG, "cleanup()");
         cleanupNative();
         return true;
     }
-
     @Override
     public int onStartCommand(Intent intent, int flags, int startId) {
         if (GattDebugUtils.handleDebugAction(this, intent)) {
@@ -215,88 +155,68 @@ public class GattService extends ProfileService {
         }
         return super.onStartCommand(intent, flags, startId);
     }
-
     /**
      * DeathReceipient handlers used to unregister applications that
      * disconnect ungracefully (ie. crash or forced close).
      */
-
     class ClientDeathRecipient implements IBinder.DeathRecipient {
         int mAppIf;
-
         public ClientDeathRecipient(int appIf) {
             mAppIf = appIf;
         }
-
         public void binderDied() {
             if (DBG) Log.d(TAG, "Binder is dead - unregistering client (" + mAppIf + ")!");
-            if (mAdvertisingClientIf == mAppIf) {
-                stopAdvertising(true);  // force stop advertising.
-            } else {
-                stopScan(mAppIf, false);
-            }
+            stopScan(mAppIf, false);
             unregisterClient(mAppIf);
         }
     }
-
     class ServerDeathRecipient implements IBinder.DeathRecipient {
         int mAppIf;
-
         public ServerDeathRecipient(int appIf) {
             mAppIf = appIf;
         }
-
         public void binderDied() {
             if (DBG) Log.d(TAG, "Binder is dead - unregistering server (" + mAppIf + ")!");
             unregisterServer(mAppIf);
         }
     }
-
     /**
      * Handlers for incoming service calls
      */
     private static class BluetoothGattBinder extends IBluetoothGatt.Stub implements IProfileServiceBinder {
         private GattService mService;
-
         public BluetoothGattBinder(GattService svc) {
             mService = svc;
         }
-
         public boolean cleanup()  {
             mService = null;
             return true;
         }
-
         private GattService getService() {
             if (mService  != null && mService.isAvailable()) return mService;
             Log.e(TAG, "getService() - Service requested, but not available!");
             return null;
         }
-
         public List<BluetoothDevice> getDevicesMatchingConnectionStates(int[] states) {
             GattService service = getService();
             if (service == null) return new ArrayList<BluetoothDevice>();
             return service.getDevicesMatchingConnectionStates(states);
         }
-
         public void registerClient(ParcelUuid uuid, IBluetoothGattCallback callback) {
             GattService service = getService();
             if (service == null) return;
             service.registerClient(uuid.getUuid(), callback);
         }
-
         public void unregisterClient(int clientIf) {
             GattService service = getService();
             if (service == null) return;
             service.unregisterClient(clientIf);
         }
-
         public void startScan(int appIf, boolean isServer) {
             GattService service = getService();
             if (service == null) return;
             service.startScan(appIf, isServer);
         }
-
         public void startScanWithUuids(int appIf, boolean isServer, ParcelUuid[] ids) {
             GattService service = getService();
             if (service == null) return;
@@ -306,37 +226,36 @@ public class GattService extends ProfileService {
             }
             service.startScanWithUuids(appIf, isServer, uuids);
         }
-
         public void stopScan(int appIf, boolean isServer) {
             GattService service = getService();
             if (service == null) return;
             service.stopScan(appIf, isServer);
         }
-
         public void clientConnect(int clientIf, String address, boolean isDirect) {
             GattService service = getService();
             if (service == null) return;
             service.clientConnect(clientIf, address, isDirect);
         }
-
         public void clientDisconnect(int clientIf, String address) {
             GattService service = getService();
             if (service == null) return;
             service.clientDisconnect(clientIf, address);
         }
-
+        public void clientListen(int clientIf, boolean start) {
+            GattService service = getService();
+            if (service == null) return;
+            service.clientListen(clientIf, start);
+        }
         public void refreshDevice(int clientIf, String address) {
             GattService service = getService();
             if (service == null) return;
             service.refreshDevice(clientIf, address);
         }
-
         public void discoverServices(int clientIf, String address) {
             GattService service = getService();
             if (service == null) return;
             service.discoverServices(clientIf, address);
         }
-
         public void readCharacteristic(int clientIf, String address, int srvcType,
                                        int srvcInstanceId, ParcelUuid srvcId,
                                        int charInstanceId, ParcelUuid charId,
@@ -347,7 +266,6 @@ public class GattService extends ProfileService {
                                        srvcId.getUuid(), charInstanceId,
                                        charId.getUuid(), authReq);
         }
-
         public void writeCharacteristic(int clientIf, String address, int srvcType,
                              int srvcInstanceId, ParcelUuid srvcId,
                              int charInstanceId, ParcelUuid charId,
@@ -359,7 +277,6 @@ public class GattService extends ProfileService {
                                        charId.getUuid(), writeType, authReq,
                                        value);
         }
-
         public void readDescriptor(int clientIf, String address, int srvcType,
                             int srvcInstanceId, ParcelUuid srvcId,
                             int charInstanceId, ParcelUuid charId,
@@ -373,7 +290,6 @@ public class GattService extends ProfileService {
                                    descrInstanceId, descrId.getUuid(),
                                    authReq);
         }
-
         public void writeDescriptor(int clientIf, String address, int srvcType,
                             int srvcInstanceId, ParcelUuid srvcId,
                             int charInstanceId, ParcelUuid charId,
@@ -387,19 +303,16 @@ public class GattService extends ProfileService {
                                     descrInstanceId, descrId.getUuid(),
                                     writeType, authReq, value);
         }
-
         public void beginReliableWrite(int clientIf, String address) {
             GattService service = getService();
             if (service == null) return;
             service.beginReliableWrite(clientIf, address);
         }
-
         public void endReliableWrite(int clientIf, String address, boolean execute) {
             GattService service = getService();
             if (service == null) return;
             service.endReliableWrite(clientIf, address, execute);
         }
-
         public void registerForNotification(int clientIf, String address, int srvcType,
                             int srvcInstanceId, ParcelUuid srvcId,
                             int charInstanceId, ParcelUuid charId,
@@ -410,46 +323,39 @@ public class GattService extends ProfileService {
                                        srvcId.getUuid(), charInstanceId,
                                        charId.getUuid(), enable);
         }
-
         public void readRemoteRssi(int clientIf, String address) {
             GattService service = getService();
             if (service == null) return;
             service.readRemoteRssi(clientIf, address);
         }
-
         public void registerServer(ParcelUuid uuid, IBluetoothGattServerCallback callback) {
             GattService service = getService();
             if (service == null) return;
             service.registerServer(uuid.getUuid(), callback);
         }
-
         public void unregisterServer(int serverIf) {
             GattService service = getService();
             if (service == null) return;
             service.unregisterServer(serverIf);
         }
-
         public void serverConnect(int serverIf, String address, boolean isDirect) {
             GattService service = getService();
             if (service == null) return;
             service.serverConnect(serverIf, address, isDirect);
         }
-
         public void serverDisconnect(int serverIf, String address) {
             GattService service = getService();
             if (service == null) return;
             service.serverDisconnect(serverIf, address);
         }
-
         public void beginServiceDeclaration(int serverIf, int srvcType,
                                             int srvcInstanceId, int minHandles,
-                                            ParcelUuid srvcId, boolean advertisePreferred) {
+                                            ParcelUuid srvcId) {
             GattService service = getService();
             if (service == null) return;
             service.beginServiceDeclaration(serverIf, srvcType, srvcInstanceId,
-                               minHandles, srvcId.getUuid(), advertisePreferred);
+                               minHandles, srvcId.getUuid());
         }
-
         public void addIncludedService(int serverIf, int srvcType,
                             int srvcInstanceId, ParcelUuid srvcId) {
             GattService service = getService();
@@ -457,7 +363,6 @@ public class GattService extends ProfileService {
             service.addIncludedService(serverIf, srvcType, srvcInstanceId,
                                             srvcId.getUuid());
         }
-
         public void addCharacteristic(int serverIf, ParcelUuid charId,
                             int properties, int permissions) {
             GattService service = getService();
@@ -465,20 +370,17 @@ public class GattService extends ProfileService {
             service.addCharacteristic(serverIf, charId.getUuid(), properties,
                                       permissions);
         }
-
         public void addDescriptor(int serverIf, ParcelUuid descId,
                            int permissions) {
             GattService service = getService();
             if (service == null) return;
             service.addDescriptor(serverIf, descId.getUuid(), permissions);
         }
-
         public void endServiceDeclaration(int serverIf) {
             GattService service = getService();
             if (service == null) return;
             service.endServiceDeclaration(serverIf);
         }
-
         public void removeService(int serverIf, int srvcType,
                            int srvcInstanceId, ParcelUuid srvcId) {
             GattService service = getService();
@@ -486,20 +388,17 @@ public class GattService extends ProfileService {
             service.removeService(serverIf, srvcType, srvcInstanceId,
                                   srvcId.getUuid());
         }
-
         public void clearServices(int serverIf) {
             GattService service = getService();
             if (service == null) return;
             service.clearServices(serverIf);
         }
-
         public void sendResponse(int serverIf, String address, int requestId,
                                  int status, int offset, byte[] value) {
             GattService service = getService();
             if (service == null) return;
             service.sendResponse(serverIf, address, requestId, status, offset, value);
         }
-
         public void sendNotification(int serverIf, String address, int srvcType,
                                               int srvcInstanceId, ParcelUuid srvcId,
                                               int charInstanceId, ParcelUuid charId,
@@ -509,80 +408,21 @@ public class GattService extends ProfileService {
             service.sendNotification(serverIf, address, srvcType, srvcInstanceId,
                 srvcId.getUuid(), charInstanceId, charId.getUuid(), confirm, value);
         }
-
-        @Override
-        public void startAdvertising(int appIf) throws RemoteException {
-            GattService service = getService();
-            if (service == null) return;
-            service.startAdvertising(appIf);
-        }
-
-        @Override
-        public boolean isAdvertising() {
-            GattService service = getService();
-            if (service == null) return false;
-            return service.isAdvertising();
-        }
-
-        @Override
-        public void stopAdvertising() throws RemoteException {
+        public void setAdvData(int serverIf, boolean setScanRsp, boolean inclName,
+                                boolean inclTxPower, int minInterval, int maxInterval,
+                                int appearance, byte[] manufacturerData) {
             GattService service = getService();
             if (service == null) return;
-            service.stopAdvertising();
-        }
-
-        @Override
-        public boolean setAdvServiceData(byte[] serviceData) throws RemoteException {
-            GattService service = getService();
-            if (service == null) return false;
-            return service.setAdvServiceData(serviceData);
-        }
-
-        @Override
-        public byte[] getAdvServiceData() throws RemoteException {
-            GattService service = getService();
-            if (service == null) return null;
-            return service.getAdvServiceData();
-        }
-
-        @Override
-        public boolean setAdvManufacturerCodeAndData(int manufactureCode, byte[] manufacturerData)
-            throws RemoteException {
-            GattService service = getService();
-            if (service == null) return false;
-            return service.setAdvManufacturerCodeAndData(manufactureCode, manufacturerData);
-        }
-
-        @Override
-        public byte[] getAdvManufacturerData() throws RemoteException {
-            GattService service = getService();
-            if (service == null) return null;
-            return service.getAdvManufacturerData();
-        }
-
-        @Override
-        public List<ParcelUuid> getAdvServiceUuids() throws RemoteException {
-            GattService service = getService();
-            if (service == null) return null;
-            return service.getAdvServiceUuids();
-        }
-
-        @Override
-        public void removeAdvManufacturerCodeAndData(int manufacturerCode) throws RemoteException {
-            GattService service = getService();
-            if (service == null) return;
-            service.removeAdvManufacturerCodeAndData(manufacturerCode);
+            service.setAdvData(serverIf, setScanRsp, inclName, inclTxPower,
+                minInterval, maxInterval, appearance, manufacturerData);
         }
     };
-
     /**************************************************************************
      * Callback functions - CLIENT
      *************************************************************************/
-
     void onScanResult(String address, int rssi, byte[] adv_data) {
         if (DBG) Log.d(TAG, "onScanResult() - address=" + address
                     + ", rssi=" + rssi);
-
         List<UUID> remoteUuids = parseUuids(adv_data);
         for (ScanClient client : mScanQueue) {
             if (client.uuids.length > 0) {
@@ -595,10 +435,8 @@ public class GattService extends ProfileService {
                         }
                     }
                 }
-
                 if (matches < client.uuids.length) continue;
             }
-
             if (!client.isServer) {
                 ClientMap.App app = mClientMap.getById(client.appIf);
                 if (app != null) {
@@ -624,7 +462,6 @@ public class GattService extends ProfileService {
             }
         }
     }
-
     void onClientRegistered(int status, int clientIf, long uuidLsb, long uuidMsb)
             throws RemoteException {
         UUID uuid = new UUID(uuidMsb, uuidLsb);
@@ -636,24 +473,20 @@ public class GattService extends ProfileService {
             app.callback.onClientRegistered(status, clientIf);
         }
     }
-
     void onConnected(int clientIf, int connId, int status, String address)
             throws RemoteException  {
         if (DBG) Log.d(TAG, "onConnected() - clientIf=" + clientIf
             + ", connId=" + connId + ", address=" + address);
-
         if (status == 0) mClientMap.addConnection(clientIf, connId, address);
         ClientMap.App app = mClientMap.getById(clientIf);
         if (app != null) {
             app.callback.onClientConnectionState(status, clientIf, true, address);
         }
     }
-
     void onDisconnected(int clientIf, int connId, int status, String address)
             throws RemoteException {
         if (DBG) Log.d(TAG, "onDisconnected() - clientIf=" + clientIf
             + ", connId=" + connId + ", address=" + address);
-
         mClientMap.removeConnection(clientIf, connId);
         mSearchQueue.removeConnId(connId);
         ClientMap.App app = mClientMap.getById(clientIf);
@@ -661,54 +494,43 @@ public class GattService extends ProfileService {
             app.callback.onClientConnectionState(status, clientIf, false, address);
         }
     }
-
     void onSearchCompleted(int connId, int status) throws RemoteException {
         if (DBG) Log.d(TAG, "onSearchCompleted() - connId=" + connId+ ", status=" + status);
         // We got all services, now let's explore characteristics...
         continueSearch(connId, status);
     }
-
     void onSearchResult(int connId, int srvcType,
             int srvcInstId, long srvcUuidLsb, long srvcUuidMsb)
             throws RemoteException {
         UUID uuid = new UUID(srvcUuidMsb, srvcUuidLsb);
         String address = mClientMap.addressByConnId(connId);
-
         if (DBG) Log.d(TAG, "onSearchResult() - address=" + address + ", uuid=" + uuid);
-
         mSearchQueue.add(connId, srvcType, srvcInstId, srvcUuidLsb, srvcUuidMsb);
-
         ClientMap.App app = mClientMap.getByConnId(connId);
         if (app != null) {
             app.callback.onGetService(address, srvcType, srvcInstId,
                                         new ParcelUuid(uuid));
         }
     }
-
     void onGetCharacteristic(int connId, int status, int srvcType,
             int srvcInstId, long srvcUuidLsb, long srvcUuidMsb,
             int charInstId, long charUuidLsb, long charUuidMsb,
             int charProp) throws RemoteException {
-
         UUID srvcUuid = new UUID(srvcUuidMsb, srvcUuidLsb);
         UUID charUuid = new UUID(charUuidMsb, charUuidLsb);
         String address = mClientMap.addressByConnId(connId);
-
         if (DBG) Log.d(TAG, "onGetCharacteristic() - address=" + address
             + ", status=" + status + ", charUuid=" + charUuid + ", prop=" + charProp);
-
         if (status == 0) {
             mSearchQueue.add(connId, srvcType,
                             srvcInstId, srvcUuidLsb, srvcUuidMsb,
                             charInstId, charUuidLsb, charUuidMsb);
-
             ClientMap.App app = mClientMap.getByConnId(connId);
             if (app != null) {
                 app.callback.onGetCharacteristic(address, srvcType,
                             srvcInstId, new ParcelUuid(srvcUuid),
                             charInstId, new ParcelUuid(charUuid), charProp);
             }
-
             // Get next characteristic in the current service
             gattClientGetCharacteristicNative(connId, srvcType,
                                         srvcInstId, srvcUuidLsb, srvcUuidMsb,
@@ -720,20 +542,16 @@ public class GattService extends ProfileService {
                 0,0,0,0);
         }
     }
-
     void onGetDescriptor(int connId, int status, int srvcType,
             int srvcInstId, long srvcUuidLsb, long srvcUuidMsb,
             int charInstId, long charUuidLsb, long charUuidMsb,
             int descrInstId, long descrUuidLsb, long descrUuidMsb) throws RemoteException {
-
         UUID srvcUuid = new UUID(srvcUuidMsb, srvcUuidLsb);
         UUID charUuid = new UUID(charUuidMsb, charUuidLsb);
         UUID descUuid = new UUID(descrUuidMsb, descrUuidLsb);
         String address = mClientMap.addressByConnId(connId);
-
         if (DBG) Log.d(TAG, "onGetDescriptor() - address=" + address
             + ", status=" + status + ", descUuid=" + descUuid);
-
         if (status == 0) {
             ClientMap.App app = mClientMap.getByConnId(connId);
             if (app != null) {
@@ -742,7 +560,6 @@ public class GattService extends ProfileService {
                             charInstId, new ParcelUuid(charUuid),
                             descrInstId, new ParcelUuid(descUuid));
             }
-
             // Get next descriptor for the current characteristic
             gattClientGetDescriptorNative(connId, srvcType,
                                     srvcInstId, srvcUuidLsb, srvcUuidMsb,
@@ -753,7 +570,6 @@ public class GattService extends ProfileService {
             continueSearch(connId, 0);
         }
     }
-
     void onGetIncludedService(int connId, int status, int srvcType,
             int srvcInstId, long srvcUuidLsb, long srvcUuidMsb, int inclSrvcType,
             int inclSrvcInstId, long inclSrvcUuidLsb, long inclSrvcUuidMsb)
@@ -761,11 +577,9 @@ public class GattService extends ProfileService {
         UUID srvcUuid = new UUID(srvcUuidMsb, srvcUuidLsb);
         UUID inclSrvcUuid = new UUID(inclSrvcUuidMsb, inclSrvcUuidLsb);
         String address = mClientMap.addressByConnId(connId);
-
         if (DBG) Log.d(TAG, "onGetIncludedService() - address=" + address
             + ", status=" + status + ", uuid=" + srvcUuid
             + ", inclUuid=" + inclSrvcUuid);
-
         if (status == 0) {
             ClientMap.App app = mClientMap.getByConnId(connId);
             if (app != null) {
@@ -773,7 +587,6 @@ public class GattService extends ProfileService {
                     srvcType, srvcInstId, new ParcelUuid(srvcUuid),
                     inclSrvcType, inclSrvcInstId, new ParcelUuid(inclSrvcUuid));
             }
-
             // Find additional included services
             gattClientGetIncludedServiceNative(connId,
                 srvcType, srvcInstId, srvcUuidLsb, srvcUuidMsb,
@@ -783,29 +596,24 @@ public class GattService extends ProfileService {
             continueSearch(connId, 0);
         }
     }
-
     void onRegisterForNotifications(int connId, int status, int registered, int srvcType,
             int srvcInstId, long srvcUuidLsb, long srvcUuidMsb,
             int charInstId, long charUuidLsb, long charUuidMsb) {
         UUID srvcUuid = new UUID(srvcUuidMsb, srvcUuidLsb);
         UUID charUuid = new UUID(charUuidMsb, charUuidLsb);
         String address = mClientMap.addressByConnId(connId);
-
         if (DBG) Log.d(TAG, "onRegisterForNotifications() - address=" + address
             + ", status=" + status + ", registered=" + registered
             + ", charUuid=" + charUuid);
     }
-
     void onNotify(int connId, String address, int srvcType,
             int srvcInstId, long srvcUuidLsb, long srvcUuidMsb,
             int charInstId, long charUuidLsb, long charUuidMsb,
             boolean isNotify, byte[] data) throws RemoteException {
         UUID srvcUuid = new UUID(srvcUuidMsb, srvcUuidLsb);
         UUID charUuid = new UUID(charUuidMsb, charUuidLsb);
-
         if (DBG) Log.d(TAG, "onNotify() - address=" + address
             + ", charUuid=" + charUuid + ", length=" + data.length);
-
         ClientMap.App app = mClientMap.getByConnId(connId);
         if (app != null) {
             app.callback.onNotify(address, srvcType,
@@ -814,19 +622,15 @@ public class GattService extends ProfileService {
                         data);
         }
     }
-
     void onReadCharacteristic(int connId, int status, int srvcType,
             int srvcInstId, long srvcUuidLsb, long srvcUuidMsb,
             int charInstId, long charUuidLsb, long charUuidMsb,
             int charType, byte[] data) throws RemoteException {
-
         UUID srvcUuid = new UUID(srvcUuidMsb, srvcUuidLsb);
         UUID charUuid = new UUID(charUuidMsb, charUuidLsb);
         String address = mClientMap.addressByConnId(connId);
-
         if (DBG) Log.d(TAG, "onReadCharacteristic() - address=" + address
             + ", status=" + status + ", length=" + data.length);
-
         ClientMap.App app = mClientMap.getByConnId(connId);
         if (app != null) {
             app.callback.onCharacteristicRead(address, status, srvcType,
@@ -834,19 +638,15 @@ public class GattService extends ProfileService {
                         charInstId, new ParcelUuid(charUuid), data);
         }
     }
-
     void onWriteCharacteristic(int connId, int status, int srvcType,
             int srvcInstId, long srvcUuidLsb, long srvcUuidMsb,
             int charInstId, long charUuidLsb, long charUuidMsb)
             throws RemoteException {
-
         UUID srvcUuid = new UUID(srvcUuidMsb, srvcUuidLsb);
         UUID charUuid = new UUID(charUuidMsb, charUuidLsb);
         String address = mClientMap.addressByConnId(connId);
-
         if (DBG) Log.d(TAG, "onWriteCharacteristic() - address=" + address
             + ", status=" + status);
-
         ClientMap.App app = mClientMap.getByConnId(connId);
         if (app != null) {
             app.callback.onCharacteristicWrite(address, status, srvcType,
@@ -854,32 +654,26 @@ public class GattService extends ProfileService {
                         charInstId, new ParcelUuid(charUuid));
         }
     }
-
     void onExecuteCompleted(int connId, int status) throws RemoteException {
         String address = mClientMap.addressByConnId(connId);
         if (DBG) Log.d(TAG, "onExecuteCompleted() - address=" + address
             + ", status=" + status);
-
         ClientMap.App app = mClientMap.getByConnId(connId);
         if (app != null) {
             app.callback.onExecuteWrite(address, status);
         }
     }
-
     void onReadDescriptor(int connId, int status, int srvcType,
             int srvcInstId, long srvcUuidLsb, long srvcUuidMsb,
             int charInstId, long charUuidLsb, long charUuidMsb,
             int descrInstId, long descrUuidLsb, long descrUuidMsb,
             int charType, byte[] data) throws RemoteException {
-
         UUID srvcUuid = new UUID(srvcUuidMsb, srvcUuidLsb);
         UUID charUuid = new UUID(charUuidMsb, charUuidLsb);
         UUID descrUuid = new UUID(descrUuidMsb, descrUuidLsb);
         String address = mClientMap.addressByConnId(connId);
-
         if (DBG) Log.d(TAG, "onReadDescriptor() - address=" + address
             + ", status=" + status + ", length=" + data.length);
-
         ClientMap.App app = mClientMap.getByConnId(connId);
         if (app != null) {
             app.callback.onDescriptorRead(address, status, srvcType,
@@ -888,20 +682,16 @@ public class GattService extends ProfileService {
                         descrInstId, new ParcelUuid(descrUuid), data);
         }
     }
-
     void onWriteDescriptor(int connId, int status, int srvcType,
             int srvcInstId, long srvcUuidLsb, long srvcUuidMsb,
             int charInstId, long charUuidLsb, long charUuidMsb,
             int descrInstId, long descrUuidLsb, long descrUuidMsb) throws RemoteException {
-
         UUID srvcUuid = new UUID(srvcUuidMsb, srvcUuidLsb);
         UUID charUuid = new UUID(charUuidMsb, charUuidLsb);
         UUID descrUuid = new UUID(descrUuidMsb, descrUuidLsb);
         String address = mClientMap.addressByConnId(connId);
-
         if (DBG) Log.d(TAG, "onWriteDescriptor() - address=" + address
             + ", status=" + status);
-
         ClientMap.App app = mClientMap.getByConnId(connId);
         if (app != null) {
             app.callback.onDescriptorWrite(address, status, srvcType,
@@ -910,104 +700,49 @@ public class GattService extends ProfileService {
                         descrInstId, new ParcelUuid(descrUuid));
         }
     }
-
     void onReadRemoteRssi(int clientIf, String address,
                     int rssi, int status) throws RemoteException{
         if (DBG) Log.d(TAG, "onReadRemoteRssi() - clientIf=" + clientIf + " address=" +
                      address + ", rssi=" + rssi + ", status=" + status);
-
         ClientMap.App app = mClientMap.getById(clientIf);
         if (app != null) {
             app.callback.onReadRemoteRssi(address, rssi, status);
         }
     }
-
-    void onAdvertiseCallback(int status, int clientIf) throws RemoteException {
+    void onClientListen(int status, int clientIf)
+            throws RemoteException {
         if (DBG) Log.d(TAG, "onClientListen() status=" + status);
-        synchronized (mLock) {
-            if (DBG) Log.d(TAG, "state" + mAdvertisingState);
-            // Invalid advertising state
-            if (mAdvertisingState == BluetoothAdapter.STATE_ADVERTISE_STARTED ||
-                    mAdvertisingState == BluetoothAdapter.STATE_ADVERTISE_STOPPED) {
-                Log.e(TAG, "invalid callback state " + mAdvertisingState);
-                return;
-            }
-
-            // Force stop advertising, no callback.
-            if (mAdvertisingState == BluetoothAdapter.STATE_ADVERTISE_FORCE_STOPPING) {
-                mAdvertisingState = BluetoothAdapter.STATE_ADVERTISE_STOPPED;
-                mAdvertisingClientIf = 0;
-                sendBroadcast(new Intent(
-                        BluetoothAdapter.ACTION_BLUETOOTH_ADVERTISING_STOPPED));
-                return;
-            }
-
-            if (mAdvertisingState == BluetoothAdapter.STATE_ADVERTISE_STARTING) {
-                if (status == 0) {
-                    mAdvertisingClientIf = clientIf;
-                    mAdvertisingState = BluetoothAdapter.STATE_ADVERTISE_STARTED;
-                    sendBroadcast(new Intent(
-                            BluetoothAdapter.ACTION_BLUETOOTH_ADVERTISING_STARTED));
-                } else {
-                    mAdvertisingState = BluetoothAdapter.STATE_ADVERTISE_STOPPED;
-                }
-            } else if (mAdvertisingState == BluetoothAdapter.STATE_ADVERTISE_STOPPING) {
-                if (status == 0) {
-                    mAdvertisingState = BluetoothAdapter.STATE_ADVERTISE_STOPPED;
-                    sendBroadcast(new Intent(
-                            BluetoothAdapter.ACTION_BLUETOOTH_ADVERTISING_STOPPED));
-                    mAdvertisingClientIf = 0;
-                } else {
-                    mAdvertisingState = BluetoothAdapter.STATE_ADVERTISE_STARTED;
-                }
-            }
-        }
         ClientMap.App app = mClientMap.getById(clientIf);
-        if (app == null || app.callback == null) {
-            Log.e(TAG, "app or callback is null");
-            return;
-        }
-        app.callback.onAdvertiseStateChange(mAdvertisingState, status);
+        if (app == null) return;
+        app.callback.onListen(status);
     }
-
     /**************************************************************************
      * GATT Service functions - Shared CLIENT/SERVER
      *************************************************************************/
-
     List<BluetoothDevice> getDevicesMatchingConnectionStates(int[] states) {
         enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
-
         final int DEVICE_TYPE_BREDR = 0x1;
-
         Map<BluetoothDevice, Integer> deviceStates = new HashMap<BluetoothDevice,
                                                                  Integer>();
-
         // Add paired LE devices
-
         Set<BluetoothDevice> bondedDevices = mAdapter.getBondedDevices();
         for (BluetoothDevice device : bondedDevices) {
             if (getDeviceType(device) != DEVICE_TYPE_BREDR) {
                 deviceStates.put(device, BluetoothProfile.STATE_DISCONNECTED);
             }
         }
-
         // Add connected deviceStates
-
         Set<String> connectedDevices = new HashSet<String>();
         connectedDevices.addAll(mClientMap.getConnectedDevices());
         connectedDevices.addAll(mServerMap.getConnectedDevices());
-
         for (String address : connectedDevices ) {
             BluetoothDevice device = mAdapter.getRemoteDevice(address);
             if (device != null) {
                 deviceStates.put(device, BluetoothProfile.STATE_CONNECTED);
             }
         }
-
         // Create matching device sub-set
-
         List<BluetoothDevice> deviceList = new ArrayList<BluetoothDevice>();
-
         for (Map.Entry<BluetoothDevice, Integer> entry : deviceStates.entrySet()) {
             for(int state : states) {
                 if (entry.getValue() == state) {
@@ -1015,271 +750,93 @@ public class GattService extends ProfileService {
                 }
             }
         }
-
         return deviceList;
     }
-
     void startScan(int appIf, boolean isServer) {
         enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, "Need BLUETOOTH_ADMIN permission");
-
         if (DBG) Log.d(TAG, "startScan() - queue=" + mScanQueue.size());
-
-        if (getScanClient(appIf, isServer) == null &&
-            LeScanRequestArbitrator.instance().RequestLeScan(LeScanRequestArbitrator.LE_NORMAL_SCAN_TYPE)) {
+        if (getScanClient(appIf, isServer) == null) {
             if (DBG) Log.d(TAG, "startScan() - adding client=" + appIf);
             mScanQueue.add(new ScanClient(appIf, isServer));
-            if(mScanQueue.size()==1)//start scan only if it is not already started
-            {
-                gattClientScanNative(appIf, true);
-            }
-            else
-            {
-                Log.d(TAG, "startScan scan already in progress for appifs-queue=" + mScanQueue.size());
-            }
         }
+        gattClientScanNative(appIf, true);
     }
-
     void startScanWithUuids(int appIf, boolean isServer, UUID[] uuids) {
         enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, "Need BLUETOOTH_ADMIN permission");
-
         if (DBG) Log.d(TAG, "startScanWithUuids() - queue=" + mScanQueue.size());
-
-        if (getScanClient(appIf, isServer) == null &&
-            LeScanRequestArbitrator.instance().RequestLeScan(LeScanRequestArbitrator.LE_NORMAL_SCAN_TYPE)) {
+        if (getScanClient(appIf, isServer) == null) {
             if (DBG) Log.d(TAG, "startScanWithUuids() - adding client=" + appIf);
             mScanQueue.add(new ScanClient(appIf, isServer, uuids));
-            if(mScanQueue.size()==1)//start scan only if it is not already started
-            {
-                gattClientScanNative(appIf, true);
-            }
-            else
-            {
-                Log.d(TAG, "startScanWithUuids scan already in progress for appifs-queue=" + mScanQueue.size());
-            }
         }
+        gattClientScanNative(appIf, true);
     }
-
     void stopScan(int appIf, boolean isServer) {
         enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH_ADMIN permission");
-
         if (DBG) Log.d(TAG, "stopScan() - queue=" + mScanQueue.size());
-        if (getScanClient(appIf, isServer) != null) {
-            LeScanRequestArbitrator.instance().StopLeScan(LeScanRequestArbitrator.LE_NORMAL_SCAN_TYPE);
-            removeScanClient(appIf, isServer);
-        }
-
+        removeScanClient(appIf, isServer);
         if (mScanQueue.isEmpty()) {
             if (DBG) Log.d(TAG, "stopScan() - queue empty; stopping scan");
             gattClientScanNative(appIf, false);
         }
     }
-
     /**************************************************************************
      * GATT Service functions - CLIENT
      *************************************************************************/
-
     void registerClient(UUID uuid, IBluetoothGattCallback callback) {
         enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
-
         if (DBG) Log.d(TAG, "registerClient() - UUID=" + uuid);
         mClientMap.add(uuid, callback);
         gattClientRegisterAppNative(uuid.getLeastSignificantBits(),
                                     uuid.getMostSignificantBits());
     }
-
     void unregisterClient(int clientIf) {
         enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
-
         if (DBG) Log.d(TAG, "unregisterClient() - clientIf=" + clientIf);
         mClientMap.remove(clientIf);
         gattClientUnregisterAppNative(clientIf);
     }
-
     void clientConnect(int clientIf, String address, boolean isDirect) {
         enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
-
         if (DBG) Log.d(TAG, "clientConnect() - address=" + address + ", isDirect=" + isDirect);
         gattClientConnectNative(clientIf, address, isDirect);
     }
-
     void clientDisconnect(int clientIf, String address) {
         enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
-
         Integer connId = mClientMap.connIdByAddress(clientIf, address);
         if (DBG) Log.d(TAG, "clientDisconnect() - address=" + address + ", connId=" + connId);
-
         gattClientDisconnectNative(clientIf, address, connId != null ? connId : 0);
     }
-
-    synchronized boolean setAdvServiceData(byte[] serviceData) {
-        enforcePrivilegedPermission();
-        if (serviceData == null) return false;
-        // Calculate how many more bytes are needed for advertising service data field.
-        int extraBytes = (mServiceData == null) ?
-                FIELD_OVERHEAD_BYTES + serviceData.length :
-                    serviceData.length - mServiceData.length;
-        if (getAvailableSize() < extraBytes) {
-            Log.e(TAG, "cannot set service data, available size " + getAvailableSize());
-            return false;
-        }
-        mServiceData = serviceData;
-        return true;
+    void clientListen(int clientIf, boolean start) {
+        if (DBG) Log.d(TAG, "clientListen() - start=" + start);
+        gattClientListenNative(clientIf, start);
     }
-
-    byte[] getAdvServiceData() {
-        enforcePrivilegedPermission();
-        return mServiceData;
-    }
-
-    synchronized boolean setAdvManufacturerCodeAndData(
-        int manufacturerCode, byte[] manufacturerData) {
-        enforcePrivilegedPermission();
-        if (manufacturerCode <= 0 || manufacturerData == null) {
-            return false;
-        }
-        if (mManufacturerCode > 0 && mManufacturerData != null) {
-            Log.e(TAG, "manufacture data is already set");
-            return false;
-        }
-        if (getAvailableSize() <
-            FIELD_OVERHEAD_BYTES + manufacturerData.length) {
-            Log.e(TAG, "cannot set manu data, available size " + getAvailableSize());
-            return false;
-        }
-        this.mManufacturerCode = manufacturerCode;
-        this.mManufacturerData = manufacturerData;
-        return true;
-    }
-
-    void removeAdvManufacturerCodeAndData(int manufacturerCode) {
-        enforcePrivilegedPermission();
-        if (mManufacturerCode != manufacturerCode) {
-            return;
-        }
-        mManufacturerCode = -1;
-        mManufacturerData = new byte[0];
-    }
-
-    byte[] getAdvManufacturerData() {
-        enforcePrivilegedPermission();
-        return mManufacturerData;
-    }
-
-    synchronized List<ParcelUuid> getAdvServiceUuids() {
-        enforcePrivilegedPermission();;
-        boolean fullUuidFound = false;
-        List<ParcelUuid> serviceUuids = new ArrayList<ParcelUuid>();
-        for (HandleMap.Entry entry : mHandleMap.mEntries) {
-            if (entry.advertisePreferred) {
-                ParcelUuid parcelUuid = new ParcelUuid(entry.uuid);
-                if (BluetoothUuid.isShortUuid(parcelUuid)) {
-                    serviceUuids.add(parcelUuid);
-                } else {
-                    // Allow at most one 128 bit service uuid to be advertised.
-                    if (!fullUuidFound) {
-                      fullUuidFound = true;
-                      serviceUuids.add(parcelUuid);
-                    }
-                }
-            }
-        }
-        return serviceUuids;
-    }
-
-    boolean isAdvertising() {
-        enforcePrivilegedPermission();
-        return mAdvertisingState != BluetoothAdapter.STATE_ADVERTISE_STOPPED;
-    }
-
-    void startAdvertising(int clientIf) {
-        enforcePrivilegedPermission();
-        if (DBG) Log.d(TAG, "start advertising for app - " + clientIf);
-        List<ParcelUuid> serviceUuids = getAdvServiceUuids();
-        int advertisingServiceUuidLength = serviceUuids == null ? 0 : serviceUuids.size();
-
-        // Note according to Bluetooth Spec Version 4.0, for advertising and scan response data
-        // "all numerical multi-byte entities and values shall use little-endian byte order".
-        ByteBuffer advertisingUuidBytes = ByteBuffer.allocate(advertisingServiceUuidLength * 16)
-                .order(ByteOrder.LITTLE_ENDIAN);
-        for (ParcelUuid parcelUuid : serviceUuids) {
-            UUID uuid = parcelUuid.getUuid();
-            // Least signifcant bits first as the advertising uuid should be in little-endian.
-            advertisingUuidBytes.putLong(uuid.getLeastSignificantBits())
-                    .putLong(uuid.getMostSignificantBits());
-        }
-
-        // Set advertising data.
-        gattSetAdvDataNative(clientIf,
-                false,  // not scan response data
-                false,  // no device name
-                false,  // no tx power included
-                DEFAULT_SCAN_INTERVAL_MILLIS,
-                DEFAULT_SCAN_INTERVAL_MILLIS,
-                0,  // no appearance limit
-                mManufacturerData,
-                mServiceData,
-                advertisingUuidBytes.array());
-
-        // Start advertising if advertising is not already started.
-        if (!isAdvertising()) {
-            gattAdvertiseNative(clientIf, true);
-            mAdvertisingClientIf = clientIf;
-            mAdvertisingState = BluetoothAdapter.STATE_ADVERTISE_STARTING;
-        }
-    }
-
-    void stopAdvertising() {
-        stopAdvertising(false);
-    }
-
-    void stopAdvertising(boolean forceStop) {
-        enforcePrivilegedPermission();
-        gattAdvertiseNative(mAdvertisingClientIf, false);
-        synchronized (mLock) {
-            if (forceStop) {
-                mAdvertisingState = BluetoothAdapter.STATE_ADVERTISE_FORCE_STOPPING;
-            } else {
-                mAdvertisingState = BluetoothAdapter.STATE_ADVERTISE_STOPPING;
-            }
-        }
-    }
-
     List<String> getConnectedDevices() {
         enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
-
         Set<String> connectedDevAddress = new HashSet<String>();
         connectedDevAddress.addAll(mClientMap.getConnectedDevices());
         connectedDevAddress.addAll(mServerMap.getConnectedDevices());
         List<String> connectedDeviceList = new ArrayList<String>(connectedDevAddress);
         return connectedDeviceList;
     }
-
     void refreshDevice(int clientIf, String address) {
         enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
-
         if (DBG) Log.d(TAG, "refreshDevice() - address=" + address);
         gattClientRefreshNative(clientIf, address);
     }
-
     void discoverServices(int clientIf, String address) {
         enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
-
         Integer connId = mClientMap.connIdByAddress(clientIf, address);
         if (DBG) Log.d(TAG, "discoverServices() - address=" + address + ", connId=" + connId);
-
         if (connId != null)
             gattClientSearchServiceNative(connId, true, 0, 0);
         else
             Log.e(TAG, "discoverServices() - No connection for " + address + "...");
     }
-
     void readCharacteristic(int clientIf, String address, int srvcType,
                             int srvcInstanceId, UUID srvcUuid,
                             int charInstanceId, UUID charUuid, int authReq) {
         enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
-
         if (DBG) Log.d(TAG, "readCharacteristic() - address=" + address);
-
         Integer connId = mClientMap.connIdByAddress(clientIf, address);
         if (connId != null)
             gattClientReadCharacteristicNative(connId, srvcType,
@@ -1290,17 +847,13 @@ public class GattService extends ProfileService {
         else
             Log.e(TAG, "readCharacteristic() - No connection for " + address + "...");
     }
-
     void writeCharacteristic(int clientIf, String address, int srvcType,
                              int srvcInstanceId, UUID srvcUuid,
                              int charInstanceId, UUID charUuid, int writeType,
                              int authReq, byte[] value) {
         enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
-
         if (DBG) Log.d(TAG, "writeCharacteristic() - address=" + address);
-
         if (mReliableQueue.contains(address)) writeType = 3; // Prepared write
-
         Integer connId = mClientMap.connIdByAddress(clientIf, address);
         if (connId != null)
             gattClientWriteCharacteristicNative(connId, srvcType,
@@ -1311,16 +864,13 @@ public class GattService extends ProfileService {
         else
             Log.e(TAG, "writeCharacteristic() - No connection for " + address + "...");
     }
-
     void readDescriptor(int clientIf, String address, int srvcType,
                             int srvcInstanceId, UUID srvcUuid,
                             int charInstanceId, UUID charUuid,
                             int descrInstanceId, UUID descrUuid,
                             int authReq) {
         enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
-
         if (DBG) Log.d(TAG, "readDescriptor() - address=" + address);
-
         Integer connId = mClientMap.connIdByAddress(clientIf, address);
         if (connId != null)
             gattClientReadDescriptorNative(connId, srvcType,
@@ -1334,16 +884,13 @@ public class GattService extends ProfileService {
         else
             Log.e(TAG, "readDescriptor() - No connection for " + address + "...");
     };
-
     void writeDescriptor(int clientIf, String address, int srvcType,
                             int srvcInstanceId, UUID srvcUuid,
                             int charInstanceId, UUID charUuid,
                             int descrInstanceId, UUID descrUuid,
                             int writeType, int authReq, byte[] value) {
         enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
-
         if (DBG) Log.d(TAG, "writeDescriptor() - address=" + address);
-
         Integer connId = mClientMap.connIdByAddress(clientIf, address);
         if (connId != null)
             gattClientWriteDescriptorNative(connId, srvcType,
@@ -1357,33 +904,25 @@ public class GattService extends ProfileService {
         else
             Log.e(TAG, "writeDescriptor() - No connection for " + address + "...");
     }
-
     void beginReliableWrite(int clientIf, String address) {
         enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
-
         if (DBG) Log.d(TAG, "beginReliableWrite() - address=" + address);
         mReliableQueue.add(address);
     }
-
     void endReliableWrite(int clientIf, String address, boolean execute) {
         enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
-
         if (DBG) Log.d(TAG, "endReliableWrite() - address=" + address
                                 + " execute: " + execute);
         mReliableQueue.remove(address);
-
         Integer connId = mClientMap.connIdByAddress(clientIf, address);
         if (connId != null) gattClientExecuteWriteNative(connId, execute);
     }
-
     void registerForNotification(int clientIf, String address, int srvcType,
                 int srvcInstanceId, UUID srvcUuid,
                 int charInstanceId, UUID charUuid,
                 boolean enable) {
         enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
-
         if (DBG) Log.d(TAG, "registerForNotification() - address=" + address + " enable: " + enable);
-
         Integer connId = mClientMap.connIdByAddress(clientIf, address);
         if (connId != null) {
             gattClientRegisterForNotificationsNative(clientIf, address,
@@ -1395,21 +934,24 @@ public class GattService extends ProfileService {
             Log.e(TAG, "registerForNotification() - No connection for " + address + "...");
         }
     }
-
     void readRemoteRssi(int clientIf, String address) {
         enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
-
         if (DBG) Log.d(TAG, "readRemoteRssi() - address=" + address);
         gattClientReadRemoteRssiNative(clientIf, address);
     }
-
+    void setAdvData(int serverIf, boolean setScanRsp, boolean inclName,
+                boolean inclTxPower, int minInterval, int maxInterval,
+                int appearance, byte[] manufacturerData) {
+        if (DBG) Log.d(TAG, "setAdvData() - setScanRsp=" + setScanRsp);
+        if (minInterval == 0) maxInterval = 0;
+        gattSetAdvDataNative(serverIf, setScanRsp, inclName, inclTxPower,
+            minInterval, maxInterval, appearance, manufacturerData);
+    }
     /**************************************************************************
      * Callback functions - SERVER
      *************************************************************************/
-
     void onServerRegistered(int status, int serverIf, long uuidLsb, long uuidMsb)
             throws RemoteException {
-
         UUID uuid = new UUID(uuidMsb, uuidLsb);
         if (DBG) Log.d(TAG, "onServerRegistered() - UUID=" + uuid + ", serverIf=" + serverIf);
         ServerMap.App app = mServerMap.getByUuid(uuid);
@@ -1419,28 +961,22 @@ public class GattService extends ProfileService {
             app.callback.onServerRegistered(status, serverIf);
         }
     }
-
     void onServiceAdded(int status, int serverIf, int srvcType, int srvcInstId,
                         long srvcUuidLsb, long srvcUuidMsb, int srvcHandle)
                         throws RemoteException {
         UUID uuid = new UUID(srvcUuidMsb, srvcUuidLsb);
         if (DBG) Log.d(TAG, "onServiceAdded() UUID=" + uuid + ", status=" + status
             + ", handle=" + srvcHandle);
-        if (status == 0) {
-            mHandleMap.addService(serverIf, srvcHandle, uuid, srvcType, srvcInstId,
-                mAdvertisingServiceUuids.remove(uuid));
-        }
-
+        if (status == 0)
+            mHandleMap.addService(serverIf, srvcHandle, uuid, srvcType, srvcInstId);
         continueServiceDeclaration(serverIf, status, srvcHandle);
     }
-
     void onIncludedServiceAdded(int status, int serverIf, int srvcHandle,
                                 int includedSrvcHandle) throws RemoteException {
         if (DBG) Log.d(TAG, "onIncludedServiceAdded() status=" + status
             + ", service=" + srvcHandle + ", included=" + includedSrvcHandle);
         continueServiceDeclaration(serverIf, status, srvcHandle);
     }
-
     void onCharacteristicAdded(int status, int serverIf,
                                long charUuidLsb, long charUuidMsb,
                                int srvcHandle, int charHandle)
@@ -1452,7 +988,6 @@ public class GattService extends ProfileService {
             mHandleMap.addCharacteristic(serverIf, charHandle, uuid, srvcHandle);
         continueServiceDeclaration(serverIf, status, srvcHandle);
     }
-
     void onDescriptorAdded(int status, int serverIf,
                            long descrUuidLsb, long descrUuidMsb,
                            int srvcHandle, int descrHandle)
@@ -1464,7 +999,6 @@ public class GattService extends ProfileService {
             mHandleMap.addDescriptor(serverIf, descrHandle, uuid, srvcHandle);
         continueServiceDeclaration(serverIf, status, srvcHandle);
     }
-
     void onServiceStarted(int status, int serverIf, int srvcHandle)
             throws RemoteException {
         if (DBG) Log.d(TAG, "onServiceStarted() srvcHandle=" + srvcHandle
@@ -1472,7 +1006,6 @@ public class GattService extends ProfileService {
         if (status == 0)
             mHandleMap.setStarted(serverIf, srvcHandle, true);
     }
-
     void onServiceStopped(int status, int serverIf, int srvcHandle)
             throws RemoteException {
         if (DBG) Log.d(TAG, "onServiceStopped() srvcHandle=" + srvcHandle
@@ -1481,49 +1014,37 @@ public class GattService extends ProfileService {
             mHandleMap.setStarted(serverIf, srvcHandle, false);
         stopNextService(serverIf, status);
     }
-
     void onServiceDeleted(int status, int serverIf, int srvcHandle) {
         if (DBG) Log.d(TAG, "onServiceDeleted() srvcHandle=" + srvcHandle
             + ", status=" + status);
         mHandleMap.deleteService(serverIf, srvcHandle);
     }
-
     void onClientConnected(String address, boolean connected, int connId, int serverIf)
             throws RemoteException {
-
         if (DBG) Log.d(TAG, "onConnected() connId=" + connId
             + ", address=" + address + ", connected=" + connected);
-
         ServerMap.App app = mServerMap.getById(serverIf);
         if (app == null) return;
-
         if (connected) {
             mServerMap.addConnection(serverIf, connId, address);
         } else {
             mServerMap.removeConnection(serverIf, connId);
         }
-
         app.callback.onServerConnectionState((byte)0, serverIf, connected, address);
     }
-
     void onAttributeRead(String address, int connId, int transId,
                             int attrHandle, int offset, boolean isLong)
                             throws RemoteException {
         if (DBG) Log.d(TAG, "onAttributeRead() connId=" + connId
             + ", address=" + address + ", handle=" + attrHandle
             + ", requestId=" + transId + ", offset=" + offset);
-
         HandleMap.Entry entry = mHandleMap.getByHandle(attrHandle);
         if (entry == null) return;
-
         if (DBG) Log.d(TAG, "onAttributeRead() UUID=" + entry.uuid
             + ", serverIf=" + entry.serverIf + ", type=" + entry.type);
-
         mHandleMap.addRequest(transId, attrHandle);
-
         ServerMap.App app = mServerMap.getById(entry.serverIf);
         if (app == null) return;
-
         switch(entry.type) {
             case HandleMap.TYPE_CHARACTERISTIC:
             {
@@ -1534,7 +1055,6 @@ public class GattService extends ProfileService {
                     new ParcelUuid(entry.uuid));
                 break;
             }
-
             case HandleMap.TYPE_DESCRIPTOR:
             {
                 HandleMap.Entry serviceEntry = mHandleMap.getByHandle(entry.serviceHandle);
@@ -1546,13 +1066,11 @@ public class GattService extends ProfileService {
                     new ParcelUuid(entry.uuid));
                 break;
             }
-
             default:
                 Log.e(TAG, "onAttributeRead() - Requested unknown attribute type.");
                 break;
         }
     }
-
     void onAttributeWrite(String address, int connId, int transId,
                             int attrHandle, int offset, int length,
                             boolean needRsp, boolean isPrep,
@@ -1562,18 +1080,13 @@ public class GattService extends ProfileService {
             + ", address=" + address + ", handle=" + attrHandle
             + ", requestId=" + transId + ", isPrep=" + isPrep
             + ", offset=" + offset);
-
         HandleMap.Entry entry = mHandleMap.getByHandle(attrHandle);
         if (entry == null) return;
-
         if (DBG) Log.d(TAG, "onAttributeWrite() UUID=" + entry.uuid
             + ", serverIf=" + entry.serverIf + ", type=" + entry.type);
-
         mHandleMap.addRequest(transId, attrHandle);
-
         ServerMap.App app = mServerMap.getById(entry.serverIf);
         if (app == null) return;
-
         switch(entry.type) {
             case HandleMap.TYPE_CHARACTERISTIC:
             {
@@ -1585,7 +1098,6 @@ public class GattService extends ProfileService {
                             new ParcelUuid(entry.uuid), data);
                 break;
             }
-
             case HandleMap.TYPE_DESCRIPTOR:
             {
                 HandleMap.Entry serviceEntry = mHandleMap.getByHandle(entry.serviceHandle);
@@ -1598,106 +1110,77 @@ public class GattService extends ProfileService {
                             new ParcelUuid(entry.uuid), data);
                 break;
             }
-
             default:
                 Log.e(TAG, "onAttributeWrite() - Requested unknown attribute type.");
                 break;
         }
     }
-
     void onExecuteWrite(String address, int connId, int transId, int execWrite)
             throws RemoteException {
         if (DBG) Log.d(TAG, "onExecuteWrite() connId=" + connId
             + ", address=" + address + ", transId=" + transId);
-
         ServerMap.App app = mServerMap.getByConnId(connId);
         if (app == null) return;
-
         app.callback.onExecuteWrite(address, transId, execWrite == 1);
     }
-
     void onResponseSendCompleted(int status, int attrHandle) {
         if (DBG) Log.d(TAG, "onResponseSendCompleted() handle=" + attrHandle);
     }
-
     /**************************************************************************
      * GATT Service functions - SERVER
      *************************************************************************/
-
     void registerServer(UUID uuid, IBluetoothGattServerCallback callback) {
         enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
-
         if (DBG) Log.d(TAG, "registerServer() - UUID=" + uuid);
         mServerMap.add(uuid, callback);
         gattServerRegisterAppNative(uuid.getLeastSignificantBits(),
                                     uuid.getMostSignificantBits());
     }
-
     void unregisterServer(int serverIf) {
         enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
-
         if (DBG) Log.d(TAG, "unregisterServer() - serverIf=" + serverIf);
-
         deleteServices(serverIf);
-
         mServerMap.remove(serverIf);
         gattServerUnregisterAppNative(serverIf);
     }
-
     void serverConnect(int serverIf, String address, boolean isDirect) {
         enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
-
         if (DBG) Log.d(TAG, "serverConnect() - address=" + address);
         gattServerConnectNative(serverIf, address, isDirect);
     }
-
     void serverDisconnect(int serverIf, String address) {
         enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
-
         Integer connId = mServerMap.connIdByAddress(serverIf, address);
         if (DBG) Log.d(TAG, "serverDisconnect() - address=" + address + ", connId=" + connId);
-
         gattServerDisconnectNative(serverIf, address, connId != null ? connId : 0);
     }
-
     void beginServiceDeclaration(int serverIf, int srvcType, int srvcInstanceId,
-                                 int minHandles, UUID srvcUuid, boolean advertisePreferred) {
+                                 int minHandles, UUID srvcUuid) {
         enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
-
         if (DBG) Log.d(TAG, "beginServiceDeclaration() - uuid=" + srvcUuid);
         ServiceDeclaration serviceDeclaration = addDeclaration();
-        serviceDeclaration.addService(srvcUuid, srvcType, srvcInstanceId, minHandles,
-            advertisePreferred);
+        serviceDeclaration.addService(srvcUuid, srvcType, srvcInstanceId, minHandles);
     }
-
     void addIncludedService(int serverIf, int srvcType, int srvcInstanceId,
                             UUID srvcUuid) {
         enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
-
         if (DBG) Log.d(TAG, "addIncludedService() - uuid=" + srvcUuid);
         getActiveDeclaration().addIncludedService(srvcUuid, srvcType, srvcInstanceId);
     }
-
     void addCharacteristic(int serverIf, UUID charUuid, int properties,
                            int permissions) {
         enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
-
         if (DBG) Log.d(TAG, "addCharacteristic() - uuid=" + charUuid);
         getActiveDeclaration().addCharacteristic(charUuid, properties, permissions);
     }
-
     void addDescriptor(int serverIf, UUID descUuid, int permissions) {
         enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
-
         if (DBG) Log.d(TAG, "addDescriptor() - uuid=" + descUuid);
         getActiveDeclaration().addDescriptor(descUuid, permissions);
     }
-
     void endServiceDeclaration(int serverIf) {
         enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
-
         if (DBG) Log.d(TAG, "endServiceDeclaration()");
-
         if (getActiveDeclaration() == getPendingDeclaration()) {
             try {
                 continueServiceDeclaration(serverIf, (byte)0, 0);
@@ -1706,117 +1189,61 @@ public class GattService extends ProfileService {
             }
         }
     }
-
     void removeService(int serverIf, int srvcType,
                   int srvcInstanceId, UUID srvcUuid) {
         enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
-
         if (DBG) Log.d(TAG, "removeService() - uuid=" + srvcUuid);
-
         int srvcHandle = mHandleMap.getServiceHandle(srvcUuid, srvcType, srvcInstanceId);
         if (srvcHandle == 0) return;
         gattServerDeleteServiceNative(serverIf, srvcHandle);
     }
-
     void clearServices(int serverIf) {
         enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
-
         if (DBG) Log.d(TAG, "clearServices()");
         deleteServices(serverIf);
     }
-
     void sendResponse(int serverIf, String address, int requestId,
                       int status, int offset, byte[] value) {
         enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
-
         if (DBG) Log.d(TAG, "sendResponse() - address=" + address);
-
         int handle = 0;
         HandleMap.Entry entry = mHandleMap.getByRequestId(requestId);
         if (entry != null) handle = entry.handle;
-
         int connId = mServerMap.connIdByAddress(serverIf, address);
         gattServerSendResponseNative(serverIf, connId, requestId, (byte)status,
                                      handle, offset, value, (byte)0);
         mHandleMap.deleteRequest(requestId);
     }
-
     void sendNotification(int serverIf, String address, int srvcType,
                                  int srvcInstanceId, UUID srvcUuid,
                                  int charInstanceId, UUID charUuid,
                                  boolean confirm, byte[] value) {
         enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
-
         if (DBG) Log.d(TAG, "sendNotification() - address=" + address);
-
         int srvcHandle = mHandleMap.getServiceHandle(srvcUuid, srvcType, srvcInstanceId);
         if (srvcHandle == 0) return;
-
         int charHandle = mHandleMap.getCharacteristicHandle(srvcHandle, charUuid, charInstanceId);
         if (charHandle == 0) return;
-
         int connId = mServerMap.connIdByAddress(serverIf, address);
         if (connId == 0) return;
-
         if (confirm) {
             gattServerSendIndicationNative(serverIf, charHandle, connId, value);
         } else {
             gattServerSendNotificationNative(serverIf, charHandle, connId, value);
         }
     }
-
     /**************************************************************************
      * Private functions
      *************************************************************************/
-
     private int getDeviceType(BluetoothDevice device) {
         int type = gattClientGetDeviceTypeNative(device.getAddress());
         if (DBG) Log.d(TAG, "getDeviceType() - device=" + device
             + ", type=" + type);
         return type;
     }
-
-    private synchronized int getAvailableSize() {
-        enforcePrivilegedPermission();
-        int availableSize = ADVERTISING_PACKET_MAX_BYTES - ADVERTISING_FLAGS_BYTES;
-
-        for (ParcelUuid parcelUuid : getAdvServiceUuids()) {
-            if (BluetoothUuid.isShortUuid(parcelUuid)) {
-                availableSize -= FIELD_OVERHEAD_BYTES + SHORT_UUID_BYTES;
-            } else {
-                availableSize -= FIELD_OVERHEAD_BYTES + FULL_UUID_BYTES;
-            }
-        }
-        if (mManufacturerCode > 0 && mManufacturerData != null) {
-            availableSize -= (FIELD_OVERHEAD_BYTES + mManufacturerData.length);
-        }
-        if (mServiceData != null) {
-            availableSize -= (FIELD_OVERHEAD_BYTES + mServiceData.length);
-        }
-        return availableSize;
-    }
-
-    // Enforce caller has BLUETOOTH_PRIVILEGED permission. A {@link SecurityException} will be
-    // thrown if the caller app does not have BLUETOOTH_PRIVILEGED permission.
-    private void enforcePrivilegedPermission() {
-        enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED,
-            "Need BLUETOOTH_PRIVILEGED permission");
-    }
-
     private void continueSearch(int connId, int status) throws RemoteException {
-        Log.d(TAG, "continueSearch() - connid=" + connId + ", status=" + status);
-
-        if(mSearchQueue.isEmpty())
-            Log.d(TAG,"Queue is completely empty");
-        if(mSearchQueue.isEmpty(connId))
-            Log.d(TAG,"continueSearch():Queue is empty for connid=" + connId);
-        if (status == 0 && !mSearchQueue.isEmpty(connId)) {
-            SearchQueue.Entry svc = mSearchQueue.pop(connId);
-
-            //verify once that the popped value is correct
-            if(svc.connId!=connId)
-                Log.d(TAG,"continueSearch(): connid of popped value not matching: input=" + connId + "and popped="+svc.connId);
-
+        if (status == 0 && !mSearchQueue.isEmpty()) {
+            SearchQueue.Entry svc = mSearchQueue.pop();
             if (svc.charUuidLsb == 0) {
                 // Characteristic is up next
                 gattClientGetCharacteristicNative(svc.connId, svc.srvcType,
@@ -1830,51 +1257,40 @@ public class GattService extends ProfileService {
         } else {
             ClientMap.App app = mClientMap.getByConnId(connId);
             if (app != null) {
-                Log.d(TAG,"continueSearch(): calling searchcomplete in frameworks");
                 app.callback.onSearchComplete(mClientMap.addressByConnId(connId), status);
             }
         }
     }
-
     private void continueServiceDeclaration(int serverIf, int status, int srvcHandle) throws RemoteException {
         if (mServiceDeclarations.size() == 0) return;
         if (DBG) Log.d(TAG, "continueServiceDeclaration() - srvcHandle=" + srvcHandle);
-
         boolean finished = false;
-
         ServiceDeclaration.Entry entry = null;
         if (status == 0)
             entry = getPendingDeclaration().getNext();
-
         if (entry != null) {
             if (DBG) Log.d(TAG, "continueServiceDeclaration() - next entry type="
                 + entry.type);
             switch(entry.type) {
                 case ServiceDeclaration.TYPE_SERVICE:
-                    if (entry.advertisePreferred) {
-                        mAdvertisingServiceUuids.add(entry.uuid);
-                    }
                     gattServerAddServiceNative(serverIf, entry.serviceType,
                         entry.instance,
                         entry.uuid.getLeastSignificantBits(),
                         entry.uuid.getMostSignificantBits(),
                         getPendingDeclaration().getNumHandles());
                     break;
-
                 case ServiceDeclaration.TYPE_CHARACTERISTIC:
                     gattServerAddCharacteristicNative(serverIf, srvcHandle,
                         entry.uuid.getLeastSignificantBits(),
                         entry.uuid.getMostSignificantBits(),
                         entry.properties, entry.permissions);
                     break;
-
                 case ServiceDeclaration.TYPE_DESCRIPTOR:
                     gattServerAddDescriptorNative(serverIf, srvcHandle,
                         entry.uuid.getLeastSignificantBits(),
                         entry.uuid.getMostSignificantBits(),
                         entry.permissions);
                     break;
-
                 case ServiceDeclaration.TYPE_INCLUDED_SERVICE:
                 {
                     int inclSrvc = mHandleMap.getServiceHandle(entry.uuid,
@@ -1892,13 +1308,11 @@ public class GattService extends ProfileService {
             gattServerStartServiceNative(serverIf, srvcHandle, (byte)2 /*BREDR/LE*/);
             finished = true;
         }
-
         if (finished) {
             if (DBG) Log.d(TAG, "continueServiceDeclaration() - completed.");
             ServerMap.App app = mServerMap.getById(serverIf);
             if (app != null) {
                 HandleMap.Entry serviceEntry = mHandleMap.getByHandle(srvcHandle);
-
                 if (serviceEntry != null) {
                     app.callback.onServiceAdded(status, serviceEntry.serviceType,
                         serviceEntry.instance, new ParcelUuid(serviceEntry.uuid));
@@ -1907,17 +1321,14 @@ public class GattService extends ProfileService {
                 }
             }
             removePendingDeclaration();
-
             if (getPendingDeclaration() != null) {
                 continueServiceDeclaration(serverIf, (byte)0, 0);
             }
         }
     }
-
     private void stopNextService(int serverIf, int status) throws RemoteException {
         if (DBG) Log.d(TAG, "stopNextService() - serverIf=" + serverIf
             + ", status=" + status);
-
         if (status == 0) {
             List<HandleMap.Entry> entries = mHandleMap.getEntries();
             for(HandleMap.Entry entry : entries) {
@@ -1925,16 +1336,13 @@ public class GattService extends ProfileService {
                     entry.serverIf != serverIf ||
                     entry.started == false)
                         continue;
-
                 gattServerStopServiceNative(serverIf, entry.handle);
                 return;
             }
         }
     }
-
     private void deleteServices(int serverIf) {
         if (DBG) Log.d(TAG, "deleteServices() - serverIf=" + serverIf);
-
         /*
          * Figure out which handles to delete.
          * The handles are copied into a new list to avoid race conditions.
@@ -1947,21 +1355,17 @@ public class GattService extends ProfileService {
                     continue;
             handleList.add(entry.handle);
         }
-
         /* Now actually delete the services.... */
         for(Integer handle : handleList) {
             gattServerDeleteServiceNative(serverIf, handle);
         }
     }
-
     private List<UUID> parseUuids(byte[] adv_data) {
         List<UUID> uuids = new ArrayList<UUID>();
-
         int offset = 0;
         while(offset < (adv_data.length-2)) {
             int len = adv_data[offset++];
             if (len == 0) break;
-
             int type = adv_data[offset++];
             switch (type) {
                 case 0x02: // Partial list of 16-bit UUIDs
@@ -1974,20 +1378,16 @@ public class GattService extends ProfileService {
                             "%08x-0000-1000-8000-00805f9b34fb", uuid16)));
                     }
                     break;
-
                 default:
                     offset += (len - 1);
                     break;
             }
         }
-
         return uuids;
     }
-
     /**************************************************************************
      * GATT Test functions
      *************************************************************************/
-
     void gattTestCommand(int command, UUID uuid1, String bda1,
                          int p1, int p2, int p3, int p4, int p5) {
         if (bda1 == null) bda1 = "00:00:00:00:00:00";
@@ -1997,137 +1397,100 @@ public class GattService extends ProfileService {
         else
             gattTestNative(command, 0,0, bda1, p1, p2, p3, p4, p5);
     }
-
     private native void gattTestNative(int command,
                                     long uuid1_lsb, long uuid1_msb, String bda1,
                                     int p1, int p2, int p3, int p4, int p5);
-
     /**************************************************************************
      * Native functions prototypes
      *************************************************************************/
-
     private native static void classInitNative();
     private native void initializeNative();
     private native void cleanupNative();
-
     private native int gattClientGetDeviceTypeNative(String address);
-
     private native void gattClientRegisterAppNative(long app_uuid_lsb,
                                                     long app_uuid_msb);
-
     private native void gattClientUnregisterAppNative(int clientIf);
-
     private native void gattClientScanNative(int clientIf, boolean start);
-
     private native void gattClientConnectNative(int clientIf, String address,
             boolean isDirect);
-
     private native void gattClientDisconnectNative(int clientIf, String address,
             int conn_id);
-
     private native void gattClientRefreshNative(int clientIf, String address);
-
     private native void gattClientSearchServiceNative(int conn_id,
             boolean search_all, long service_uuid_lsb, long service_uuid_msb);
-
     private native void gattClientGetCharacteristicNative(int conn_id,
             int service_type, int service_id_inst_id, long service_id_uuid_lsb,
             long service_id_uuid_msb, int char_id_inst_id, long char_id_uuid_lsb,
             long char_id_uuid_msb);
-
     private native void gattClientGetDescriptorNative(int conn_id, int service_type,
             int service_id_inst_id, long service_id_uuid_lsb, long service_id_uuid_msb,
             int char_id_inst_id, long char_id_uuid_lsb, long char_id_uuid_msb,
             int descr_id_inst_id, long descr_id_uuid_lsb, long descr_id_uuid_msb);
-
     private native void gattClientGetIncludedServiceNative(int conn_id,
             int service_type, int service_id_inst_id,
             long service_id_uuid_lsb, long service_id_uuid_msb,
             int incl_service_id_inst_id, int incl_service_type,
             long incl_service_id_uuid_lsb, long incl_service_id_uuid_msb);
-
     private native void gattClientReadCharacteristicNative(int conn_id,
             int service_type, int service_id_inst_id, long service_id_uuid_lsb,
             long service_id_uuid_msb, int char_id_inst_id, long char_id_uuid_lsb,
             long char_id_uuid_msb, int authReq);
-
     private native void gattClientReadDescriptorNative(int conn_id, int service_type,
             int service_id_inst_id, long service_id_uuid_lsb, long service_id_uuid_msb,
             int char_id_inst_id, long char_id_uuid_lsb, long char_id_uuid_msb,
             int descr_id_inst_id, long descr_id_uuid_lsb, long descr_id_uuid_msb,
             int authReq);
-
     private native void gattClientWriteCharacteristicNative(int conn_id,
             int service_type, int service_id_inst_id, long service_id_uuid_lsb,
             long service_id_uuid_msb, int char_id_inst_id, long char_id_uuid_lsb,
             long char_id_uuid_msb, int write_type, int auth_req, byte[] value);
-
     private native void gattClientWriteDescriptorNative(int conn_id, int service_type,
             int service_id_inst_id, long service_id_uuid_lsb, long service_id_uuid_msb,
             int char_id_inst_id, long char_id_uuid_lsb, long char_id_uuid_msb,
             int descr_id_inst_id, long descr_id_uuid_lsb, long descr_id_uuid_msb,
             int write_type, int auth_req, byte[] value);
-
     private native void gattClientExecuteWriteNative(int conn_id, boolean execute);
-
     private native void gattClientRegisterForNotificationsNative(int clientIf,
             String address, int service_type, int service_id_inst_id,
             long service_id_uuid_lsb, long service_id_uuid_msb,
             int char_id_inst_id, long char_id_uuid_lsb, long char_id_uuid_msb,
             boolean enable);
-
     private native void gattClientReadRemoteRssiNative(int clientIf,
             String address);
-
-    private native void gattAdvertiseNative(int client_if, boolean start);
-
+    private native void gattClientListenNative(int client_if, boolean start);
     private native void gattSetAdvDataNative(int serverIf, boolean setScanRsp, boolean inclName,
             boolean inclTxPower, int minInterval, int maxInterval,
-            int appearance, byte[] manufacturerData, byte[] serviceData, byte[] serviceUuid);
-
+            int appearance, byte[] manufacturerData);
     private native void gattServerRegisterAppNative(long app_uuid_lsb,
                                                     long app_uuid_msb);
-
     private native void gattServerUnregisterAppNative(int serverIf);
-
     private native void gattServerConnectNative(int server_if, String address,
                                              boolean is_direct);
-
     private native void gattServerDisconnectNative(int serverIf, String address,
                                               int conn_id);
-
     private native void gattServerAddServiceNative (int server_if,
             int service_type, int service_id_inst_id,
             long service_id_uuid_lsb, long service_id_uuid_msb,
             int num_handles);
-
     private native void gattServerAddIncludedServiceNative (int server_if,
             int svc_handle, int included_svc_handle);
-
     private native void gattServerAddCharacteristicNative (int server_if,
             int svc_handle, long char_uuid_lsb, long char_uuid_msb,
             int properties, int permissions);
-
     private native void gattServerAddDescriptorNative (int server_if,
             int svc_handle, long desc_uuid_lsb, long desc_uuid_msb,
             int permissions);
-
     private native void gattServerStartServiceNative (int server_if,
             int svc_handle, int transport );
-
     private native void gattServerStopServiceNative (int server_if,
                                                      int svc_handle);
-
     private native void gattServerDeleteServiceNative (int server_if,
                                                        int svc_handle);
-
     private native void gattServerSendIndicationNative (int server_if,
             int attr_handle, int conn_id, byte[] val);
-
     private native void gattServerSendNotificationNative (int server_if,
             int attr_handle, int conn_id, byte[] val);
-
     private native void gattServerSendResponseNative (int server_if,
             int conn_id, int trans_id, int status, int handle, int offset,
             byte[] val, int auth_req);
-}
+}
\ No newline at end of file
diff --git a/src/com/android/bluetooth/gatt/HandleMap.java b/src/com/android/bluetooth/gatt/HandleMap.java
index 187625a..d5ca15a 100644
--- a/src/com/android/bluetooth/gatt/HandleMap.java
+++ b/src/com/android/bluetooth/gatt/HandleMap.java
@@ -98,9 +98,8 @@ class HandleMap {
         mRequestMap.clear();
     }
 
-    void addService(int serverIf, int handle, UUID uuid, int serviceType, int instance,
-        boolean advertisePreferred) {
-        mEntries.add(new Entry(serverIf, handle, uuid, serviceType, instance, advertisePreferred));
+    void addService(int serverIf, int handle, UUID uuid, int serviceType, int instance) {
+        mEntries.add(new Entry(serverIf, handle, uuid, serviceType, instance, false));
     }
 
     void addCharacteristic(int serverIf, int handle, UUID uuid, int serviceHandle) {
diff --git a/src/com/android/bluetooth/gatt/ServiceDeclaration.java b/src/com/android/bluetooth/gatt/ServiceDeclaration.java
index 1d0bc4e..cd48b73 100644
--- a/src/com/android/bluetooth/gatt/ServiceDeclaration.java
+++ b/src/com/android/bluetooth/gatt/ServiceDeclaration.java
@@ -53,7 +53,7 @@ class ServiceDeclaration {
           this.uuid = uuid;
           this.instance = instance;
           this.serviceType = serviceType;
-          this.advertisePreferred = advertisePreferred;
+          this.advertisePreferred = false;
         }
 
         Entry(UUID uuid, int properties, int permissions, int instance) {
@@ -78,9 +78,8 @@ class ServiceDeclaration {
         mEntries = new ArrayList<Entry>();
     }
 
-    void addService(UUID uuid, int serviceType, int instance, int minHandles,
-        boolean advertisePreferred) {
-        mEntries.add(new Entry(uuid, serviceType, instance, advertisePreferred));
+    void addService(UUID uuid, int serviceType, int instance, int minHandles) {
+        mEntries.add(new Entry(uuid, serviceType, instance));
         if (minHandles == 0) {
             ++mNumHandles;
         } else {
@@ -115,7 +114,7 @@ class ServiceDeclaration {
     boolean isServiceAdvertisePreferred(UUID uuid) {
       for (Entry entry : mEntries) {
           if (entry.uuid.equals(uuid)) {
-              return entry.advertisePreferred;
+              return false;
           }
       }
       return false;

project packages/apps/Browser/
diff --git a/src/com/android/browser/BrowserSettings.java b/src/com/android/browser/BrowserSettings.java
index 9b96c3ae..aa4db762 100644
--- a/src/com/android/browser/BrowserSettings.java
+++ b/src/com/android/browser/BrowserSettings.java
@@ -606,7 +606,7 @@ public class BrowserSettings implements OnSharedPreferenceChangeListener,
             }
         }
 
-        int cookiesBefore = CookieManager.getInstance().countCookies();
+        int cookiesBefore = 0; //CookieManager.getInstance().countCookies();
         if (savedCookies == cookiesBefore) {
             // all cookies are whitelisted cookies. our job is done.
             return;
@@ -628,7 +628,7 @@ public class BrowserSettings implements OnSharedPreferenceChangeListener,
             }
         }
 
-        int cookiesAfter = CookieManager.getInstance().countCookies();
+        int cookiesAfter = 0; //CookieManager.getInstance().countCookies();
         int cookiesDeleted = cookiesBefore - cookiesAfter;
         boolean munched = cookiesDeleted > 0;
 

project packages/apps/Exchange/
diff --git a/Android.mk b/Android.mk
deleted file mode 100644
index 7a3de443..00000000
--- a/Android.mk
+++ /dev/null
@@ -1,50 +0,0 @@
-# Copyright 2008, The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-LOCAL_PATH:= $(call my-dir)
-include $(CLEAR_VARS)
-
-#
-# Exchange2
-#
-LOCAL_MODULE_TAGS := optional
-
-# Include res dir from emailcommon
-emailcommon_dir := ../Email/emailcommon
-res_dir := res $(emailcommon_dir)/res
-
-LOCAL_RESOURCE_DIR := $(addprefix $(LOCAL_PATH)/, $(res_dir))
-
-LOCAL_AAPT_FLAGS := --auto-add-overlay
-LOCAL_AAPT_FLAGS += --extra-packages com.android.emailcommon
-
-LOCAL_SRC_FILES := $(call all-java-files-under, src)
-LOCAL_SRC_FILES += $(call all-java-files-under, build/src)
-
-LOCAL_STATIC_JAVA_LIBRARIES := android-common com.android.emailcommon com.android.emailsync
-LOCAL_STATIC_JAVA_LIBRARIES += calendar-common
-LOCAL_STATIC_JAVA_LIBRARIES += android-support-v4
-
-LOCAL_PACKAGE_NAME := Exchange2
-LOCAL_OVERRIDES_PACKAGES := Exchange
-
-LOCAL_PROGUARD_FLAG_FILES := proguard.flags
-LOCAL_SDK_VERSION := 19
-
-LOCAL_EMMA_COVERAGE_FILTER += +com.android.exchange.*
-
-include $(BUILD_PACKAGE)
-
-# additionally, build unit tests in a separate .apk
-include $(call all-makefiles-under,$(LOCAL_PATH))

project packages/apps/Gallery2/
diff --git a/src/org/codeaurora/gallery3d/video/SettingsActivity.java b/src/org/codeaurora/gallery3d/video/SettingsActivity.java
index d58dd3c3b..eef8457cf 100755
--- a/src/org/codeaurora/gallery3d/video/SettingsActivity.java
+++ b/src/org/codeaurora/gallery3d/video/SettingsActivity.java
@@ -50,7 +50,7 @@ import android.preference.PreferenceScreen;
 import android.provider.ContactsContract;
 import android.provider.Settings.System;
 import android.provider.Telephony;
-import android.telephony.MSimTelephonyManager;
+//import android.telephony.MSimTelephonyManager;
 import android.telephony.TelephonyManager;
 import android.text.method.DigitsKeyListener;
 import android.util.Log;

project packages/apps/PhoneCommon/
diff --git a/src/com/android/phone/common/CallLogAsync.java b/src/com/android/phone/common/CallLogAsync.java
index 9ded014..9fa3d19 100644
--- a/src/com/android/phone/common/CallLogAsync.java
+++ b/src/com/android/phone/common/CallLogAsync.java
@@ -167,8 +167,8 @@ public class CallLogAsync {
                 try {
                     // May block.
                     result[i] = Calls.addCall(c.ci, c.context, c.number, c.presentation,
-                            c.callType, c.timestamp, c.durationInSec, c.subscription,
-                            c.durationType);
+                            c.callType, c.timestamp, c.durationInSec );
+                          //, c.subscription, c.durationType);
                 } catch (Exception e) {
                     // This must be very rare but may happen in legitimate cases.
                     // e.g. If the phone is encrypted and thus write request fails, it may

project packages/apps/ResurrectionSetup/
diff --git a/src/com/cyanogenmod/account/receiver/ApplyHexoIconsReceiver.java b/src/com/cyanogenmod/account/receiver/ApplyHexoIconsReceiver.java
index 31935f2..ccdec42 100644
--- a/src/com/cyanogenmod/account/receiver/ApplyHexoIconsReceiver.java
+++ b/src/com/cyanogenmod/account/receiver/ApplyHexoIconsReceiver.java
@@ -23,7 +23,9 @@ import android.content.Intent;
 import android.content.pm.PackageInfo;
 import android.content.pm.PackageManager;
 import android.content.pm.ThemeUtils;
-import android.content.res.CustomTheme;
+//import android.content.res.CustomTheme;
+import android.content.res.ThemeConfig;
+import android.content.pm.ThemeUtils;
 import android.content.res.ThemeManager;
 import android.provider.ThemesContract;
 import android.util.Log;
@@ -39,7 +41,7 @@ public class ApplyHexoIconsReceiver extends BroadcastReceiver {
             "com.cyanogenmod.account.intent.action.APPLY_HEXO_ICONS";
 
     public void onReceive(Context context, Intent intent) {
-        if (ThemeUtils.getDefaultThemePackageName(context) != CustomTheme.HOLO_DEFAULT
+        if (ThemeUtils.getDefaultThemePackageName(context) != ThemeConfig.HOLO_DEFAULT
                 && isPackageInstalled(context, HEXO_ICONS_PACKAGE_NAME)) {
             ArrayList<String> componentList = new ArrayList<String>();
             componentList.add(ThemesContract.ThemesColumns.MODIFIES_ICONS);
diff --git a/src/com/cyanogenmod/account/setup/PersonalizationPage.java b/src/com/cyanogenmod/account/setup/PersonalizationPage.java
index 559b3a0..a9a4809 100644
--- a/src/com/cyanogenmod/account/setup/PersonalizationPage.java
+++ b/src/com/cyanogenmod/account/setup/PersonalizationPage.java
@@ -18,7 +18,9 @@ package com.cyanogenmod.account.setup;
 import android.app.Fragment;
 import android.content.Context;
 import android.content.pm.ThemeUtils;
-import android.content.res.CustomTheme;
+//import android.content.res.CustomTheme;
+import android.content.res.ThemeConfig;
+import android.content.pm.ThemeUtils;
 import android.graphics.ColorFilter;
 import android.graphics.ColorMatrix;
 import android.graphics.ColorMatrixColorFilter;
@@ -136,7 +138,7 @@ public class PersonalizationPage extends Page {
 
 
     protected static boolean hideThemeSwitch(Context context) {
-        return ThemeUtils.getDefaultThemePackageName(context) == CustomTheme.HOLO_DEFAULT;
+        return ThemeUtils.getDefaultThemePackageName(context) == ThemeConfig.HOLO_DEFAULT;
     }
 
     public static boolean skipPage(Context context) {

project packages/apps/Settings/
diff --git a/res/values/cm_strings.xml b/res/values/cm_strings.xml
index 9ecac0096..28320e54f 100644
--- a/res/values/cm_strings.xml
+++ b/res/values/cm_strings.xml
@@ -61,6 +61,13 @@
     <string name="increasing_ring_interval_5seconds">5 seconds</string>
     <string name="increasing_ring_interval_10seconds">10 seconds</string>
 
+    <!-- Vold Switchable Pair -->
+    <string name="storage_switch_title">Use external SD as primary</string>
+    <string name="storage_switch_summary_off">Using expanded internal storage for apps and media</string>
+    <string name="storage_switch_summary_on">Using SD Card for apps and media</string>
+    <string name="reboot_prompt_title">Reboot required</string>
+    <string name="reboot_prompt_message">In order to apply the changed configuration, a reboot is required.\n\nDo you want to reboot now?</string>
+
     <!-- Profiles settings -->
     <string name="profiles_settings_title">Profiles</string>
     <string name="profiles_add">Add</string>
diff --git a/res/xml/device_info_memory.xml b/res/xml/device_info_memory.xml
index 356beaf1e..812951b2b 100644
--- a/res/xml/device_info_memory.xml
+++ b/res/xml/device_info_memory.xml
@@ -17,6 +17,12 @@
 <PreferenceScreen xmlns:android="http://schemas.android.com/apk/res/android"
         android:title="@string/storage_settings_title">
 
+    <CheckBoxPreference
+        android:key="key_switch_storage"
+        android:title="@string/storage_switch_title"
+        android:summaryOn="@string/storage_switch_summary_on"
+        android:summaryOff="@string/storage_switch_summary_off" />
+
 <!-- Preference categories are dynamically created based on the list of available storage volumes -->
     <!-- Partition info -->
 
diff --git a/src/com/android/settings/deviceinfo/Memory.java b/src/com/android/settings/deviceinfo/Memory.java
index 52fef32b6..b30a89887 100644
--- a/src/com/android/settings/deviceinfo/Memory.java
+++ b/src/com/android/settings/deviceinfo/Memory.java
@@ -47,7 +47,10 @@ import android.view.Menu;
 import android.view.MenuInflater;
 import android.view.MenuItem;
 import android.widget.Toast;
-
+import android.os.PowerManager;
+import android.os.SystemProperties;
+import android.preference.CheckBoxPreference;
+import android.text.TextUtils;
 import com.android.settings.R;
 import com.android.settings.SettingsPreferenceFragment;
 import com.android.settings.Utils;
@@ -80,6 +83,10 @@ public class Memory extends SettingsPreferenceFragment {
     private UsbManager mUsbManager;
 
     private ArrayList<StorageVolumePreferenceCategory> mCategories = Lists.newArrayList();
+    private static final String KEY_SWITCH_STORAGE = "key_switch_storage";
+    private static final String VOLD_SWITCH_PERSIST_PROP = "persist.sys.vold.switchexternal";
+    private static final String VOLD_SWITCHABLEPAIR_PROP = "persist.sys.vold.switchablepair";
+    private CheckBoxPreference mSwitchStoragePref;
 
     @Override
     public void onCreate(Bundle icicle) {
@@ -93,6 +100,26 @@ public class Memory extends SettingsPreferenceFragment {
         mStorageManager.registerListener(mStorageListener);
 
         addPreferencesFromResource(R.xml.device_info_memory);
+        String voldswitch = SystemProperties.get(VOLD_SWITCH_PERSIST_PROP, "0");
+        mSwitchStoragePref = (CheckBoxPreference) findPreference(KEY_SWITCH_STORAGE);
+        mSwitchStoragePref.setChecked("1".equals(voldswitch));
+        if (!Environment.isExternalStorageEmulated()) {
+            Log.i(TAG, "Checking to see if vold switch is possible on this device.");
+            String PRIMARY_STORAGE = System.getenv("EXTERNAL_STORAGE");
+            String SECONDARY_STORAGE = System.getenv("SECONDARY_STORAGE");
+            if (!TextUtils.isEmpty(PRIMARY_STORAGE) && !TextUtils.isEmpty(SECONDARY_STORAGE)) {
+                SystemProperties.set(VOLD_SWITCHABLEPAIR_PROP, PRIMARY_STORAGE + ',' +
+                       SECONDARY_STORAGE);
+                Log.i(TAG, "Setting persist.sys.vold.switchablepair=" + PRIMARY_STORAGE + ',' +
+                        SECONDARY_STORAGE);
+            } else {
+                Log.i(TAG, "Vold switch not possible on this device.");
+            }
+        }
+
+        if (SystemProperties.get(VOLD_SWITCHABLEPAIR_PROP).equals("")) {
+            removePreference(KEY_SWITCH_STORAGE);
+        }
 
         addCategory(StorageVolumePreferenceCategory.buildForInternal(context));
 
@@ -213,7 +240,13 @@ public class Memory extends SettingsPreferenceFragment {
 
     @Override
     public boolean onPreferenceTreeClick(PreferenceScreen preferenceScreen, Preference preference) {
-        if (StorageVolumePreferenceCategory.KEY_CACHE.equals(preference.getKey())) {
+        if(preference == mSwitchStoragePref) {
+            Log.d(TAG,"Setting persist.sys.vold.switchexternal to "+(
+                    mSwitchStoragePref.isChecked() ? "1" : "0"));
+            SystemProperties.set(VOLD_SWITCH_PERSIST_PROP,
+                    mSwitchStoragePref.isChecked() ? "1" : "0");
+            showRebootPrompt();
+        } else if (StorageVolumePreferenceCategory.KEY_CACHE.equals(preference.getKey())) {
             ConfirmClearCacheFragment.show(this);
             return true;
         }
@@ -423,4 +456,21 @@ public class Memory extends SettingsPreferenceFragment {
             return builder.create();
         }
     }
+
+    private void showRebootPrompt() {
+        AlertDialog dialog = new AlertDialog.Builder(getActivity())
+                .setTitle(R.string.reboot_prompt_title)
+                .setMessage(R.string.reboot_prompt_message)
+                .setPositiveButton(R.string.yes, new DialogInterface.OnClickListener() {
+                    @Override
+                    public void onClick(DialogInterface dialog, int which) {
+                        PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE);
+                        pm.reboot(null);
+                    }
+                })
+                .setNegativeButton(R.string.no, null)
+                .create();
+
+        dialog.show();
+    }
 }

project packages/apps/ThemeChooser/
diff --git a/src/org/cyanogenmod/theme/chooser/AppReceiver.java b/src/org/cyanogenmod/theme/chooser/AppReceiver.java
index 72719d3..d3c0487 100644
--- a/src/org/cyanogenmod/theme/chooser/AppReceiver.java
+++ b/src/org/cyanogenmod/theme/chooser/AppReceiver.java
@@ -46,17 +46,6 @@ public class AppReceiver extends BroadcastReceiver {
             }
         } else if (Intent.ACTION_PACKAGE_FULLY_REMOVED.equals(action)) {
             NotificationHelper.cancelNotificationForPackage(context, pkgName);
-        } else if (Intent.ACTION_THEME_RESOURCES_CACHED.equals(action)) {
-            final String themePkgName = intent.getStringExtra(Intent.EXTRA_THEME_PACKAGE_NAME);
-            final int result = intent.getIntExtra(Intent.EXTRA_THEME_RESULT,
-                    PackageManager.INSTALL_FAILED_THEME_UNKNOWN_ERROR);
-            Set<String> processingThemes =
-                    PreferenceUtils.getInstalledThemesBeingProcessed(context);
-            if (processingThemes != null &&
-                    processingThemes.contains(themePkgName) && result >= 0) {
-                NotificationHelper.postThemeInstalledNotification(context, themePkgName);
-                PreferenceUtils.removeThemeBeingProcessed(context, themePkgName);
-            }
         }
     }
 
@@ -74,6 +63,7 @@ public class AppReceiver extends BroadcastReceiver {
 
     private boolean isThemeBeingProcessed(Context context, String pkgName) {
         ThemeManager tm = (ThemeManager) context.getSystemService(Context.THEME_SERVICE);
-        return tm.isThemeBeingProcessed(pkgName);
+        //return tm.isThemeBeingProcessed(pkgName);
+        return true;
     }
 }
diff --git a/src/org/cyanogenmod/theme/chooser/ChooserDetailFragment.java b/src/org/cyanogenmod/theme/chooser/ChooserDetailFragment.java
index 39475a8..a39512b 100644
--- a/src/org/cyanogenmod/theme/chooser/ChooserDetailFragment.java
+++ b/src/org/cyanogenmod/theme/chooser/ChooserDetailFragment.java
@@ -191,7 +191,7 @@ public class ChooserDetailFragment extends Fragment implements LoaderManager.Loa
 
         getLoaderManager().initLoader(LOADER_ID_THEME_INFO, null, this);
         getLoaderManager().initLoader(LOADER_ID_APPLIED_THEME, null, this);
-        mService = (ThemeManager) getActivity().getSystemService(Context.THEME_SERVICE);
+     //   mService = (ThemeManager) getActivity().getSystemService(Context.THEME_SERVICE);
         return v;
     }
 
@@ -211,26 +211,20 @@ public class ChooserDetailFragment extends Fragment implements LoaderManager.Loa
     @Override
     public void onResume() {
         super.onResume();
-        if (mService != null) {
-            mService.onClientResumed(this);
-        }
+    //    if (mService != null) {            mService.onClientResumed(this);        }
         refreshApplyButton();
     }
 
     @Override
     public void onPause() {
         super.onPause();
-        if (mService != null) {
-            mService.onClientPaused(this);
-        }
+     //   if (mService != null) {            mService.onClientPaused(this);        }
     }
 
     @Override
     public void onDestroy() {
         super.onDestroy();
-        if (mService != null) {
-            mService.onClientDestroyed(this);
-        }
+   //     if (mService != null) {            mService.onClientDestroyed(this);        }
     }
 
     @Override
@@ -456,7 +450,7 @@ public class ChooserDetailFragment extends Fragment implements LoaderManager.Loa
         }
 
         //Determine if the apply button's progress
-        int progress = (mService == null) ? 0 : mService.getProgress();
+        int progress = 0; // (mService == null) ? 0 : mService.getProgress();
         if (progress != 0) {
             clip.setLevel(progress * 100);
             mApply.setText(R.string.applying);
diff --git a/src/org/cyanogenmod/theme/util/IconPreviewHelper.java b/src/org/cyanogenmod/theme/util/IconPreviewHelper.java
index f9d1f6d..556ee15 100644
--- a/src/org/cyanogenmod/theme/util/IconPreviewHelper.java
+++ b/src/org/cyanogenmod/theme/util/IconPreviewHelper.java
@@ -136,12 +136,12 @@ public class IconPreviewHelper {
         ComponentName component = new ComponentName(pkgName, activityName);
         PackageManager pm = mContext.getPackageManager();
         Resources res = null;
+        /*
         try {
             ActivityInfo info = pm.getActivityInfo(component, 0);
             ApplicationInfo appInfo = pm.getApplicationInfo(pkgName, 0);
 
             res = pm.getThemedResourcesForApplication(pkgName, mThemePkgName);
-
             final int iconId = info.icon != 0 ? info.icon : appInfo.icon;
             info.themedIcon = 0;
             setupComposedIcon(res, info, iconId);
@@ -149,6 +149,7 @@ public class IconPreviewHelper {
         } catch (NameNotFoundException e2) {
            Log.w(TAG, "Unable to get the icon for " + pkgName + " using default");
         }
+        */
         drawable = (drawable != null) ?
                 getComposedIcon(res, drawable) : getFullResDefaultActivityIcon();
         return drawable;
@@ -156,8 +157,8 @@ public class IconPreviewHelper {
 
     private Drawable getComposedIcon(Resources res, Drawable baseIcon) {
         ComposedIconInfo iconInfo = mIconPackHelper.getComposedIconInfo();
-        if (res != null && iconInfo != null && (iconInfo.iconBacks != null ||
-                iconInfo.iconMask != 0 || iconInfo.iconUpon != 0)) {
+        if (res != null && iconInfo != null && (iconInfo.iconBacks != null )) {
+               // iconInfo.iconMask != 0 || iconInfo.iconUpon != 0)) {
             return IconPackHelper.IconCustomizer.getComposedIconDrawable(baseIcon, res, iconInfo);
         }
         return baseIcon;
@@ -165,7 +166,8 @@ public class IconPreviewHelper {
 
     private void setupComposedIcon(Resources res, ActivityInfo info, int iconId) {
         ComposedIconInfo iconInfo = mIconPackHelper.getComposedIconInfo();
-        if (iconInfo.iconBacks == null && iconInfo.iconMask == 0 && iconInfo.iconUpon == 0) {
+       // if (iconInfo.iconBacks == null && iconInfo.iconMask == 0 && iconInfo.iconUpon == 0) {
+       if (iconInfo.iconBacks == null ) {
             return;
         }
 

project packages/providers/ThemesProvider/
diff --git a/src/org/cyanogenmod/themes/provider/AppReceiver.java b/src/org/cyanogenmod/themes/provider/AppReceiver.java
index c856abd..f028316 100644
--- a/src/org/cyanogenmod/themes/provider/AppReceiver.java
+++ b/src/org/cyanogenmod/themes/provider/AppReceiver.java
@@ -61,6 +61,7 @@ public class AppReceiver extends BroadcastReceiver {
                     // added to the DB when ACTION_THEME_RESOURCES_CACHED is received
                     PreferenceUtils.addThemeBeingProcessed(context, pkgName);
                 }
+/*
             } else if (Intent.ACTION_THEME_RESOURCES_CACHED.equals(action)) {
                 final String themePkgName = intent.getStringExtra(Intent.EXTRA_THEME_PACKAGE_NAME);
                 final int result = intent.getIntExtra(Intent.EXTRA_THEME_RESULT,
@@ -76,6 +77,7 @@ public class AppReceiver extends BroadcastReceiver {
                         ThemePackageHelper.insertPackage(context, themePkgName);
                     }
                 }
+*/
             }
         } catch(NameNotFoundException e) {
             Log.e(TAG, "Unable to add package to theme's provider ", e);
@@ -99,6 +101,6 @@ public class AppReceiver extends BroadcastReceiver {
 
     private boolean isThemeBeingProcessed(Context context, String pkgName) {
         ThemeManager tm = (ThemeManager) context.getSystemService(Context.THEME_SERVICE);
-        return tm.isThemeBeingProcessed(pkgName);
+        return true; //tm.isThemeBeingProcessed(pkgName);
     }
 }

project prebuilts/misc/
diff --git a/common/ub-uiautomator/Android.mk b/common/ub-uiautomator/Android.mk
index 1e4a212..6fc411c 100644
--- a/common/ub-uiautomator/Android.mk
+++ b/common/ub-uiautomator/Android.mk
@@ -16,7 +16,7 @@ LOCAL_PATH:= $(call my-dir)
 
 include $(CLEAR_VARS)
 
-LOCAL_MODULE := ub-uiautomator
+LOCAL_MODULE := ub-ti-ga-majke
 LOCAL_MODULE_TAGS := optional
 LOCAL_SRC_FILES := ub-uiautomator.jar
 LOCAL_MODULE_CLASS := JAVA_LIBRARIES

project system/core/
diff --git a/init/devices.c b/init/devices.c
index 273553d7..61dafa7b 100644
--- a/init/devices.c
+++ b/init/devices.c
@@ -847,6 +847,7 @@ file_free_out:
     free(file1);
     free(file2);
     free(file3);
+    free(file4);
 data_free_out:
     free(data);
 loading_free_out:

project system/netd/
diff --git a/Android.mk b/Android.mk
index 9c383d0..bd56b00 100644
--- a/Android.mk
+++ b/Android.mk
@@ -19,7 +19,6 @@ LOCAL_SRC_FILES:=                                      \
                   PppController.cpp                    \
                   ResolverController.cpp               \
                   SecondaryTableController.cpp         \
-                  SoftapController.cpp                 \
                   TetherController.cpp                 \
                   oem_iptables_hook.cpp                \
                   UidMarkMap.cpp                       \
@@ -46,18 +45,14 @@ LOCAL_SHARED_LIBRARIES := libstlport libsysutils liblog libcutils libnetutils \
                           libcrypto libhardware_legacy libmdnssd libdl \
                           liblogwrap
 
-ifneq ($(BOARD_HOSTAPD_DRIVER),)
-  LOCAL_CFLAGS += -DHAVE_HOSTAPD
-  ifneq ($(BOARD_HOSTAPD_DRIVER_NAME),)
-    LOCAL_CFLAGS += -DHOSTAPD_DRIVER_NAME=\"$(BOARD_HOSTAPD_DRIVER_NAME)\"
-  endif
-endif
-
-ifeq ($(BOARD_HAS_QCOM_WLAN_SDK), true)
-  LOCAL_SRC_FILES += QsoftapCmd.cpp
-  LOCAL_CFLAGS += -DQSAP_WLAN
-  LOCAL_SHARED_LIBRARIES += libqsap_sdk
-  LOCAL_C_INCLUDES += $(LOCAL_PATH)/../qcom/softap/sdk/
+ifeq ($(BOARD_HAS_ATH_WLAN),true)
+  LOCAL_CFLAGS += -DATH_WLAN
+  LOCAL_CFLAGS += -DWIFI_MODULE_PATH=\"$(WIFI_DRIVER_MODULE_PATH)\"
+  LOCAL_C_INCLUDES += external/wpa_supplicant_8/wpa_supplicant/src/common
+  LOCAL_SRC_FILES += SoftapControllerATH.cpp
+  LOCAL_SHARED_LIBRARIES := $(LOCAL_SHARED_LIBRARIES) libwpa_client
+else
+   LOCAL_SRC_FILES += SoftapController.cpp
 endif
 
 include $(BUILD_EXECUTABLE)
diff --git a/CommandListener.cpp b/CommandListener.cpp
index 63c2615..627e0e1 100644
--- a/CommandListener.cpp
+++ b/CommandListener.cpp
@@ -1062,9 +1062,18 @@ int CommandListener::SoftapCmd::runCommand(SocketClient *cli,
                      "Missing argument in a SoftAP command", false);
         return 0;
     }
-
+    
+#ifdef ATH_WLAN
+    if (!strcmp(argv[1], "start")) {
+        rc = sSoftapCtrl->startDriver(argv[2]);
+    } else if (!strcmp(argv[1], "stop")) {
+        rc = sSoftapCtrl->stopDriver(argv[2]);
+    } else if (!strcmp(argv[1], "startap")) {
+        rc = sSoftapCtrl->startSoftap();
+#else
     if (!strcmp(argv[1], "startap")) {
         rc = sSoftapCtrl->startSoftap();
+#endif
     } else if (!strcmp(argv[1], "stopap")) {
         rc = sSoftapCtrl->stopSoftap();
     } else if (!strcmp(argv[1], "fwreload")) {
diff --git a/SoftapController.cpp b/SoftapController.cpp
index 825233e..7020712 100644
--- a/SoftapController.cpp
+++ b/SoftapController.cpp
@@ -140,7 +140,7 @@ int SoftapController::setSoftap(int argc, char *argv[]) {
             channel = AP_CHANNEL_DEFAULT;
     }
 
-    asprintf(&wbuf, "interface=%s\ndriver=" HOSTAPD_DRIVER_NAME "\nctrl_interface="
+    asprintf(&wbuf, "interface=%s\ndriver=nl80211\nctrl_interface="
             "/data/misc/wifi/hostapd\nssid=%s\nchannel=%d\nieee80211n=1\n"
             "hw_mode=g\nignore_broadcast_ssid=%d\n",
             argv[2], argv[3], channel, hidden);
diff --git a/SoftapController.h b/SoftapController.h
index 7063067..b520fca 100644
--- a/SoftapController.h
+++ b/SoftapController.h
@@ -32,12 +32,20 @@ public:
     SoftapController();
     virtual ~SoftapController();
 
+#ifdef ATH_WLAN
+    int startDriver(const char *iface);
+    int stopDriver(const char *iface);
+#endif
     int startSoftap();
     int stopSoftap();
     bool isSoftapStarted();
     int setSoftap(int argc, char *argv[]);
     int fwReloadSoftap(int argc, char *argv[]);
 private:
+#ifdef ATH_WLAN
+    char mBuf[SOFTAP_MAX_BUFFER_SIZE];
+    char mIface[IFNAMSIZ];
+#endif
     pid_t mPid;
     void generatePsk(char *ssid, char *passphrase, char *psk);
 };

project vendor/cm/
diff --git a/config/common.mk b/config/common.mk
index 8951349..80fa297 100644
--- a/config/common.mk
+++ b/config/common.mk
@@ -190,27 +190,39 @@ PRODUCT_PACKAGES += \
 PRODUCT_PACKAGES += \
     rsync
 
+# Stagefright FFMPEG plugin
+PRODUCT_PACKAGES += \
+    libstagefright_soft_ffmpegadec \
+    libstagefright_soft_ffmpegvdec \
+    libFFmpegExtractor \
+    libnamparser
+
 # These packages are excluded from user builds
 ifneq ($(TARGET_BUILD_VARIANT),user)
 
 PRODUCT_PACKAGES += \
     procmem \
     procrank \
-    CMUpdater \
+ #   CMUpdater \
     Superuser \
     su
 
 # Terminal Emulator
 PRODUCT_COPY_FILES +=  \
     vendor/cm/proprietary/Term.apk:system/app/Term.apk \
-    vendor/cm/proprietary/lib/armeabi/libjackpal-androidterm4.so:system/lib/libjackpal-androidterm4.so
+    vendor/cm/proprietary/TotalCMD.apk:system/priv-app/TotalCMD.apk \
+    vendor/cm/proprietary/K9Mail.apk:system/priv-app/K9Mail.apk \
+    vendor/cm/proprietary/getChromium.apk:system/priv-app/getChromium.apk \
+    vendor/cm/proprietary/FDroid.apk:system/priv-app/FDroid.apk \
+    vendor/cm/proprietary/lib/armeabi/libjackpal-androidterm5.so:system/lib/libjackpal-androidterm5.so \
+    vendor/cm/proprietary/lib/armeabi/libjackpal-termexec2.so:system/lib/libjackpal-termexec2.so
 
 PRODUCT_PROPERTY_OVERRIDES += \
-    persist.sys.root_access=1
+    persist.sys.root_access=3
 else
 
 PRODUCT_PROPERTY_OVERRIDES += \
-    persist.sys.root_access=0
+    persist.sys.root_access=1
 
 endif
 
